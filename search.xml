<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Python学习笔记（一）]]></title>
      <url>%2F2017%2F03%2F23%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[基础知识数字和表达式的注意点整数除法(/)1/2 结果是0。这个其实是类似与OC语的取整运算。那么怎么才能算出小数呢？ 有两种方法： 运用实数（包含小数点的十进制数，如：10.0）而不是整数进行运算。实数在Python中被称为浮点数，两者相除，如果有一个浮点数，结果就是浮点数，如：1.0/2、1 / 2.0、1/2.，结果都是0.5； 让python改变除法的执行方式。可以通过在运行除法之前，添加使用from __future__ import division。来告诉Python只执行普通的除法。这个时候1/2结果就是0.5。 通过命令行运行Python,可以使用命令开关-Qnew。(这里就不介绍了) 123&gt;&gt;&gt; from __future__ import division&gt;&gt;&gt; 1/20.5 通过上面的第二种方法已经将取整运算的/方法变成了普通的除法运算，而不是取整运算，那么怎么才能继续使用取整运算呢？//使用两个就可以了。 123456&gt;&gt;&gt; from __future__ import division&gt;&gt;&gt; 1/20.5&gt;&gt;&gt; 1//20&gt;&gt;&gt; 取余(模除%)对浮点数也同样适用： 1234&gt;&gt;&gt; 10%31&gt;&gt;&gt; 2.75%0.50.25 幂运算（乘方**）注意：幂运算符的优先级比取反(-)的要高。也就是-3**2等价于-(3**2),但是不等价于(-3)**2 12345678&gt;&gt;&gt; 3**29&gt;&gt;&gt; -3**3-27&gt;&gt;&gt; -(3**3)-27&gt;&gt;&gt; (-3)**29 长整型长整型和普通整型一样，但是后面有一个L。但是可以混合使用。除非需要检验类型，否则不用担心两者的区别。 12&gt;&gt;&gt; 123123123123123123123L + 123123123123123123123L +23246246246246246246269L 变量代表（或者引用）某值得名字。如下：x=3,可以称作是赋值操作，也可以称作是将变量x绑定了值3。 123&gt;&gt;&gt; x = 3&gt;&gt;&gt; x * 39 注意： 在使用变量的时候必须先给变量赋值，否则会报错。 语句语句（做某事）和表达式（某事）之间的区别在赋值时会表现得更加明显一些。因为语句不是表达式，所以没有值可供交互式解释器打印出来： 12345678&gt;&gt;&gt; print &quot;表达式&quot;表达式&gt;&gt;&gt; x=3&gt;&gt;&gt;&gt;&gt;&gt; print &quot;语句&quot;语句&gt;&gt;&gt; print &quot;我是print语句执行出来的&quot;我是print语句执行出来的 获取用户输入-input函数下面的10和30都是用户自己手动输入的。input函数完成了用户与计算机的交互。 1234567&gt;&gt;&gt; x = input(&quot;x:&quot;)x:10&gt;&gt;&gt; y = input(&quot;y:&quot;)y:30&gt;&gt;&gt; print(x*y)300&gt;&gt;&gt; 函数例如上面讲的乘方（ ** ）。事实上可以使用一个函数来代替：pow。 12&gt;&gt;&gt; pow(3,4)81 这就是3的4次方的结果。 函数就像是一个实现特定功能的小程序。通常把pow等标准函数称为內建函数。 很多內建函数也可以用于数值表达式：`abs函数未获取绝对值`` 1234&gt;&gt;&gt; 10 + pow(3,4)91&gt;&gt;&gt; 10 + abs(-100)110 下面介绍与整数除法相关的两个有意思的函数： round函数：将结果四舍五入为最接近的整数；floor函数：将给定的数值向下取整为某个特定的整数；ceil函数：将给定的数值向上取整为某个特定的整数； 注意：floor函数和ceil函数是需要引入math模块才可以使用的。 12345678910111213141516171819202122232425&gt;&gt;&gt; round(10/3.0)3.0&gt;&gt;&gt; round(29.9/5)6.0&gt;&gt;&gt; round(-10/3.0)-3.0&gt;&gt;&gt; round(-29.9/5)-6.0&gt;&gt;&gt; import math&gt;&gt;&gt; math.floor(10/3.0)3.0&gt;&gt;&gt; math.floor(29.9/5)5.0&gt;&gt;&gt; math.floor(-10/3.0)-4.0&gt;&gt;&gt; math.floor(-29.9/5)-6.0&gt;&gt;&gt; math.ceil(10/3.0)4.0&gt;&gt;&gt; math.ceil(29.9/5)6.0&gt;&gt;&gt; math.ceil(-10/3.0)-3.0&gt;&gt;&gt; math.ceil(-29.9/5)-5.0 模块模块就是导入Python来增强其功能的扩展。需要用import来导入。如上面的math。 它的所用方式：“模块.函数”-&gt;math.floor。 如果你不想每次调用函数的时候都加上模块的话，可以使用from 模块 import 函数，这样的写法。但是这个一定要在你确定自己不会导入多个同名函数（从不同的模块导入）的情况下。 123&gt;&gt;&gt; from math import sqrt&gt;&gt;&gt; sqrt(9)3.0 我们还有一种方式可以来引用函数，那就是使用变量来引用函数（或者Python之中大多数的对象）：sq = math.sqrt，然后可以直接通过sq来操作函数。 1234&gt;&gt;&gt; import math&gt;&gt;&gt; sq = math.sqrt&gt;&gt;&gt; sq(9)3.0 cmath和复数sqrt函数用来计算一个数的平方根，如果此时给他的是一个负数的话，他就没办法运行了。但是作为数学系的，我告诉你，按道理他是有值的，就是虚数。 所以下面我们介绍一个复数模块cmath。 123&gt;&gt;&gt; import cmath&gt;&gt;&gt; cmath.sqrt(-1)1j 这个1j就是结果，而j就代表这是虚数。下面我们举一个更加复杂的复数的例子。 12&gt;&gt;&gt; (-1 + 3j)*(12 + 12j)(-48+24j) 这就说明了，python是可以计算复数的。当然了，Python里面是没有虚数这个概念的，虚数就是实数部分为0的复数。 保存并执行程序我们创建一个python文件，里面写上”Hello Feyddy!”。然后保存为.py格式。当然，这个保存的路径你一定要知道。（最好是通过下载的python的IDLE上面的File-&gt;New File创建文件。） 此时不要关闭，如果关闭了，再重新打开。试着按F5可以直接运行文件。 接下来我们对上面的脚本进行扩展。 12name = input(&quot;What is your name? &quot;)print(&quot;Hello&quot; + name + &quot;!&quot;) 然后按F5执行后，出现What is your name?。之后你再输入Feyddy，会弹出HelloFeyddy!。 通过命令提示符运行Python脚本打开电脑终端，进入有Python执行文件的目录下。以为我的Feyddy.py文件是放在桌面上的。所以： 1xuzhonglindeMac-mini:~ t3$ cd ~/desktop 然后通过：python 文件名来运行文件。 12xuzhonglindeMac-mini:desktop t3$ python Feyddy.pyWhat is your name? 此时你如果输入Feyddy的话，会出现一个错误： 12345Traceback (most recent call last): File &quot;Feyddy.py&quot;, line 1, in &lt;module&gt; name = input(&quot;What is your name? &quot;) File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;NameError: name &apos;Feyddy&apos; is not defined 这个时候就需要将input改成raw_input。（两者的区别后面讲） 改完之后，你再次运行操作： 123xuzhonglindeMac-mini:desktop t3$ python Feyddy.pyWhat is your name? FeyddyHelloFeyddy! 让脚本像普通程序一样运行(暂时没搞懂怎么操作，当然也没有搞懂的必要)我们可能会发现一个问题，当程序运行完成后，就关闭了。 12345678910What is your name? FeyddyHelloFeyddy!Exit status: 0logoutSaving session......copying shared history......saving history...truncating history files......completed.[进程已完成] 当我们输入Feyddy的之后，回车下面的就会自动执行完成。 此时如果我们在文件中的最后加上raw_input(&quot;Press &lt;enter&gt;&quot;)之后，就会发现，按了回车之后不会自动结束进程，而是弹出Press &lt;enter&gt;这个之后需要再一次回车才能结束进程。 123What is your name? FeyddyHelloFeyddy!Press &lt;enter&gt; 1234567891011What is your name? FeyddyHelloFeyddy!Press &lt;enter&gt;Exit status: 0logoutSaving session......copying shared history......saving history...truncating history files......completed.[进程已完成] 注释只能使用(#)字符串单引号字符串和转义引号事实上单引号和双引号没有什么区别，但是在有些场景下，这两者还是很有必要分开的。例如： 123&gt;&gt;&gt; &apos;let&apos;s go!&apos;SyntaxError: invalid syntax&gt;&gt;&gt; 这个时候错误会指向s。因为程序会首先判断前面两个单引号是一组，但是s后面的就没办法识别了。此时就需要外面用双引号，里面的用单引号。 123&gt;&gt;&gt; &quot;let&apos;s go!&quot;&quot;let&apos;s go!&quot;&gt;&gt;&gt; 如果里面出现的是双引号，那么外面就用单引号进行封闭。 当然，也可以不用这么分开， 直接使用转义符号\转义就行。 12&gt;&gt;&gt; &quot;Hello Feyddy! \&quot;,my blog site is www.feyddy.com&quot;&apos;Hello Feyddy! &quot;,my blog site is www.feyddy.com&apos; 拼接字符串当我们连续写了两个字符串的时候，Python会自动将两个字符串拼接起来。当然这个只限于连续写了两个字符串。可以说是书写字符串的一种特殊方法，并不是拼接字符串的一般方法。 123&gt;&gt;&gt; &quot;My name is Feyddy,&quot; &quot;my blog site is www.feyddy.com&quot;&apos;My name is Feyddy,my blog site is www.feyddy.com&apos;&gt;&gt;&gt; 拼接字符串，使用+就可以了。 123456&gt;&gt;&gt; &quot;Hello ,guys!&quot; + &quot;Welcome to my blog!&quot;&apos;Hello ,guys!Welcome to my blog!&apos;&gt;&gt;&gt; x = &quot;My name is Feyddy ,&quot;&gt;&gt;&gt; y = &quot;my blog site is www.feyddy.com&quot;&gt;&gt;&gt; x+y&apos;My name is Feyddy ,my blog site is www.feyddy.com&apos; 字符串表示，str和repr通过之前的几个例子，我们可以发现这样一个规律：所有通过Python打印的字符都是带有引号的，或者是代码中原有的状态，如： 1234&gt;&gt;&gt; &quot;hello feyddy&quot;&apos;hello feyddy&apos;&gt;&gt;&gt; 1000000L1000000L 也就是说，你代码中是什么格式的，打印出来的就是什么样子的。但是如果使用print打印就不一样了。 1234&gt;&gt;&gt; print 10000l10000&gt;&gt;&gt; print &quot;Hello Feyddy&quot;Hello Feyddy 这个其实就是值被转换为字符串的两种机制。一种是通过str函数，它会把值转换成合理形式的字符串，以便用户可以理解；而repr会创建一个字符串，它以合法的Python表达形式来表示值。 123456&gt;&gt;&gt; print repr(&quot;Hello Feyddy&quot;)&apos;Hello Feyddy&apos;&gt;&gt;&gt; print str(&quot;Hello Feyddy&quot;)Hello Feyddy&gt;&gt;&gt; print str(100000L)100000 当然repr(x)的功能也可以用x实现( 注意：` 是反引号，而不是单引号 )。如果希望打印一个包含数字的句子，那么反引号就很有用。(在Python3.0中，已经不再使用反引号，因此，即使在旧的代码中看到了反引号，你也应该坚持使用repr。)如： 1234567&gt;&gt;&gt; temp = 100&gt;&gt;&gt; print &quot;The temperature is &quot; + tempTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: cannot concatenate &apos;str&apos; and &apos;int&apos; objects&gt;&gt;&gt; print &quot;The temperature is &quot; + `temp`The temperature is 100 上面第一个print语句并不能工作，那是因为不可以将字符串和数字进行相加。第二个可以是因为，我已经将temp用反引号将其转换成字符串。 总结：简而言之，str、repr和反引号都是将Python值转换成字符串的3种方法。函数str让字符串更容易阅读，而repr(和反引号)则把结果字符串转换成合法的Python表达式。 input和raw_input的比较还记得上面那个脚本中使用print然后输入Feyddy之后运行报错的例子吗？，然后换成用raw_input之后就不报错了。原因是，input函数会假设用户输入的是合法的Python表达式(或多或少有些与repr函数相反的意思)。如果以字符串作为输入的名字，程序是没问题的。 123xuzhonglindeMacBook-Air-2:Python Feyddy$ python Feyddy.pyWhat is your name? &quot;Feyddy&quot; HelloFeyddy! 但是要求用户输入的时候带上引号，是不是有点过分。因此，这就需要使用raw_input函数，它会把所有的输入当作原始数据(raw data),然后将其放入字符串中： 123456&gt;&gt;&gt; input(&quot;Enter a number:&quot;)Enter a number:2323&gt;&gt;&gt; raw_input(&quot;Enter a number:&quot;)Enter a number:23&apos;23&apos; 除非对input有特别的需要，否则应该尽可能使用raw_input函数。 长字符串、原始字符串和Unicode在需要长达多行的字符串或者包含多种特殊字符的字符串的时候，这些候选的字符串语法就会非常有用。 长字符串 如果需要写一个非常长的字符串，需要跨多行，可以使用三个引号(双引号和单引号都行)代替普通引号。注意，此时是三个引号，因此，在三个引号中间的字符串中可以随便使用双引号或者单引号。 12345678&gt;&gt;&gt; print &apos;&apos;&apos;My name is Feyddy,... I am a iOS developer.... My blog site is www.feyddy.com.... Welcome to my blog.&apos;&apos;&apos;My name is Feyddy,I am a iOS developer.My blog site is www.feyddy.com.Welcome to my blog. 当然，普通的字符串也是可以换行的，只需要一行的最后一个字符是反斜线： 123&gt;&gt;&gt; print &quot;Welcome to \... my blog&quot;Welcome to my blog 当然，这也是和表达式和语句： 1234567&gt;&gt;&gt; 1+ 2 \... + 3+410&gt;&gt;&gt; print \... &quot;Welcome&quot; \... &quot;Guys&quot;WelcomeGuys 但是输出的结果还是单行的。 原始字符串 原始的字符串对于反斜线的使用并不会过分挑剔。在某些情况下，这个特性就能派上用场了。在普通字符串里，反斜线有特殊的作用，会转义，可以再字符串中加入通常情况下不能直接加入的内容。如换行\n: 123&gt;&gt;&gt; print &quot;Hello \nGuys&quot;HelloGuys 但是，有的时候我们的字符串里面就需要包含\这下怎么办，虽然可以使用两个\进行转义，但是如果想一个链接一样有很多个怎么办。这下我们的原始字符串就有用了。 原始字符串不会把反斜线当做是特殊的字符。我们只需要在字符串的前面加上r就可以了。 12&gt;&gt;&gt; print r&quot;https://www.baidu.com/username=Feyddy/passWorld=Welcome&quot;https://www.baidu.com/username=Feyddy/passWorld=Welcome 但是，一旦使用了原始字符串。如果里面使用\进行转义的话，是可以转义的，但是\也会被打印出来。 12&gt;&gt;&gt; print r&quot;I\&apos;am a boy&quot;I\&apos;am a boy 注意： 千万不能让原始字符串的最后一个字符是\。如果最后一个字符是反斜线，Python就不清楚是否应该结束字符串。 12345&gt;&gt;&gt; print r&quot;This is illegal\&quot; File &quot;&lt;stdin&gt;&quot;, line 1 print r&quot;This is illegal\&quot; ^SyntaxError: EOL while scanning string literal 但是如果我们非要让\作为原始字符串的结尾的话，我们可以用字符串拼接的方法： 12&gt;&gt;&gt; print r&quot;This is right&quot; + &quot;\\&quot;This is right\ 注意： 在原始字符串中你可以同时使用单双引号，即使三引号字符串也可以充当原始字符串。 Unicode字符串 字符串常量的最后一种类型就是Unicode字符串（或称是Unicode对象—-与字符串并不是同一个类型）。 Python中的普通字符串在内部是以8位的ASCII码形式存储的，而Unicode字符串则存储为16位Unicode字符，这样就能表示更多的字符集。这个不多说，下面举个小例子： 12&gt;&gt;&gt; u&quot;Hello Feyddy&quot;u&apos;Hello Feyddy&apos;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Realm数据库初识]]></title>
      <url>%2F2017%2F03%2F22%2FRealm%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E8%AF%86%2F</url>
      <content type="text"><![CDATA[Realm数据库Realm是一款针对移动设备设计的数据库，已经涵盖所有主流开发平台，并且全部代码开源，地址如下：地址 Realm特性 移动设备支持：Realm是第一个针对手机平板和可穿戴设备设计的数据库，基本全平台支持。 简单：Realm的安装和接入简易，不同于Core Data,不需要开发者配置模型层结构，从开始接触到上手使用，只需要短短几分钟时间。 现代：关系型数据库，支持泛型。 快速：官方称比SQLite的常规操作要快速。 Realm学习资源官方文档:中文文档 Realm Browser:一款MAC平台的工具 Xcode插件（详情看官方文档里面有介绍）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Runtime常用方法总结]]></title>
      <url>%2F2017%2F03%2F21%2FRuntime%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[Runtime学习总结Runtime 简介 RunTime简称运行时。OC就是运行时机制，也就是在运行时候的一些机制，其中最主要的是消息机制。 对于C语言，函数的调用在编译的时候会决定调用哪个函数。 对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。 事实证明: 在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。 在编译阶段，C语言调用未实现的函数就会报错。 Runtime作用发送消息 方法调用的本质，就是让对象发送消息。 objc_msgSend,只有对象才能发送消息，因此以objc开头。 使用消息机制前提，必须导入#import &lt;objc/message.h&gt;，并且需要在：Build Setting -&gt; 搜索msg -&gt; 设置属性为No 消息机制简单使用 1234567891011121314151617181920212223242526// 创建person对象Person *p = [[Person alloc] init];// 调用对象方法[p eat];//SEL：方法编号，根据方法编号就可以找到对应方法实现[p performSelector:@selector(eat)];// 本质：让对象发送消息objc_msgSend(p, @selector(eat));objc_msgSend(p, @selector(run:),10);//逗号后面传的都是参数可以用逗号隔开多个参数，例如10就是其中一个参数// 调用类方法的方式：两种// 第一种通过类名调用[Person eat];// 第二种通过类对象调用[[Person class] eat];// 用类名调用类方法，底层会自动把类名转换成类对象调用// 获取类对象// Class personClass = [Person class];// [personClass performSelector:@selector(eat)];// 本质：让类对象发送消息objc_msgSend([Person class], @selector(eat)); 消息机制原理:对象根据方法编号SEL去映射表查找对应的方法实现 先转换成对象，然后调用performSelector，然后根据方法编号进行寻找 交换方法 开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。 方式一:继承系统的类，重写方法。 方式二:使用runtime,交换方法。 1234567891011121314151617181920212223242526272829303132333435363738394041@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。 // 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString*)name; // 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。 UIImage*image = [UIImage imageNamed:@&quot;123&quot;];&#125;@end@implementation UIImage (Image)// 加载分类到内存的时候调用+ (void)load&#123; // 交换方法 // 获取imageWithName方法地址 Method imageWithName = class_getClassMethod(self, @selector(imageWithName:)); // 获取imageWithName方法地址 Method imageName = class_getClassMethod(self, @selector(imageNamed:)); // 交换方法地址，相当于交换实现方式 method_exchangeImplementations(imageWithName, imageName);&#125;// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.// 既能加载图片又能打印+ (instancetype)imageWithName:(NSString*)name&#123; // 这里调用imageWithName，相当于调用imageName UIImage* image = [self imageWithName:name]; if (image == nil) &#123; NSLog(@&quot;加载空的图片&quot;); &#125; return image;&#125;@end 交换原理： 交换之前： 交换之后： 具体实现： 首先明白需求： 系统的imageNamed加载图片,并不知道图片是否加载成功 以后调用imageNamed的时候,就知道图片是否加载 创建一个UIImage的分类UIImage+FeyddyImage。 UIImage+FeyddyImage.h 123456789#import &lt;UIKit/UIKit.h&gt;@interface UIImage (FeyddyImage)//创建自己加载图片的方法+(__kindof UIImage*)FD_imageNamed:(NSString *)imageName;@end UIImage+FeyddyImage.m 12345678910111213141516171819202122232425#import &quot;UIImage+FeyddyImage.h&quot;@implementation UIImage (FeyddyImage)// 在分类里面不能调用super,分类木有父类//+(UIImage * )imageNamed:(NSString * )name//&#123;// [super im]//&#125;// 先写一个其他方法,实现这个功能+(UIImage*)FD_imageNamed:(NSString * )imageName &#123; //1.加载图片 UIImage * image = [UIImage imageNamed:imageName]; //2.判断图片是否存在 if (image == nil) &#123; NSLog(@&quot;图片不存在&quot;); &#125; return image;&#125;@end 在主控制器里面调用 1234567891011#import &quot;ViewController.h&quot;#import &quot;UIImage+FeyddyImage.h&quot;@interface ViewController ()@end@implementation ViewController-(void)viewDidLoad &#123; [super viewDidLoad]; UIImage * image = [UIImage FD_imageNamed:@&quot;feyddy&quot;];&#125;@end 但是使用自己的方法有两个弊端： 每次使用,都需要导入头文件”UIImage+FeyddyImage.h”。 当一个项目开发太久,使用这个方式不靠谱。 所以我们现在想实现的就是: 直接使用系统的方法imageNamed:,但是它实际的实现方法:底层调用FD_imageNamed 本质: 交换两个方法的实现imageNamed:和FD_imageNamed方法 调用imageNamed:其实就是调用FD_imageNamed 实现方法： 在UIImage+FeyddyImage.m中实现交换两个方法的实现。 加载分类的时候会调用 + (void)load方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#import &quot;UIImage+FeyddyImage.h&quot;#import &lt;objc/message.h&gt;@implementation UIImage (FeyddyImage)// 在分类里面不能调用super,分类木有父类//+ (UIImage * )imageNamed:(NSString * )name//&#123;// [super im]//&#125;// 先写一个其他方法,实现这个功能+ (UIImage * )FD_imageNamed:(NSString * )imageName &#123; //1.加载图片 UIImage * image = [UIImage FD_imageNamed:imageName]; //2.判断图片是否存在 if (image == nil) &#123; NSLog(@&quot;图片不存在&quot;); &#125; return image;&#125;// 加载这个分类的时候调用+ (void)load&#123; //交换方法实现，方法都是定义在类里面，所以都会以class开头、 // class_getMethodImplementation:获取方法实现,因为他的返回是IMP // class_getInstanceMethod:获取对象方法 // class_getClassMethod:获取类方法 // IMP:方法实现 //获取imageNamed类方法 // Class:获取哪个类方法 // SEL:获取方法编号,根据SEL就能去对应的类找方法 Method imageNamedClassMethod = class_getClassMethod([UIImage class], @selector(imageNamed:)); //获取FD_imageNamed类方法 Method FD_imageNamedClassMethod = class_getClassMethod([UIImage class], @selector(FD_imageNamed:)); //交换方法实现 method_exchangeImplementations(imageNamedClassMethod, FD_imageNamedClassMethod);&#125;@end 注意：FD_imageNamed里面的加载图片方法不能使用系统的，会出现死循环。改成UIImage * image = [UIImage FD_imageNamed:imageName];。 其实交换方法不是简单的交换而已，当你继续使用系统的方法名的时候，你会将你交换的方法与系统的方法一起实现，可以理解为为系统方法增加新的功能。 动态添加方法 开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。 经典面试题：有没有使用performSelector，其实主要想问你有没有动态添加过方法。 运用的其实是懒加载机制：用到的时候再加载。 简单使用 123456789101112131415161718192021222324252627282930313233343536373839@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. Person* p = [[Person alloc] init]; // 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。 // 动态添加方法就不会报错 [p performSelector:@selector(eat)];&#125;@end@implementation Person// void(* )()// 默认方法都有两个隐式参数，void eat(id self,SEL sel)&#123; NSLog(@&quot;%@ %@&quot;,self,NSStringFromSelector(sel));&#125;// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if (sel == @selector(eat)) &#123; // 动态添加eat方法 // 第一个参数：给哪个类添加方法 // 第二个参数：添加方法的方法编号 // 第三个参数：添加方法的函数实现（函数地址） // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd class_addMethod(self, @selector(eat), eat, &quot;v@:&quot;); &#125; return [super resolveInstanceMethod:sel];&#125;@end 具体实现： 首先创建一个Person类,动态添加一个带参数的age:方法和不带参数的eat方法。 Person.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#import &quot;Person.h&quot;#import &lt;objc/message.h&gt;@implementation Person// 动态添加方法,首先实现这个resolveInstanceMethod// resolveInstanceMethod调用:当调用了没有实现的方法，就会调用resolveInstanceMethod// resolveInstanceMethod作用:就知道哪些方法没有实现,从而动态添加方法// sel:就是没有实现方法就是主控制器里面的eat方法+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; NSLog(@&quot;%@&quot;,NSStringFromSelector(sel));//打印出来的就是eat //动态添加eat方法 //判断添加的方法是哪个 if (sel == @selector(age:)) &#123;//有参数 /* cls:给哪个类添加方法 SEL:添加方法的方法编号是什么 IMP:方法实现,函数入口,函数名 types:方法类型,这个需要查询runtime class_addMethod(__unsafe_unretained Class cls, SEL name, IMP imp, const char *types) ____ */ /**/ // @-&gt;对象 :-&gt;SEL class_addMethod(self, sel, (IMP)ageMethodRealize, &quot;v@:@&quot;); // 处理完 return YES; &#125;else if (sel == @selector(eat)) &#123;//没有参数 class_addMethod(self, sel, (IMP)eatMethodRealize, &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;//IMP函数方法实现// 默认一个方法都有两个参数,self,_cmd,隐式参数// self:方法调用者// _cmd:调用方法的编号//后面的id param1如果方法有参数就加上void ageMethodRealize(id self, SEL _cmd, id param1)&#123; NSLog(@&quot;age: 方法被调用了，%@ %@ 年龄为： %@&quot;,self,NSStringFromSelector(_cmd),param1);&#125;void eatMethodRealize(id self, SEL _cmd) &#123; NSLog(@&quot;eat 方法被调用了，%@ %@ &quot;,self,NSStringFromSelector(_cmd));&#125;@end 在主控制器中的实现 1234567891011121314151617181920212223#import &quot;ViewController.h&quot;#import &quot;Person.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //performSelector动态添加方法 Person * p = [[Person alloc] init]; //动态添加方法eat，但是Person里面如果没有这个方法会报错 [p performSelector:@selector(eat)]; [p performSelector:@selector(age:) withObject:@25];&#125;@end 运行结果： 123456782017-03-21 14:24:33.333 runtime动态添加方法[5770:176029] eat2017-03-21 14:24:33.333 runtime动态添加方法[5770:176029] _dynamicContextEvaluation:patternString:2017-03-21 14:24:33.333 runtime动态添加方法[5770:176029] descriptionWithLocale:2017-03-21 14:24:33.334 runtime动态添加方法[5770:176029] eat 方法被调用了，&lt;Person: 0x60800000fdc0&gt; eat2017-03-21 14:24:33.334 runtime动态添加方法[5770:176029] age:2017-03-21 14:24:33.335 runtime动态添加方法[5770:176029] _dynamicContextEvaluation:patternString:2017-03-21 14:24:33.335 runtime动态添加方法[5770:176029] descriptionWithLocale:2017-03-21 14:24:33.335 runtime动态添加方法[5770:176029] age: 方法被调用了，&lt;Person: 0x60800000fdc0&gt; age: 年龄为： 25 给分类添加属性 原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。 1234567891011121314151617181920212223242526272829303132333435@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 给系统NSObject类动态添加属性name NSObject * objc = [[NSObject alloc] init]; objc.name = @&quot;Feyddy&quot;; NSLog(@&quot;%@&quot;,objc.name);&#125;@end// 定义关联的keystatic const char *key = &quot;name&quot;;@implementation NSObject (Property)- (NSString * )name&#123; // 根据关联的key，获取关联的值。 return objc_getAssociatedObject(self, key);&#125;- (void)setName:(NSString * )name&#123; // 第一个参数：给哪个对象添加关联 // 第二个参数：关联的key，通过这个key获取 // 第三个参数：关联的value // 第四个参数:关联的策略 objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 具体实现：我们给NSObject添加一个属性：创建一个分类NSObject+FeyddyObjc NSObject+FeyddyObjc.h 123456789#import &lt;Foundation/Foundation.h&gt;@interface NSObject (FeyddyObjc)//在分类里面的@property只会生成get和set方法的声明，不会自动实现，需要自己去实现@property(nonatomic,copy) NSString * name;@end NSObject+FeyddyObjc.m 12345678910111213141516#import &quot;NSObject+FeyddyObjc.h&quot;@implementation NSObject (FeyddyObjc)static NSString * staticName;//用来接收外面传进的name属性值- (void)setName:(NSString * )name&#123; staticName = name;&#125;- (NSString * )name&#123; return staticName;&#125;@end 主控制器实现： 1234567891011121314151617#import &quot;ViewController.h&quot;#import &quot;NSObject+FeyddyObjc.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSObject * obj = [[NSObject alloc] init]; obj.name = @&quot;Feyddy&quot;; NSLog(@&quot;%@&quot;,obj.name); &#125;@end 运行结果： 12017-03-21 15:03:01.392 runtime给分类添加属性[6602:200009] Feyddy 虽然是可以用了，但是这个相当于给静态变量staticName赋值，但是name这个属性和这个类，没有关系直接关系。直接关系的staticName。但是如果我们这个类消失了，但是staticName还在。所以不是我们的初衷。 下面动态添加属性： NSObject+FeyddyObjc.m 1234567891011121314151617181920212223242526272829303132333435363738#import &quot;NSObject+FeyddyObjc.h&quot;#import &lt;objc/message.h&gt;@implementation NSObject (FeyddyObjc)//static NSString * staticName;//用来接收外面传进的name属性值- (void)setName:(NSString * )name&#123; // 添加属性,跟对象 /* 给某个对象产生关联,添加属性 object:给哪个对象添加属性 key:属性名,根据key去获取关联的对象 ,void * == id value:关联的值 policy:策越 objc_setAssociatedObject(id object, const void * key, id value, objc_AssociationPolicy policy) */ /**/ objc_setAssociatedObject(self, @&quot;name&quot;, name, OBJC_ASSOCIATION_COPY);// staticName = name;&#125;- (NSString * )name&#123; /* 获取某个对象关联的属性 object:给哪个对象添加属性 key:属性名,根据key去获取关联的对象 ,void * == id objc_getAssociatedObject(id object, const void * key) */ /**/ return objc_getAssociatedObject(self, @&quot;name&quot;);// return staticName;&#125;@end 运行结果同上。 字典转模型 设计模型：字典转模型的第一步 模型属性，通常需要跟字典中的key一一对应 问题：一个一个的生成模型属性，很慢？ 需求：能不能自动根据一个字典，生成对应的属性。 解决：提供一个分类，专门根据字典生成对应的属性字符串。 1234567891011121314151617181920212223242526272829303132333435363738394041@implementation NSObject (Log)// 自动打印属性字符串+(void)resolveDict:(NSDictionary * )dict&#123; // 拼接属性字符串代码 NSMutableString * strM = [NSMutableString string]; // 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码 [dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; // 类型经常变，抽出来 NSString * type; if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFString&quot;)]) &#123; type = @&quot;NSString&quot;; &#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFArray&quot;)])&#123; type = @&quot;NSArray&quot;; &#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFNumber&quot;)])&#123; type = @&quot;int&quot;; &#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFDictionary&quot;)])&#123; type = @&quot;NSDictionary&quot;; &#125; // 属性字符串 NSString *str; if ([type containsString:@&quot;NS&quot;]) &#123; str = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) %@ *%@;&quot;,type,key]; &#125;else&#123; str = [NSString stringWithFormat:@&quot;@property (nonatomic, assign) %@ %@;&quot;,type,key]; &#125; // 每生成属性字符串，就自动换行。 [strM appendFormat:@&quot;\n%@\n&quot;,str]; &#125;]; // 把拼接好的字符串打印出来，就好了。 NSLog(@&quot;%@&quot;,strM);&#125;@end 具体实现 创建一个工具分类：NSObject+PropertyAutoFeyddy NSObject+PropertyAutoFeyddy.h 12345678#import &lt;Foundation/Foundation.h&gt;@interface NSObject (PropertyAutoFeyddy)//创一个字典过来+ (void)createPropertyCodeWithDict:(NSDictionary * )dict;@end NSObject+PropertyAutoFeyddy.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#import &quot;NSObject+PropertyAutoFeyddy.h&quot;@implementation NSObject (PropertyAutoFeyddy)+ (void)createPropertyCodeWithDict:(NSDictionary *)dict &#123; //遍历字典 /** key -&gt;属性名propertyName obj -&gt;属性值value */ NSMutableString *strm = [NSMutableString string]; [dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; //属性代码 NSString *code; //NSLog(@&quot;---%@---%@&quot;,key,[obj class]);//通过获取字典中的字段的内容我们可以发现到下面的类型 /* 2017-03-21 16:18:03.447 runtime字典转模型KVC实现[8119:245304] ---source---__NSCFString 2017-03-21 16:18:03.448 runtime字典转模型KVC实现[8119:245304] ---reposts_count---__NSCFNumber 2017-03-21 16:18:03.448 runtime字典转模型KVC实现[8119:245304] ---pic_urls---__NSCFArray 2017-03-21 16:18:03.449 runtime字典转模型KVC实现[8119:245304] ---created_at---__NSCFString 2017-03-21 16:18:03.449 runtime字典转模型KVC实现[8119:245304] ---attitudes_count---__NSCFNumber 2017-03-21 16:18:03.450 runtime字典转模型KVC实现[8119:245304] ---idstr---__NSCFString 2017-03-21 16:18:03.450 runtime字典转模型KVC实现[8119:245304] ---text---__NSCFString 2017-03-21 16:18:03.450 runtime字典转模型KVC实现[8119:245304] ---comments_count---__NSCFNumber 2017-03-21 16:18:03.451 runtime字典转模型KVC实现[8119:245304] ---user---__NSCFDictionary */ //属性策略，判断obj类型，对象strong，基本数据类型assign if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFString&quot;)]) &#123; code = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) NSString *%@;&quot;,key] ; &#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFNumber&quot;)])&#123; code = [NSString stringWithFormat:@&quot;@property (nonatomic, assign) int %@;&quot;,key] ; &#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFArray&quot;)])&#123; code = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) NSArray *%@;&quot;,key] ; &#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFDictionary&quot;)])&#123; code = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) NSDictionary *%@;&quot;,key] ; &#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFBoolean&quot;)])&#123; code = [NSString stringWithFormat:@&quot;@property (nonatomic, assign) BOOL %@;&quot;,key] ; &#125; [strm appendFormat:@&quot;\n%@\n&quot;,code]; &#125;]; NSLog(@&quot;==== %@&quot;,strm);&#125;@end 在主控制器中实现 12345678910111213141516171819202122232425262728#import &quot;ViewController.h&quot;#import &quot;NSObject+PropertyAutoFeyddy.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //获取文件路径 NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;status.plist&quot; ofType:nil]; //获取文件最外层字典 NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:filePath]; //获取文件中的某个字典数组 NSArray *dictArray = dict[@&quot;statuses&quot;]; //设计模型属性代码 [NSObject createPropertyCodeWithDict:dictArray[0][@&quot;user&quot;]]; for (NSDictionary *dic in dictArray) &#123; //字典转模型-&gt;创建模型Status &#125;&#125;@end 运行结果 1234567891011121314151617@property (nonatomic, strong) NSString *source;@property (nonatomic, assign) int reposts_count;@property (nonatomic, strong) NSArray *pic_urls;@property (nonatomic, strong) NSString *created_at;@property (nonatomic, assign) int attitudes_count;@property (nonatomic, strong) NSString *idstr;@property (nonatomic, strong) NSString *text;@property (nonatomic, assign) int comments_count;@property (nonatomic, strong) NSDictionary *user; 字典转模型的方式一：KVC 1234567891011@implementation Status+ (instancetype)statusWithDict:(NSDictionary * )dict&#123; Status * status = [[self alloc] init]; //KVC设置值 [status setValuesForKeysWithDictionary:dict]; return status;&#125;@end KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应。 如果不一致，就会调用[ setValue:forUndefinedKey:] 报key找不到的错。 分析:模型中的属性和字典的key不一一对应，系统就会调用setValue:forUndefinedKey:报错。 解决:重写对象的setValue:forUndefinedKey:,把系统的方法覆盖， 就能继续使用KVC，字典转模型了。 1234-(void)setValue:(id)value forUndefinedKey:(NSString * )key&#123;&#125; 具体实现： 创建一个Status模型： Status.h 12345678910111213141516171819202122232425262728293031323334#import &lt;Foundation/Foundation.h&gt;@interface Status : NSObject// 写一段程序自动生成属性代码@property (nonatomic, assign) NSInteger ID;// 解析字典自动生成属性代码@property (nonatomic, strong) NSString *source;@property (nonatomic, assign) NSInteger reposts_count;@property (nonatomic, strong) NSArray *pic_urls;@property (nonatomic, strong) NSString *created_at;@property (nonatomic, assign) int attitudes_count;@property (nonatomic, strong) NSString *idstr;@property (nonatomic, strong) NSString *text;@property (nonatomic, assign) int comments_count;@property (nonatomic, strong) NSDictionary *user;@property (nonatomic, strong) NSDictionary *retweeted_status;// 模型的属性名跟字典一一对应+ (__kindof Status *)statusWithDict:(NSDictionary *)dict;@end Status.m 1234567891011121314151617181920212223#import &quot;Status.h&quot;@implementation Status+ (Status * )statusWithDict:(NSDictionary * )dict &#123; Status * status = [[self alloc] init]; //KVC设置值 [status setValuesForKeysWithDictionary:dict]; return status;&#125;//解决KVC报错-&gt;id字段问题处理- (void)setValue:(id)value forUndefinedKey:(NSString * )key &#123; // key:没有找到key // value:没有找到key对应的值 if ([key isEqualToString:@&quot;id&quot;]) &#123; self.ID = (NSString * )value; &#125;&#125;@end 主控制器实现： 12345678910111213141516171819202122232425262728293031323334#import &quot;ViewController.h&quot;#import &quot;NSObject+PropertyAutoFeyddy.h&quot;#import &quot;Status.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //获取文件路径 NSString * filePath = [[NSBundle mainBundle] pathForResource:@&quot;status.plist&quot; ofType:nil]; //获取文件最外层字典 NSDictionary * dict = [NSDictionary dictionaryWithContentsOfFile:filePath]; //获取文件中的某个字典数组 NSArray * dictArray = dict[@&quot;statuses&quot;]; //设计模型属性代码// [NSObject createPropertyCodeWithDict:dictArray[0]]; NSMutableArray * statusArray = [NSMutableArray array]; for (NSDictionary * dic in dictArray) &#123; //字典转模型-&gt;创建模型Status Status * status = [Status statusWithDict:dic]; [statusArray addObject:status]; &#125; NSLog(@&quot;---%@&quot;,statusArray);&#125;@end 运行结果： 12345678910111213141516171819202122 2017-03-21 17:30:56.000 runtime字典转模型KVC实现[9351:278442] ---( &quot;&lt;Status: 0x6000000a4260&gt;&quot;, &quot;&lt;Status: 0x6000000a4620&gt;&quot;, &quot;&lt;Status: 0x6000000a4680&gt;&quot;, &quot;&lt;Status: 0x6000000a4740&gt;&quot;, &quot;&lt;Status: 0x6000000a47a0&gt;&quot;, &quot;&lt;Status: 0x6000000a4800&gt;&quot;, &quot;&lt;Status: 0x6000000a4860&gt;&quot;, &quot;&lt;Status: 0x6000000a48c0&gt;&quot;, &quot;&lt;Status: 0x6000000a4920&gt;&quot;, &quot;&lt;Status: 0x6000000a4980&gt;&quot;, &quot;&lt;Status: 0x6000000a49e0&gt;&quot;, &quot;&lt;Status: 0x6000000a4a40&gt;&quot;, &quot;&lt;Status: 0x6000000a4aa0&gt;&quot;, &quot;&lt;Status: 0x6000000a4b00&gt;&quot;, &quot;&lt;Status: 0x6000000a4b60&gt;&quot;, &quot;&lt;Status: 0x6000000a4bc0&gt;&quot;, &quot;&lt;Status: 0x6000000a4c20&gt;&quot;, &quot;&lt;Status: 0x6000000a4c80&gt;&quot;, &quot;&lt;Status: 0x6000000a4ce0&gt;&quot;, &quot;&lt;Status: 0x6000000a4d40&gt;&quot;) 字典转模型的方式二：Runtime 思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。 步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 解析Plist文件 NSString * filePath = [[NSBundle mainBundle] pathForResource:@&quot;status.plist&quot; ofType:nil]; NSDictionary * statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath]; // 获取字典数组 NSArray * dictArr = statusDict[@&quot;statuses&quot;]; // 自动生成模型的属性字符串 // [NSObject resolveDict:dictArr[0][@&quot;user&quot;]]; NSMutableArray * statusArray = [NSMutableArray array]; // 遍历字典数组 for (NSDictionary * dict in dictArr) &#123; Status * status = [Status modelWithDict:dict]; [statusArray addObject:status]; &#125; // 测试数据 NSLog(@&quot;%@ %@&quot;,statusArray,[statusArray[0] user]);&#125;@end@implementation NSObject (Model)+(instancetype)modelWithDict:(NSDictionary * )dict&#123; // 思路：遍历模型中所有属性-》使用运行时 // 0.创建对应的对象 id objc = [[self alloc] init]; // 1.利用runtime给对象中的成员属性赋值 // class_copyIvarList:获取类中的所有成员属性 // Ivar：成员属性的意思 // 第一个参数：表示获取哪个类中的成员属性 // 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值 // 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。 /* 类似下面这种写法 Ivar ivar; Ivar ivar1; Ivar ivar2; // 定义一个ivar的数组a Ivar a[] = &#123;ivar,ivar1,ivar2&#125;; // 用一个Ivar * 指针指向数组第一个元素 Ivar * ivarList = a; // 根据指针访问数组第一个元素 ivarList[0]; */ unsigned int count; // 获取类中的所有成员属性 Ivar * ivarList = class_copyIvarList(self, &amp;count); for (int i = 0; i &lt; count; i++) &#123; // 根据角标，从数组取出对应的成员属性 Ivar ivar = ivarList[i]; // 获取成员属性名 NSString * name = [NSString stringWithUTF8String:ivar_getName(ivar)]; // 处理成员属性名-&gt;字典中的key // 从第一个角标开始截取 NSString * key = [name substringFromIndex:1]; // 根据成员属性名去字典中查找对应的value id value = dict[key]; // 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型 // 判断下value是否是字典 if ([value isKindOfClass:[NSDictionary class]]) &#123; // 字典转模型 // 获取模型的类对象，调用modelWithDict // 模型的类名已知，就是成员属性的类型 // 获取成员属性类型 NSString * type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)]; // 生成的是这种@&quot;@\&quot;User\&quot;&quot; 类型 -》 @&quot;User&quot; 在OC字符串中 \&quot; -&gt; &quot;，\是转义的意思，不占用字符 // 裁剪类型字符串 NSRange range = [type rangeOfString:@&quot;\&quot;&quot;]; type = [type substringFromIndex:range.location + range.length]; range = [type rangeOfString:@&quot;\&quot;&quot;]; // 裁剪到哪个角标，不包括当前角标 type = [type substringToIndex:range.location]; // 根据字符串类名生成类对象 Class modelClass = NSClassFromString(type); if (modelClass) &#123; // 有对应的模型才需要转 // 把字典转模型 value = [modelClass modelWithDict:value]; &#125; &#125; // 三级转换：NSArray中也是字典，把数组中的字典转换成模型. // 判断值是否是数组 if ([value isKindOfClass:[NSArray class]]) &#123; // 判断对应类有没有实现字典数组转模型数组的协议 if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123; // 转换成id类型，就能调用任何对象的方法 id idSelf = self; // 获取数组中字典对应的模型 NSString * type = [idSelf arrayContainModelClass][key]; // 生成模型 Class classModel = NSClassFromString(type); NSMutableArray * arrM = [NSMutableArray array]; // 遍历字典数组，生成模型数组 for (NSDictionary * dict in value) &#123; // 字典转模型 id model = [classModel modelWithDict:dict]; [arrM addObject:model]; &#125; // 把模型数组赋值给value value = arrM; &#125; &#125; if (value) &#123; // 有值，才需要给模型的属性赋值 // 利用KVC给模型中的属性赋值 [objc setValue:value forKey:key]; &#125; &#125; return objc;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS9新特性回顾]]></title>
      <url>%2F2017%2F03%2F21%2FiOS9%E6%96%B0%E7%89%B9%E6%80%A7%E5%9B%9E%E9%A1%BE%2F</url>
      <content type="text"><![CDATA[iOS9新特性常见关键字iOS9新出的关键字:用来修饰属性,或者方法的参数,方法的返回值。 好处: 迎合swift 提高我们开发人员开发规范,减少程序员之间交流 注意:iOS9新出关键字nonnull,nullable只能修饰对象,不能修饰基本数据类型 nullable作用:表示可以为空 nullable书写规范:123456// 方式一:@property (nonatomic, strong, nullable) NSString *name;// 方式二:@property (nonatomic, strong) NSString *_Nullable name;// 方式三:@property (nonatomic, strong) NSString *__nullable name; nonnullnon:非 null:空 书写格式: 12345@property (nonatomic, strong, nonnull) NSString *icon;@property (nonatomic, strong) NSString * _Nonnull icon;@property (nonatomic, strong) NSString * __nonnull icon; NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END在NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END之间,定义的所有对象属性和方法默认都是nonnull 方法中,关键字书写规范12- (nonnull NSString *)test:(nonnull NSString *)str;- (NSString * _Nonnull)test1:(NSString * _Nonnull)str; null_resettableget:不能返回为空, set:可以为空 注意:如果使用null_resettable,必须重写get方法或者set方法,处理传递的值为空的情况 书写方式: 1@property (nonatomic, strong, null_resettable) NSString *name; _Null_unspecified_Null_unspecified(不确定是否为空) 书写方式只有这种 12345//方式一@property (nonatomic, strong) NSString *_Null_unspecified name;//方式二@property (nonatomic, strong) NSString *__null_unspecified name; 泛型泛型:限制类型。 泛型使用场景: 1. 在集合(数组,字典,NSSet)中使用泛型比较常见。 2. 当声明一个类,类里面的某些属性的类型不确定,这时候我们才使用泛型。 泛型书写规范： 在类型后面定义泛型,`NSMutableArray&lt;UITouch *&gt; *datas` 泛型修饰: 只能修饰方法的调用。 泛型好处: 1. 提高开发规范,减少程序员之间交流 2. 通过集合取出来对象,直接当做泛型对象使用,可以直接使用点语法 下面对上面的几点通过代码进行说明： 泛型书写规范12345//普通的类型声明@property (nonatomic, strong) NSMutableArray *data1;//泛型声明-限制数组里面全部是字符串@property (nonatomic, strong) NSMutableArray&lt;NSString *&gt; *data2; 泛型修饰12345//普通的id类型，没有限制self.data1 addObject:(nonnull id)//泛型限制数组里面的对象必须为字符串self.data2 addObject:(nonnull NSString *) 泛型好处第二点，id类型没有点语法。 12345//联想不出来，并且报错，如上图self.data1[0].length//可以联想出来self.data2[0].length; 泛型使用场景第二点我们自定义一个泛型类： 需求说明：Person类,开发语言Language类。iOS,Java两个继承Language类。 Person.h 1234567891011121314151617181920212223242526#import &lt;Foundation/Foundation.h&gt;#import &quot;Language.h&quot;#import &quot;IOS.h&quot;// 声明泛型@interface Person&lt;ObjectType&gt; : NSObject// 语言@property (nonatomic) ObjectType language;// id类型@property (nonatomic) id language2;//Language类型@property (nonatomic) Language * language3;//IOS类型@property (nonatomic) IOS * language4;/* id:任何对象都能传进来 Language:在外面调用的时候,没有提示 IOS* 以后只能传IOS对象,不能传其他的对象了*///如果声明了泛型就会自动的生成下面的set和get方法- (ObjectType)language;- (void)setLanguage:(ObjectType)language;@end 上面的解释通过代码来演示一下： 1234567891011121314151617181920212223242526/*不是泛型的三种情况的弊端*/Person *idP = [[Person alloc] init];idP.language2 = @&quot;123&quot;;//此时的language2是一个id类型，什么类型都可以赋值Person *languageP = [[Person alloc] init];languageP.language3 = [[IOS alloc] init];//此时的language3是一个Language类型，但是Language类型现在有两个，没有提示，所以还是不知道有哪些类型。Person *iOSP = [[Person alloc] init];iOSP.language4 = [[Java alloc] init];//此时的language4是ios类型的，所以只能赋iOS类型对象，不能赋其他类型的对象。此时报警告/*泛型的好处演示*///LanguagePerson&lt;Language *&gt; *p = [[Person alloc] init];p.language = [[Language alloc] init];//此时的language为Language类型//iOSPerson&lt;IOS *&gt; *iosP = [[Person alloc] init];iosP.language = [[IOS alloc] init];//此时的language为IOS类型//JAVAPerson&lt;Java *&gt; *javaP = [[Person alloc] init];javaP.language = [[Java alloc] init];//此时的language为Java类型 泛型的进阶(协变、逆变)__covariant(协变):用于泛型数据强转类型,可以向上强转,子类 可以转成 父类。__contravariant(逆变):用于泛型数据强转类型,可以向下强转, 父类 可以 转成子类。 将上面的Person.h里面修改一下： 123456789101112131415161718#import &lt;Foundation/Foundation.h&gt;#import &quot;Language.h&quot;#import &quot;IOS.h&quot;// 声明泛型@interface Person&lt;__contravariant ObjectType&gt; : NSObject// 语言@property (nonatomic) ObjectType language;// id类型@property (nonatomic) id language2;//Language类型@property (nonatomic) Language * language3;//IOS类型@property (nonatomic) IOS * language4;@end 1234567891011121314151617//LanguagePerson&lt;Language *&gt; *p = [[Person alloc] init];p.language = [[Language alloc] init];//此时的language为Language类型//iOSPerson&lt;IOS *&gt; *iosP = [[Person alloc] init];iosP.language = [[IOS alloc] init];//此时的language为IOS类型//JAVAPerson&lt;Java *&gt; *javaP = [[Person alloc] init];javaP.language = [[Java alloc] init];//此时的language为Java类型// 如果子类想给父类赋值,协变iosP = p;//需要__contravariantp = javaP;//需要__covariant __kindof__kindof:表示当前类或者它子类：在调用的时候,很清楚的知道返回类型。 __kindof书写格式: 放在类型前面,表示修饰这个类型`(__kindof Person *)` 下面我们通过代码演示说明一下： 首先创建一个Person类，然后创建一个集成它的SonPerson子类。 Person.h 123456789101112131415161718192021#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject// 会自动识别当前对象的类// SonPerson//+ (instancetype)person;///id类型// + (id)person;/// Person类型// + (Person * )person;// __kindof Person *:表示可以是Person类或者它的子类+ (__kindof Person *)person;// 仅仅表示只能是Person类+ (Person *)person1;@end Person.m 12345678910#import &quot;Person.h&quot;@implementation Person// id坏处: 1.不能在编译的时候检查真实类型// 2.返回值,没有提示+ (id)person&#123; return [[self alloc] init];&#125;@end 下面进行操作演示： 当Person.h里面的是 12///id类型// + (id)person; 1234// id坏处: 1.不能在编译的时候检查真实类型// 2.返回值,没有提示NSString *p = [SonPerson person];//此时就什么类型都可以指向[SonPerson person];//调用的方法返回的是id类型，没有提示，不知道是什么 当Person.h里面的是 123///Person类型// 仅仅表示只能是Person类// + (Person * )person; 1SonPerson *p = [SonPerson person];//会报警告，说类型不匹配 当Person.h里面的是 123// 会自动识别当前对象的类// SonPerson+ (instancetype)person; 12SonPerson *p = [SonPerson person];//不会报警告[SonPerson person];//这个时候也不会有提示告诉你person返回的是哪种类型 当Person.h里面的是 12// __kindof Person *:表示可以是Person类或者它的子类+ (__kindof Person *)person; 结果： 12[SonPerson person];//这个时候会提示是返回的Person类NSString *p = [SonPerson person];//此时就会报警告。说类型不匹配]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript运动事件-中级篇]]></title>
      <url>%2F2017%2F03%2F20%2FJavaScript%E8%BF%90%E5%8A%A8%E4%BA%8B%E4%BB%B6-%E4%B8%AD%E7%BA%A7%E7%AF%87%2F</url>
      <content type="text"><![CDATA[知识点 多物体运动首先我们先做一个小的div变宽的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #div1 &#123; width: 200px; height: 200px; background-color: red; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; timer = null; var oDiv = document.getElementById('div1'); oDiv.onmouseover = function()&#123; startMove(400); &#125; var oDiv = document.getElementById('div1'); oDiv.onmouseout = function()&#123; startMove(200); &#125; function startMove(iTarget) &#123; var oDiv = document.getElementById('div1'); clearInterval(timer); timer = setInterval(function()&#123; var iSpeed = (iTarget - oDiv.offsetWidth) / 8; iSpeed = iSpeed &gt; 0? Math.ceil(iSpeed):Math.floor(iSpeed); if(oDiv.offsetWidth == iTarget)&#123; clearInterval(timer); &#125;else &#123; oDiv.style.width = oDiv.offsetWidth + iSpeed + "px"; &#125; &#125;,30); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 下面我们对多个div进行运动 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 200px; height: 200px; background-color: red; margin-top: 50px; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; timer = null; var oDiv = document.getElementsByTagName('div'); var i = 0; for( i = 0;i &lt; oDiv.length;i++)&#123; //为了给每个div加上自己的一个定时器属性，在移动的函数框架里面每次一处自己的定时器，不影响其他的定时器。防止出现鼠标切换div导致div停止运动。 oDiv[i].timer = null; oDiv[i].onmouseover = function()&#123; startMove(this,400); &#125; oDiv[i].onmouseout = function()&#123; startMove(this,200); &#125; &#125; function startMove(obj , iTarget) &#123; clearInterval(obj.timer); obj.timer = setInterval(function()&#123; var iSpeed = (iTarget - obj.offsetWidth) / 8; iSpeed = iSpeed &gt; 0? Math.ceil(iSpeed):Math.floor(iSpeed); if(obj.offsetWidth == iTarget)&#123; clearInterval(obj.timer); &#125;else &#123; obj.style.width = obj.offsetWidth + iSpeed + "px"; &#125; &#125;,30); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 同样的方式，我们也可以将alpha设置成一个div的属性： 多个div淡入淡出： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background-color: orange; margin: 10px; filter: alpha(opacity:30);/*IE用的*/ opacity : 0.3; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var oDiv = document.getElementsByTagName("div"); var alpha = 30; var i = 0; for(i = 0;i &lt; oDiv.length; i++)&#123; oDiv[i].timer = null; //这里赋值属性alpha目的是为了在移动到另一个div的时候，这个div的alpha继续运动 oDiv[i].alpha = 30; oDiv[i].onmouseover = function()&#123; startMove(this,100); &#125; oDiv[i].onmouseout = function()&#123; startMove(this,30); &#125; &#125; function startMove(obj, itarget)&#123; clearInterval(obj.timer); obj.timer = setInterval(function()&#123; var iSpeed = (itarget - obj.alpha) / 8; iSpeed = iSpeed &gt; 0 ? Math.ceil(iSpeed) : Math.floor(iSpeed); if(obj.alpha == itarget)&#123; clearInterval(obj.timer); &#125;else &#123; obj.alpha += iSpeed; obj.style.filter = "alpha(opacity:" + obj.alpha + ")"; obj.style.opacity = obj.alpha/100; &#125; &#125;,30); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运动效果： 任意值变化 offsetWidth系列的BUG解决。由于offsetWidth实际上是由width+padding+border三部分组成的，所以有时候就会出现问题。所以真正在做项目的时候千万不要用。可以使用下面的例子中的方法: 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #div1&#123; width: 100px; height: 100px; background-color: orange; border: 1px solid black; &#125; &lt;/style&gt; &lt;script&gt; function getStyle(obj,attr) &#123; if(obj.currentStyle)&#123; return obj.currentStyle[attr]; &#125;else &#123; return getComputedStyle(obj,false)[attr]; &#125; &#125; setInterval(function()&#123; var oDiv = document.getElementById("div1"); oDiv.style.width = parseInt(getStyle(oDiv,"width")) - 1 + "px"; &#125;,30); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 下面我们实现任意值框架的制作：(不会使用offset系列) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background-color: orange; margin: 20px; border: 1px solid black; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; var oDiv = document.getElementsByTagName("div"); oDiv[0].onclick = function()&#123; startMove(this,"width",300); &#125; oDiv[1].onclick = function()&#123; startMove(this,"height",200); &#125; oDiv[2].onclick = function()&#123; startMove(this,"borderWidth",50); &#125; oDiv[3].onclick = function()&#123; startMove(this,"fontSize",100); &#125; &#125; function getStyle(obj, attr) &#123; if(obj.currentStyle)&#123; return obj.currentStyle[attr]; &#125;else &#123; return getComputedStyle(obj,false)[attr]; &#125; &#125; function startMove(obj, attr ,iTarget) &#123; clearInterval(obj.timer); obj.timer = setInterval(function()&#123; var icurrent = parseInt(getStyle(obj,attr)); var iSpeed = (iTarget - icurrent) / 8; iSpeed = iSpeed &gt; 0? Math.ceil(iSpeed) : Math.floor(iSpeed); if(icurrent == iTarget)&#123; clearInterval(obj.timer); &#125;else &#123; obj.style[attr] = icurrent + iSpeed + "px"; &#125; &#125;,30); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;www.feyddy.com&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 但是我们这个有个小问题，那就是没有对透明度的问题进行处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;style&gt;#div1 &#123;width:200px; height:200px; background:red; filter:alpha(opacity:30); opacity:0.3;&#125;&lt;/style&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script type="text/javascript"&gt;window.onload=function ()&#123; var oDiv=document.getElementById('div1'); oDiv.onmouseover=function () &#123; startMove(oDiv, 'opacity', 100); &#125; oDiv.onmouseout=function () &#123; startMove(oDiv, 'opacity', 30); &#125;&#125;function getStyle(obj, attr)&#123; if(obj.currentStyle) &#123; return obj.currentStyle[attr]; &#125; else &#123; return getComputedStyle(obj, false)[attr]; &#125;&#125;function startMove(obj, attr, iTarget)&#123; clearInterval(obj.timer); obj.timer=setInterval(function ()&#123; var iCur=0; if(attr=='opacity') &#123; iCur=parseInt(parseFloat(getStyle(obj, attr))*100); &#125; else &#123; iCur=parseInt(getStyle(obj, attr)); &#125; var iSpeed=(iTarget-iCur)/8; iSpeed=iSpeed&gt;0?Math.ceil(iSpeed):Math.floor(iSpeed); if(iCur==iTarget) &#123; clearInterval(obj.timer); &#125; else &#123; if(attr=='opacity') &#123; obj.style.filter='alpha(opacity:'+(iCur+iSpeed)+')'; obj.style.opacity=(iCur+iSpeed)/100; document.getElementById('txt1').value=obj.style.opacity; &#125; else &#123; obj.style[attr]=iCur+iSpeed+'px'; &#125; &#125; &#125;, 30)&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input id="txt1" type="text"/&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这样就可以对透明度进行封装了。 小数与整数判断的话，只要不是小数部位的值相等，会判断两者相等。 123var a=3;var b=3.10000000000000000001;alert(a==b);//true 封装自己的运动框架通过上面的例子已经出来了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function getStyle(obj, attr)&#123; if(obj.currentStyle) &#123; return obj.currentStyle[attr]; &#125; else &#123; return getComputedStyle(obj, false)[attr]; &#125;&#125;function startMove(obj, attr, iTarget)&#123; clearInterval(obj.timer); obj.timer=setInterval(function ()&#123; var iCur=0; if(attr=='opacity') &#123; iCur=parseInt(parseFloat(getStyle(obj, attr))*100); &#125; else &#123; iCur=parseInt(getStyle(obj, attr)); &#125; var iSpeed=(iTarget-iCur)/8; iSpeed=iSpeed&gt;0?Math.ceil(iSpeed):Math.floor(iSpeed); if(iCur==iTarget) &#123; clearInterval(obj.timer); &#125; else &#123; if(attr=='opacity') &#123; obj.style.filter='alpha(opacity:'+(iCur+iSpeed)+')'; obj.style.opacity=(iCur+iSpeed)/100; &#125; else &#123; obj.style[attr]=iCur+iSpeed+'px'; &#125; &#125; &#125;, 30)&#125; 下面我们就用我们自己的运动框架做一个图片轮换播放器的例子效果如下： demo下载地址：https://github.com/Feyddy/JSPictureWheel]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Socket(理论篇)]]></title>
      <url>%2F2017%2F03%2F18%2FSocket-%E7%90%86%E8%AE%BA%E7%AF%87%2F</url>
      <content type="text"><![CDATA[网络模型网络模型的出现，由于网络是一个比较复杂的系统，所以需要将网络进行分层，每一层规范相应的职能。正如一个公司越来越大时，会进行改革，也就是部门划分，员工制度规范。网络也是一样，为了维持网络的可持续发展，所以网络模型就出来。 网络模型有OSI参考模型（局域网）和TCP/IP参考模型： OSI参考模型 OSI参考模型，只是为实现网络交互建立一个参考标准 其中OSI参考模型中分层的原则： 网络中各结点都有相同的层次 不同结点相同层次具有相同的功能 同一结点相邻层间通过接口通信 每一层可以使用下层提供的服务，并向上层提供服务 不同结点的同等层间通过协议来实现对等层间的通信 OSI参考模型各层职能 物理层:主要定义物理设备标准，如网线的接口类型、各种传输介质的传输速率等。主要作用是传输比特流(就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是常说的数模 与模数转换)。这一层的数据叫做比特(bit)，主要设备:集线器、网线。网线-水晶头-指针排序是规定 数据链路层:主要将从物理层接收的数据进行 MAC 地址的封装与解封装。常把这一层的数据叫做 帧，主要设备:网卡，交换机。IP地址可以对mac地址进行绑定；交换机也可以实现路由的功能，三层交换机 -带来路由的功能 网络层:选择合适的网间路由和交换结点， 确保数据及时传送，将从下层接收到的数据进行IP 地址的封装与解封装,称为 IP 协议。常把这一层数据叫做数据包，主要设备:路由器。192.168.0.23 传输到 192.168.0.140 - 最好确保它们之间行走的距离短 传输层:定义了一些传输数据的协议和端口，如 TCP、UDP 协议，主要将从下层接收的数据进行 分段和传输，到达目的地址后再进行重组，以往把这一层数据叫做段。通过端口来识别发送的是哪个应用，所以微信不会把消息发送到QQ上 会话层:通过传输层建立数据传输通道。在系统之间发起会话或者接受会话请求(设备之间需要 互相认识) 表示层:主要是进行对接收的数据进行解释、压缩与解压缩等，即把计算机能够识别的东西转化 成人能够识别的东西(如图片、声音等) 应用层:主要是一些终端的应用，比如说 FTP(各种文件下载)、浏览器、QQ 等，可以将其理解 为在电脑屏幕上可以看到的东西，也就是终端应用。 TCP/IP参考模型 TCP/IP参考模型是对OSI参考模型的简化 TCP/IP协议网络协议即网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为网络协议。 TCP/IP 协议是网络的基础，是 Internet 的语言，可以说没有 TCP/IP 协议就没有互联网的今天。 IP是网络层,TCP是传输层,UDP也是传输层的,socket属于会话层 什么是 TCP 和 UDP 及区别TCP(传输控制协议) 建立连接，形成传输数据的通道 在连接中进行大数据传输(数据大小不受限制) 通过三次握手完成连接，是可靠协议，安全送达 必须建立连接，效率会稍低 http就是基于tcp数据传输,每发送一次http请求就会建立三次握手； UDP(用户数据报协议) 将数据及源和目的封装成数据包中，不需要建立连接 每个数据包的大小限制在 64K 之内 因为无需连接，因此是不可靠协议，不安全 不需要建立连接，速度快 典型的例子就是屏幕共享和手机发短信； UDP数据传输是不安全，对方收不收得都是不能保证 网络通讯要素 IP地址(唯一标示网络设备的): 网络中设备的标示 不易记忆，可以用主机名 本地回环地址:127.0.0.1 主机名:localhost 本地回环地址可以测试网卡有没有问题 ping -c 4 127.0.0.1 结果如果ping不通，网卡坏了，或者网卡没插好。 ping -c 4 localhost的时候，返回的IP地址是127.0.0.1的原因：本地存在一个/etc/hosts文件。 下面我们打开这个文件看看： 1234567891011xuzhonglindeMacBook-Air-2:~ Feyddy$ cat /etc/hosts### Host Database## localhost is used to configure the loopback interface# when the system is booting. Do not change this entry.##127.0.0.1 localhost255.255.255.255 broadcasthost::1 localhostfe80::1%lo0 localhost 我们可以发现里面有127.0.0.1 localhost。这就代表当我们pinglocalhost的时候，其实就代表了127.0.0.1 当然我们可以更改/etc/hosts文件： sudo vi /etc/hosts 123456789101112131415161718192021222324### Host Database## localhost is used to configure the loopback interface# when the system is booting. Do not change this entry.##127.0.0.1 localhost255.255.255.255 broadcasthost::1 localhostfe80::1%lo0 localhost~~~~~~~~~~~~~&quot;/etc/hosts&quot; 10L, 236C 按下键盘i让终端进入编辑模式。 输入输入127.0.0.1 www.baidu.com 按:,然后输入wq退出编辑 这个时候如果我们用ping -c 4 www.baidu.com来访问百度的话实际上访问的就是127.0.0.1 访问域名的流程 会优先查看本地的hosts文件中有没有该IP地址： 端口号(定位程序) 用于标示进程的逻辑地址，不同进程的标示 有效端口:0~65535，其中 0~1024 由系统使用或者保留端口，开发中不要使用 1024 以下的端口 传输协议(用什么样的方式进行交互) 通讯的规则 常见协议:TCP、UDP TCP和HTTP的区别： TCP:传输协议(用什么样的方式进行交互) HTTP:协议（数据格式）请求头”content-type” content-size 编码方式URL编码 比如从广州到北京 坐飞机 高铁 火车（传输协议） 到了北京后，进行交流用英语 国语，(HTTP) URL(统一资源定位) http://ip:端口号/文件路径 http 是数据传输格式协议，tcp 是数据传输方式，tcp 相当于邮寄信封或者是打电话,http 相当于信或者 打电话是英语还是国语沟通 在开发过程中，经常发送HTTP请求，获取服务器返回的数据。访问不了数据问题可能是 “服务器没有开启” 这个时候我们就可以通过Telnet查看服务是否开启。 telnet IP 端口号 1234xuzhonglindeMacBook-Air-2:~ Feyddy$ telnet 127.0.0.1 80Trying 127.0.0.1...telnet: connect to address 127.0.0.1: Connection refusedtelnet: Unable to connect to remote host 我们可以看出本地的80端口没有开启。 当我们链接百度的IP地址的时候(端口也是80) 1234567891011121314xuzhonglindeMacBook-Air-2:~ Feyddy$ ping -c 4 www.baidu.comPING www.a.shifen.com (115.239.210.27): 56 data bytes64 bytes from 115.239.210.27: icmp_seq=0 ttl=53 time=8.483 ms64 bytes from 115.239.210.27: icmp_seq=1 ttl=53 time=6.883 ms64 bytes from 115.239.210.27: icmp_seq=2 ttl=53 time=9.352 ms64 bytes from 115.239.210.27: icmp_seq=3 ttl=53 time=10.773 ms--- www.a.shifen.com ping statistics ---4 packets transmitted, 4 packets received, 0.0% packet lossround-trip min/avg/max/stddev = 6.883/8.873/10.773/1.410 msxuzhonglindeMacBook-Air-2:~ Feyddy$ telnet 115.239.210.27 80Trying 115.239.210.27...Connected to 115.239.210.27.Escape character is &apos;^]&apos;. 可以看出连接成功。 Socket(套接字) Socket 就是为网络服务提供的一种机制 通信的两端都是 Socket 网络通信其实就是 Socket 间的通信 数据在两个 Socket 间通过 IO（输入输出流） 传输 HTTP 协议的传输实质就是 Socket 通信 模拟QQ聊天实现的socket流程 Socket通信流程图 案例:简单聊天室步骤: 启动聊天服务器 Python chatserver.py 连接到主机，分配输入输出流空间 建立长连接CFStreamCreatePairWithSocketToHost 将C语言的输入输出流转成OC对象 设置代理监听输入输出流的状态 添加到主运行循环，否理代理不工作 1[_inputStream scheduleInRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; 打开输入输出流 &gt;登录发送 12NSString *loginStr = [NSString stringWithFormat:@&quot;iam:zhangsan&quot;];NSData *data = [loginStr dataUsingEncoding:NSUTF8StringEncoding]; [_outputStream write:data.bytes maxLength:data.length]; 数据读取 123456789//建立个缓冲区来保存读取到的数据uint8_t buffer[1024]; //返回实际读取的数据长度NSInteger len = [_inputStream read:buffermaxLength:sizeof(buffer)];//有数据if (len &gt; 0) &#123; NSString* receiver = [[NSString alloc] initWithBytes:buffer length:lenencoding:NSUTF8StringEncoding];&#125; 断开连接要关闭输入输出流并移除主运行循环 实现配置服务器我们这里使用已经写好的一个Python文件：chatserver.py。它的详细代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344from twisted.internet.protocol import Protocol, Factoryfrom twisted.internet import reactorclass IphoneChat(Protocol): def connectionMade(self): #self.transport.write("""connected""") self.factory.clients.append(self) print "clients are ", self.factory.clients def connectionLost(self, reason): self.factory.clients.remove(self) def dataReceived(self, data): #print "data is ", data a = data.split(':') if len(a) &gt; 1: command = a[0] content = a[1] msg = "" if command == "iam": self.name = content msg = self.name + " has joined" elif command == "msg": msg = self.name + ": " + content print msg for c in self.factory.clients: c.message(msg) def message(self, message): self.transport.write(message + '\n')factory = Factory()factory.protocol = IphoneChatfactory.clients = []reactor.listenTCP(12345, factory)print "Iphone Chat server started"reactor.run() 我们通过终端进入此文件的目录下，运行python 文件名开启ChatSever服务 如果你本地没有文件，可以参考这篇博客：点击这里 如果是MAC系统可能涉及到权限的问题，所以在上面的博客里，在安装的时候前面最好都加上sudo。 实现登录功能http://192.168.0.1/login(后面的两个值为参数) 实现登录的功能：username passworld传给服务器socket: 192.168.0.1:12345登录指令：iam:Feyddy 实现发送聊天功能发送聊天数据指令：msg:xxxxx 下面开始进行小项目： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#import &quot;ViewController.h&quot;@interface ViewController ()&lt;NSStreamDelegate&gt;&#123; NSInputStream * _inputStream; NSOutputStream *_outputSteam;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib.&#125;//连接服务器- (IBAction)connectToServer:(id)sender &#123; //ios里实现sokcet的连接，使用C语言 // 1.与服务器通过三次握手建立连接 NSString *host = @&quot;127.0.0.1&quot;;//ip地址 int port = 12345;//端口号 // 2.定义输入输出流 CFReadStreamRef readStream; CFWriteStreamRef writeStream; // 3.分配输入输出流的内存空间 CFStreamCreatePairWithSocketToHost(NULL, (__bridge CFStringRef)host, port, &amp;readStream, &amp;writeStream); // 4.把C语言的输入输出流转成OC对象 _inputStream = (__bridge NSInputStream *)readStream; _outputSteam = (__bridge NSOutputStream *)(writeStream); // 5.设置代理,监听数据接收的状态 _outputSteam.delegate = self; _inputStream.delegate = self; // 把输入输入流添加到主运行循环(RunLoop) // 主运行循环是监听网络状态 [_outputSteam scheduleInRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; [_inputStream scheduleInRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; // 6.打开输入输出流 [_inputStream open]; [_outputSteam open];&#125;#pragma mark - NSStreamDelegate-(void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode&#123;// NSStreamEventOpenCompleted = 1UL &lt;&lt; 0,// NSStreamEventHasBytesAvailable = 1UL &lt;&lt; 1,// NSStreamEventHasSpaceAvailable = 1UL &lt;&lt; 2,// NSStreamEventErrorOccurred = 1UL &lt;&lt; 3,// NSStreamEventEndEncountered = 1UL &lt;&lt; 4 switch (eventCode) &#123; case NSStreamEventOpenCompleted: NSLog(@&quot;%@&quot;,aStream); NSLog(@&quot;成功连接建立，形成输入输出流的传输通道&quot;); break; case NSStreamEventHasBytesAvailable: NSLog(@&quot;有数据可读&quot;); [self readData]; break; case NSStreamEventHasSpaceAvailable: NSLog(@&quot;可以发送数据&quot;); break; case NSStreamEventErrorOccurred: NSLog(@&quot;有错误发生，连接失败&quot;); break; case NSStreamEventEndEncountered: NSLog(@&quot;正常的断开连接&quot;); break; default: break; &#125;&#125;//登录- (IBAction)loginBtnClick:(id)sender &#123; //发送登录请求 使用输出流 //拼接登录的指令 iam:zhangsan NSString * loginStr = @&quot;iam:zhangsan&quot;; //uint8_t * 字符数组 NSData * data = [loginStr dataUsingEncoding:NSUTF8StringEncoding]; [_outputSteam write:data.bytes maxLength:data.length];&#125;#pragma mark 读取服务器返回的数据-(void)readData&#123; //定义缓冲区 这个缓冲区只能存储1024字节 uint8_t buf[1024]; // 读取数据 // len为服务器读取到的实际字节数 NSInteger len = [_inputStream read:buf maxLength:sizeof(buf)]; // 把缓冲区里的实现字节数转成字符串 NSString * receiverStr = [[NSString alloc] initWithBytes:buf length:len encoding:NSUTF8StringEncoding]; NSLog(@&quot;%@&quot;,receiverStr);&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python初识]]></title>
      <url>%2F2017%2F03%2F17%2FPython%E5%88%9D%E8%AF%86%2F</url>
      <content type="text"><![CDATA[为什么这么受欢迎？面向对象，解释型计算机程序设计语言。 设计哲学：优雅，明确，简单，可读性强。优点：功能强大，开发效率高，应用广泛，易上手，语法简洁。用途： 网页开发 可视化（GUI）界面开发 网络 系统编程 数据分析 机器学习 网络爬虫 科学计算 哪些著名网站是用Python实现的？ 雅虎地图 谷歌中的很多组成部分 Youtube 豆瓣网 安装Python环境配置首先去Python官网下载安装包：https://www.python.org。 点击Downloads模块里面的MAC OSX系统（视情况而定）。 然后选择自己电脑相应的位数，例如我的是64位的。点击下载,安装。安装完成后你会发现： 这就是Python自带的IDEL。 IDLE介绍下面我们使用Python shell简单的编写python。 这就证明我们的Python已经成功安装在系统上面了。 下面介绍怎么建立具体的模块来运行代码。 然后会弹出下面的编辑窗口，然后我们进行简单的编辑： 按command+s进行保存 这样我们就完成了一个python文件的创建。 当然如果需要运行这个文件，我们可以直接点击Run,选择Run Module就可以了。 运行结果： 上面的Check Module是用来检查是否存在语法错误。 IDLE比较简单，满足不了大型开发。下面介绍其他的编辑软件。 PyDev介绍 Eclipse PyDev for Eclipse 下载Eclipse 下载安装Java http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 下载Eclipse http://www.pc6.com/mac/115396.html 配置PyDev以及安装package介绍Python interpreter代码解释器。所有的代码都需要通过它来执行。 命令行中运行Python（配置环境变量）(mac里面内置有python)这里我们讲解下如何升级MAC里面自带的Python。 先去python的官网下载最新的python(我这里下载的是3.6)，并安装好。现在要删除mac自带的python，如下： 1sudo rm -R /System/Library/Frameworks/Python.framework/Versions/2.7 把第一步里安装好的Python目录移到原本系统所持有的目录位置。 1sudo mv /Library/Frameworks/Python.framework/Versions/3.6 /System/Library/Frameworks/Python.framework/Versions 第三步，修改文件所属的Group.设置Group为wheel，原来系统自带的就是这样的。 1sudo chown -R root:wheel /System/Library/Frameworks/Python.framework/Versions/3.6 第四步，更新一下Current的Link。在Versions的目录里有一个Current的link，是指向当前的Python版本，原始是指向系统自带的Python2.7.2，我们把它删除后，link就失效了，所以需要重新链一下。 1sudo rm /System/Library/Frameworks/Python.framework/Versions/Current 1sudo ln -s /System/Library/Frameworks/Python.framework/Versions/3.6 /System/Library/Frameworks/Python.framework/Versions/Current 第五步，重新链接可执行文件 先把系统原来的执行文件删掉 1234567sudo rm /usr/bin/pydocsudo rm /usr/bin/pythonsudo rm /usr/bin/pythonwsudo rm /usr/bin/python-config 建立新的链接 1234567sudo ln -s /System/Library/Frameworks/Python.framework/Versions/3.6/bin/pydoc3.6 /usr/bin/pydocsudo ln -s /System/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6 /usr/bin/pythonsudo ln -s /System/Library/Frameworks/Python.framework/Versions/3.6/bin/pythonw3.6 /usr/bin/pythonwsudo ln -s /System/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6m-config /usr/bin/python-config 最后，更新一下.bash_profile文件 配置Eclipse 配置Eclipse中的java的路径(mac不需要配置) 测试java 配置PyDev 在Eclipse里安装PyDev 然后点击Add按钮,并且在里面输入下图中的文字： 我们发现Eclipse成功检测到 我们只需要选择下图中的就可以了 最后一步一步按照指示完成安装即可。 安装完成后，再新建的时候就会出现PyDev 下面我们新建一个Python文件 然后我们点击上图中的蓝色字体，让Eclipse知道我们选择哪块Python interpreter 为了快速，我们可以选择快速匹配。也可以手动。 完成后创建了项目。 下面我们开始新建一个基本模块 测试一下： 但是会出错 SyntaxError: Non-ASCII character &#39;\xe5&#39; in file /Users/admin/Documents/workspace/TestPython/PythonTest1.py on line 3, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details 这是因为我的代码里出现了中文编码年月日,所以需要在文件的第一行加上# -*- coding: UTF-8 -*-。 但是每创建一个文件就要粘贴一遍是在太烦了。下面我们来设置一下，一创建就自动添上这行代码。 在偏好设置里-&gt;PyDev-&gt;Templates-&gt;&lt;Empty&gt;-&gt;Edit-&gt;粘贴上# -*- coding: UTF-8 -*- Package以及数据类型自带(built-in)package和外部(external)package自带的包的使用。下面通过举例说明新建一个PyDev Project。然后import os（这个os就是自带的package,import是引入的方式） 123456789# -*- coding: UTF-8 -*- '''Created on 2017年3月9日@author: admin'''import os# 获取当前的路径print(os.getcwd()) 运行结果： 安装额外的package（package以及管理系统介绍：easy_install，pip）这两个工具3.4以上的版本就已经安装好了，只需要配置环境就可以直接使用。 环境变量中配置easy_install，pip 首先我们在终端中输入easy_install，可以发现已经安装好了，因为mac是需要权限的，所以执行下面的命令可以安装任何东西，包括pip。因为pip是easy_install的取代品。 sudo easy_install pip 然后输入电脑密码就可以了。 使用easy_install,pip安装package举例 我们来安装一个requests。这个是用提供很多针对网页的抓取和函数。 在终端中输入sudo pip install requests 12345678910sudo pip install requestsPassword:The directory &apos;/Users/admin/Library/Caches/pip/http&apos; or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo&apos;s -H flag.The directory &apos;/Users/admin/Library/Caches/pip&apos; or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo&apos;s -H flag.Collecting requests Downloading requests-2.13.0-py2.py3-none-any.whl (584kB) 100% |████████████████████████████████| 593kB 598kB/sInstalling collected packages: requestsSuccessfully installed requests-2.13.0xuzhonglindeMacBook-Air-2:bin admin$ 安装成功，然后我们导入： 123456xuzhonglindeMacBook-Air-2:workspace admin$ pythonPython 2.7.10 (default, Jul 30 2016, 19:40:32)[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.34)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import requests&gt;&gt;&gt; 但是你会发现并没有用，因为这个只是操作的系统自带的python2.7.10的。 但是我们可以通过加后缀在操作我们刚刚下载的3.6的 1234567891011xuzhonglindeMacBook-Air-2:~ admin$ pip3 install requestsCollecting requests Using cached requests-2.13.0-py2.py3-none-any.whlInstalling collected packages: requestsSuccessfully installed requests-2.13.0xuzhonglindeMacBook-Air-2:~ admin$ python3Python 3.6.0 (v3.6.0:41df79263a11, Dec 22 2016, 17:23:13)[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import requests&gt;&gt;&gt; 这样我们刚刚下载的就可以导入了。 python就是2的版本,python3就是3的版本. pip是2的版本, pip3是3的版本. 下面开始举例应用它： 123456789101112131415# -*- coding: UTF-8 -*- '''Created on 2017年3月9日@author: admin'''import osimport requests# 获取当前的路径print(os.getcwd())r = requests.get("http://www.baidu.com")print(r.url)#返回url地址print(r.encoding)#返回编码print(r.text)#返回了内容 运行结果： 12345/Users/admin/Documents/workspace/TeachingPythonhttp://www.baidu.com/ISO-8859-1&lt;!DOCTYPE html&gt;。。。。 数据类型Numeric(数字型)：int（包含Boolean）,float,complex（复数） int 长度不受限制 float 对应的是c语言的double，可查看具体范围：通过sys.float_info complex:real(实部)，imaginary(虚部)，用z.real和z.imag来获取 具体用法参考官方文件。 下面简单举几个小例子来了解一下Numeric类型： 1234567891011121314151617181920212223242526272829303132333435# -*- coding: UTF-8 -*- '''Created on 2017年3月11日@author: admin'''import sys#整型变量a = 3#声明变量的时候不需要申明类型，系统自动的判断b = 4#浮点型变量c = 5.66d = 8.0#复数变量complex(实部,虚部)#float()强转成浮点型e = complex(c,d)f = complex(float(a),float(b))#查询类型type()print("a is type:",type(a))print("a is type:",type(c))print("a is type:",type(e))print(a+b)print(d / c)print(b/a)#整数相除结果是浮点型print(b // a)#取整数部分print(e)print(f-e)#获取系统对浮点类型的详细信息print(sys.float_info) 运行结果： 12345678910a is type: &lt;class &apos;int&apos;&gt;a is type: &lt;class &apos;float&apos;&gt;a is type: &lt;class &apos;complex&apos;&gt;71.41342756183745591.33333333333333331(5.66+8j)(-2.66-4j)sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1) 字符串简单的来说，字符串就是一串字符。显示或者打印出来文字信息。下面介绍几个知识点： 表现形式：单引号，双引号，三引号。 12345678910111213141516# -*- coding: UTF-8 -*- '''Created on 2017年3月11日@author: Feyddy'''#单引号print('My blog site is http://www.feyddy.com')#双引号print("My blog site is http://www.feyddy.com")#三引号-输入换行显示print('''My name is Feyddy,my realName is xuzhonglin,my blog site is http://www.feyddy.com''') 运行结果： 12345My blog site is http://www.feyddy.comMy blog site is http://www.feyddy.comMy name is Feyddy,my realName is xuzhonglin,my blog site is http://www.feyddy.com 如果想打印中文字符串需要在模块中第一行加上编码，编码是：# -*- coding: UTF-8 -*-。 不可变（immutable） Format字符串,对字符串的格式进行调整，让他打印出来我们需要的格式 12345678910# -*- coding: UTF-8 -*- '''Created on 2017年3月11日@author: Feyddy'''name = "Feyddy"site = "http://www.feyddy.com"print("&#123;&#125; is blog site is &#123;&#125;".format(name, site))print("&#123;0&#125; is blog site is &#123;1&#125;".format(name, site)) 运行结果： 12Feyddy is blog site is http://www.feyddy.comFeyddy is blog site is http://www.feyddy.com 联合（前提必须保证所有的部分都是字符串,可以用str()将里面的值转成字符型`） 123456789# -*- coding: UTF-8 -*- '''Created on 2017年3月11日@author: Feyddy'''name = "Feyddy"age = 25print("My name is" + " " + name + ". I am " + str(age) + " years old") 运行结果： 1My name is Feyddy. I am 25 years old 换行符(\n) 字面常量（常量不会被改变）：如：6，34，“this is a”等，可以直接以字面的意义使用它们 变量： 它是用来储存信息，属于identifier，也就是变量名。 命名规则：第一个字符必须是字母或者下划线，其余字符可以使字母，数字，或者下划线，区分大小写。 注释：# 缩进 数据结构列表(list)列表操作包含以下函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding: UTF-8 -*- '''Created on 2017年3月14日@author: Feyddy'''import stringfrom _ast import Numprint("今天我们学习数据结构列表");#因为最上面第一行的设置，可以打印中文#换行print("今天我们学习这个\n明天我们学习那个");#创建一个listnumber_list = [25,26,35,36];print("number_list:" + str(number_list));string_list = ["Feyddy","xuzhonglin","tom"];print("string_list:" + str(string_list));mixed_list = ["Feyddy",25];print("mixed_list:" + str(mixed_list));#访问列表指定位置的元素print("number_list的第一个："+ str(number_list[0]) + "，string_list的第二个：" + str(string_list[1]) + "。mixed_list的名字：" + str(mixed_list[0]) + ",年龄：" + str(mixed_list[1]));#更新元素number_list[1] = 30;print("修改number_list第二个元素" + str(number_list));#删除元素del number_list[1];print("删除number_list第二个元素" + str(number_list));#求list的长度print("number_list的长度：" +str(len(number_list)));#两个list中的元素相加合并number_list2 = [1,2,3,4,35];print(number_list + number_list2);#list中的元素进行加减乘除print(number_list[1] *4);#判断list中是否包含某个值print(34 in number_list);#截取元素print(number_list[1]);#正向截取print(number_list[-2]);#反向截取indexprint(number_list[1:]);#截取第二个之后所有的 运行结果： 12345678910111213141516今天我们学习数据结构列表今天我们学习这个明天我们学习那个number_list:[25, 26, 35, 36]string_list:[&apos;Feyddy&apos;, &apos;xuzhonglin&apos;, &apos;tom&apos;]mixed_list:[&apos;Feyddy&apos;, 25]number_list的第一个：25，string_list的第二个：xuzhonglin。mixed_list的名字：Feyddy,年龄：25修改number_list第二个元素[25, 30, 35, 36]删除number_list第二个元素[25, 35, 36]number_list的长度：3[25, 35, 36, 1, 2, 3, 4, 35]140False3535[35, 36] 元组(Tuple) 创建只有一个元素的Tuple，需要用逗号结尾消除歧义； Tuple是不可变的list，一旦创建了一个tuple就不能以任何方式改变他； Tuple与list的相同之处： 整个元素集都是用小括号包含的； 都是按照定义的次序排序，索引也一样； 负数的索引都是从尾部开始的； 都可以用slice分片。注意当分割一个list时，会得到新的list，tuple也一样。 Tuple不存在的方法： 不能增减元素；可以用in来查看一个元素是否存在与tuple中 用Tuple的好处： 比list操作快。遍历的时候尽量用Tuple； 因为不能修改，所以安全； 可以和list转换 可以一次赋多个值 123456789101112131415161718192021222324252627282930313233343536# -*- coding: UTF-8 -*- '''Created on 2017年3月14日@author: Feyddy'''#元祖a_tuple = (2,);#这里必须加上,避免歧义print(a_tuple);#元组中的listmixed_tuple = (1,2,['a','b']);print(mixed_tuple);#修改元素。但是此时修改的并不是Tuple中的元素，而是list中的，对Tuple没有什么结构上的更改mixed_tuple[2][0] = 'Feyddy';print(mixed_tuple);#删除整个mixed_tuple，但是不能删除里面的某个元素，因为不能改变mixed_tuple# del mixed_tuple# print(mixed_tuple)#获取长度print(len(mixed_tuple))#相加print((1,2,3)+(4,5,6))#相乘print('hello' * 4)#判断是否存在某个元素print('a' in ('a','b','c'))#截取元素print(mixed_tuple[1]);#正向截取print(mixed_tuple[-2]);#反向截取indexprint(mixed_tuple[1:]);#截取第二个之后所有的 运行结果： 12345678910(2,)(1, 2, [&apos;a&apos;, &apos;b&apos;])(1, 2, [&apos;Feyddy&apos;, &apos;b&apos;])3(1, 2, 3, 4, 5, 6)hellohellohellohelloTrue22(2, [&apos;Feyddy&apos;, &apos;b&apos;]) 字典Dictionary基本语法：key:value 12345678910111213141516171819202122232425262728293031323334353637# -*- coding: UTF-8 -*- '''Created on 2017年3月16日@author: Feyddy'''#创建一个字典phone_book = &#123;"Feyddy":15757166448,"YUHAO":13166253623,"Crics":18555066961&#125;mixed_dict = &#123;"Feyddy":"xuzhonglin",11:11.5&#125;#读取字典里的值print("Feyddy is " + mixed_dict["Feyddy"] + ", his phone number is "+ str(phone_book["Feyddy"]))#修改字典里的值phone_book["YUHAO"] = 1233124124124print(str(phone_book["YUHAO"]))#添加一个值phone_book["HAONAN"] = 18809593139print(str(phone_book))#删除一个值del phone_book["YUHAO"]print(str(phone_book))#清空所有内容，但是字典还是存在的phone_book.clear()print(str(phone_book))#键可以是元组phone_book = &#123;("name"):"Feyddy"&#125;print(phone_book)#删除整个字典del phone_bookprint(str(phone_book)) 运行结果 123456789Feyddy is xuzhonglin, his phone number is 157571664481233124124124&#123;&apos;Feyddy&apos;: 15757166448, &apos;YUHAO&apos;: 1233124124124, &apos;Crics&apos;: 18555066961, &apos;HAONAN&apos;: 18809593139&#125;&#123;&apos;Feyddy&apos;: 15757166448, &apos;Crics&apos;: 18555066961, &apos;HAONAN&apos;: 18809593139&#125;&#123;&#125;&#123;&apos;name&apos;: &apos;Feyddy&apos;&#125; File &quot;/Users/admin/Documents/workspace/TeachingPython/5-Dictionary.py&quot;, line 33, in &lt;module&gt; print(str(phone_book))NameError: name &apos;phone_book&apos; is not defined 特性： 不允许两个相同的键。如果出现两个相同的键指向不同的内容，那么系统会自动选择后面一个键指向的内容； 键必须是不可变的，不能用列表来充当键，可以用数字，字符串或者元组充当。 函数函数的基本语法及用法函数：程序中可重复使用的程序段。给一段程序起一个名字，用这个名字来执行一段程序，反复使用（调用函数）用关键词def来定义，identifier(参数) identifier 参数list return statement 局部变量vs全局变量 定义函数的语法： 注意函数执行前面一定要有压根TAB 1234def 函数名(参数): 函数执行方法函数调用 下面介绍几个函数的定义以及使用方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#-*- coding: UTF-8 -*-#函数的基本定义及实现，无参无返回值def print_a(): a= 100 print(a)#函数调用print_a()#函数传参1无返回值def print_sum(a,b): sum = a+b print(sum)#函数调用print_sum(12,23)#函数传参2无返回值def print_str(name,blogSite): print("My name is " + name + ", my blogSite is " + blogSite)#函数调用print_str("Feyddy","www.Feyddy.com")#函数传参有返回值def repeat_str(str,times): repeated_str = str * times return repeated_str#函数调用repeat_strResult = repeat_str("Feyddy!",5)print(repeat_strResult)#全局变量xx = 60#函数定义def local_change_foo(x): #全局变量传进去只能读取，修改不了它原本的值 print("x is :"+str(x)) #局部变量，所以x的变化只在函数内部有用 x = 30 print("change local x to "+str(x))local_change_foo(x)#x还是60print("x is still "+ str(x))#在函数里面修改全局变量的值def global_change_foo(): #此时定义的x就是全局变量，所以接下来对x的改变会影响到全局的x值 global x print("x is :" + str(x)) x = 3 print("change local x to :" + str(x))global_change_foo()#x是3print("x is :"+ str(x)) 运行结果： 1234567891010035My name is Feyddy, my blogSite is www.Feyddy.comFeyddy!Feyddy!Feyddy!Feyddy!Feyddy!x is :60change local x to 30x is still 60x is :60change local x to :3x is :3 参数 默认参数：可以让多个参数都有默认值，但是默认值必须放在所有参数的最后面； 关键字参数：通过指定让某个参数等于多少，直接跨过中间的参数；而且指明赋值也可以不按照顺序来； VarArgs参数:通过*和**，具体用法见下面的代码； 下面结合具体的代码例子介绍这三种参数：123456789101112131415161718192021222324252627282930313233343536373839#-*- coding: UTF-8 -*-#############参数###################### 默认参数值def repeart_str_default_param(str,times = 2): repeated_str_default = str * times return repeated_str_default#使用默认值repeated_str_default_Result = repeart_str_default_param("Feyddy!")print(repeated_str_default_Result)#不使用默认值repeated_str_default_Result2 = repeart_str_default_param("Feyddy!",4)print(repeated_str_default_Result2)### 关键字参数def keyword_func(name,age = 25,sex = "male"): print("My name is ", name , ", my age is " , age,'I am ',sex)#正常传参keyword_func("Feyddy",28)#指明赋值keyword_func("Feyddy",sex = "female")#不按照顺序赋值keyword_func(sex = "female", name = "Feyddy")### VarArgs参数不定参数---`*`def print_params(name , *nums , **phones): print("name is "+ str(name)) print("nums is "+ str(nums)) print("phones is "+ str(phones))#如何判断nums和phones之间的分割数据，通过关键字phones，也就是说phones之后的都是属于phones这个里面的#phones的使用类似于字典的使用key : valueprint_params("Feyddy",1,2,3,4,5,phones = "Iphone" ,ano_phones = "android",girlFriends = "nobody",second_girl="still nobody") 运行结果 12345678Feyddy!Feyddy!Feyddy!Feyddy!Feyddy!Feyddy!(&apos;My name is &apos;, &apos;Feyddy&apos;, &apos;, my age is &apos;, 28, &apos;I am &apos;, &apos;male&apos;)(&apos;My name is &apos;, &apos;Feyddy&apos;, &apos;, my age is &apos;, 25, &apos;I am &apos;, &apos;female&apos;)(&apos;My name is &apos;, &apos;Feyddy&apos;, &apos;, my age is &apos;, 25, &apos;I am &apos;, &apos;female&apos;)name is Feyddynums is (1, 2, 3, 4, 5)phones is &#123;&apos;phones&apos;: &apos;Iphone&apos;, &apos;second_girl&apos;: &apos;still nobody&apos;, &apos;girlFriends&apos;: &apos;nobody&apos;, &apos;ano_phones&apos;: &apos;android&apos;&#125; 控制流if &amp;forif123456789101112131415161718#-*-coding:UTF-8-*-#####################If#################################猜数字number = 110#input函数可以让用户在控制台输入内容guess = int(input('请输入数字 :'))#if 判断if guess == number: #执行操作 print("Congratulation! ")elif guess &lt; number: print("your number is lower!")else: print("your number is higher!")print("Guess done!") 运行结果： 123请输入数字 :123 your number is higher! Guess done! for12345678910111213141516171819202122232425262728293031323334#-*-coding:UTF-8-*-#####################for################################print("####################range遍历###############")#range遍历for i in range(1,10): print(i)else: print("The for loop is over!")print("####################list遍历###############")#list遍历list = ['a','b','c','d']for i in list: print(i)print("###################tuple遍历###############")#tuple遍历tuple = (1,2,3,4,5,6)for i in tuple: print(i)print("###################Dictionary字典遍历方法一###############")#Dictionary字典遍历方法一dict = &#123;"a":1,"b":2,"c":3&#125;for ele in dict: print(ele) print(dict[ele])print("###################Dictionary字典遍历方法二###############")#Dictionary字典遍历方法二dict = &#123;"a":1,"b":2,"c":3&#125;for (key,value) in dict.items(): print(key,value) 运行结果 12345678910111213141516171819202122232425262728293031323334####################range历############### 1 2 3 4 5 6 7 8 9 The for loop is over! ####################list历############### a b c d ###################tuple历############### 1 2 3 4 5 6 ###################Dictionary字典遍历方法一############### a 1 c 3 b 2 ###################Dictionary字典遍历方法二############### (&apos;a&apos;, 1) (&apos;c&apos;, 3) (&apos;b&apos;, 2) while1234567891011121314151617181920#-*-coding:UTF-8-*-#########################while#############################做个猜数字游戏，直到用户猜对为止number = 60guess_flag = Falsewhile guess_flag == False: guess = int(input("请输入您猜的数字：")) if guess == number: guess_flag = True elif guess &gt; number: print("The number is higher than the right one") else: print("The number is lower than the right one")print("congratulation!")print("done!") 运行结果： 1234567请输入您猜的数字：56 The number is lower than the right one 请输入您猜的数字：62 The number is higher than the right one 请输入您猜的数字：60 congratulation! done! break &amp; continue &amp; pass break跳出当前循环,执行循环后面的任务； continue不执行当前这一次循环后面的内容,但是继续执行下一次循环； pass继续执行当前这一次循环判断后面的内容,然后继续执行下一次循环 123456789101112131415#########################break&amp;continue#########################number = 100;while True: guess = int(input("请输入数字：")) if guess == number: break elif guess &gt; number: print("The number is higher than the right one") continue else: print("The number is lower than the right one") continueprint("congratulation!")print("done!") 运行结果： 1234567请输入数字：10 The number is lower than the right one 请输入数字：102 The number is higher than the right one 请输入数字：100 congratulation! done! 123456789101112131415#continue和pass的区别number = 100;while True: guess = int(input("请输入数字：")) if guess == number: break elif guess &gt; number: continue print("The number is higher than the right one") else: pass print("The number is lower than the right one")print("congratulation!")print("done!") 运行结果： 123456请输入数字：16 The number is lower than the right one 请输入数字：120 请输入数字：100 congratulation! done! 输入输出输入输入方式介绍（Output Format）接受用户的输入： `input()`` 输入格式：str().format 123456789# -*- coding:UTF-8-*-####################输入输入方式介绍#########################name = input("请输入你的姓名:")#此时如果输入字符串需要加上双引号，而且里面的冒号必须是英文格式下的。否则报错age = input("请输入你的年龄:")print("你叫：" + name + ",你今年" + str(age) + "岁。你今年犯桃花")print("你叫:&#123;&#125;,你今年&#123;&#125;岁。你今年犯桃花").format(name,age) 运行结果： 1234请输入你的姓名:&quot;Feyddy&quot; 请输入你的年龄:25 你叫：Feyddy,你今年25岁。你今年犯桃花 你叫:Feyddy,你今年25岁。你今年犯桃花 文件写入读取方式介绍读取文件：open 写入文件:：write 关闭文件：close 123456789101112131415####################文件写入读出方式介绍##########################创建文件open然后写入(创建文件的路径以及文件名,文件当前的模式)f = open("PythonText.txt","w")#创建了一个名为"PythonText.txt"的文本文件，并且可以写。f.write("Feyddy's blogSite is www.Feyddy.com")#此时你会发现文本中出现了你写的内容f.close()#关闭文件，这个时候你就不能修改这个文件了。#读出文件内容f = open("PythonText.txt")#默认为可读状态'r'while True: line = f.readline() if len(line) == 0: break print(line)f.close() 运行结果： 1Feyddy&apos;s blogSite is www.Feyddy. 错误与异常处理(Error &amp; Exceptions)Python 有两种错误类型： 语法错误(Syntax Error) 异常(Error) 首先，try语句下的（try和except之间的代码）被执行；如果没有出现异常，except语句将被忽略；如果try语句之间出现了异常，try之下异常之后的代码将被忽略，直接跳跃到except语句；如果异常出现，但并不属于except中定义的异常类型，程序将被执行外围一片的try语句；如果异常没有被处理，将产生unhandled exception的错误。 处理异常（Handling Exceptions）1234567####################处理异常###############while True: try: x = int(input("请输入年龄:")) break except ValueError: print("您输入的不是数字，请重新输入！") 运行结果： 123请输入年龄:&quot;asd&quot; 您输入的不是数字，请重新输入！ 请输入年龄:25 下面介绍一个小例子： 先创建一个文件：PythonText.txt 1234567891011# -*- coding:UTF-8-*-##################系统异常和值异常#############try: f = open("PythonText.txt") s = f.readline() i = int(s.strip())#strip()为了让文字前面的空格移除 print("数字为：" + str(i))except IOError as err:#出现系统错误：比如文件不存在 print("IO error:&#123;&#125;".format(err))except ValueError: print("Could not convert data to integer!") 首先我们先将文件名改成一个没有的,如：PythonTex.txt，这个时候就找不到这个文件，就会走系统异常IOError 1IO error:[Errno 2] No such file or directory: &apos;PythonTex.txt&apos; 下面我们把文件名改正确，然后在里面写上：Feyddy&#39;s blogSite is www.Feyddy.comwelcome to visit。此时里面的字符串无法转变成整形。就会走ValueError。 1Could not convert data to integer! 然后我们将文件里的内容转化成33。这个时候就不会走异常处理了。 1数字为：33 面向对象处理面向对象编程Python支持面向对象编程 类(class):现实世界中一些事物的封装类：属性 类对象实例对象 引用：通过引用对类的属性和方法进行操作实例化：创建一个类的具体实例对象 12345678910111213141516171819202122232425#-*-coding:UTF-8-*-##创建一个学生类class Student: #当我们实例化一个类的对象的时候，会自动调用__init__这个函数 #self表示当前的这个类 def __init__(self, name,grade):#定义两个属性name和grade self.name = name self.grade = grade #自定义的一个介绍自己的方法 def introduce(self): print("My name is " + self.name) print("My grade is " + str(self.grade)) #定义的一个改变成绩的方法 def improve(self,amount): self.grade += amount#初始化创建一个Student对象feyddy = Student("Feyddy",125)#调用介绍自己的方法feyddy.introduce()#调用提高成绩的方法feyddy.improve(20)#调用介绍自己的方法feyddy.introduce() 运行结果： 1234My name is Feyddy My grade is 125 My name is Feyddy My grade is 145 装饰器（decorator） 普通的函数嵌套1234567891011121314#-*-coding:UTF-8-*-###普通调用def add_candles(cake_func):#参数是一个函数 def insert_candles(): return cake_func() + "candles" return insert_candlesdef make_cake(): return "cake"gift_func = add_candles(make_cake)print(make_cake())print(gift_func()) 运行结果： 12cake cakecandles 装饰器的使用 1234567891011###装饰器def add_candles(cake_func):#参数是一个函数 def insert_candles(): return cake_func() + " candles" return insert_candles#`@`就是装饰器@add_candlesdef make_cake(): return "cake"print(make_cake()) 运行结果： 1cake candles 图形界面(GUI)和猜数字游戏图形界面介绍GuiTkinter12345678910111213141516171819202122232425# -*- coding: UTF-8 -*- '''Created on 2017年3月17日@author: Feyddy'''from tkinter import *import tkinter.simpledialog as dlimport tkinter.messagebox as mbfrom cProfile import label#设置GUIroot = Tk()w = Label(root, text = "Feyddy")w.pack()#让文字自适应label大小#欢迎消息#给用户展示信息mb.showinfo("welcom", "Message")#提供用户输入的对话框guess = dl.askinteger("Number", "Enter a number")output = "This is output message"mb.showinfo("output:", output) 运行结果： 猜数字游戏 GUI 逻辑层 123456789101112131415161718192021222324252627282930313233343536373839# -*- coding: UTF-8 -*- '''Created on 2017年3月17日@author: Feyddy'''from tkinter import *import tkinter.simpledialog as dlimport tkinter.messagebox as mbfrom cProfile import label#设置GUIroot = Tk()w = Label(root, text = "Guess Number Game!")w.pack()#让文字自适应label大小number = 59#欢迎消息#给用户展示信息mb.showinfo("Welcome", "Welcome to Guess Number Game")while True: #用户输入信息 guess = dl.askinteger("Number","What's your guess?") if guess == number: output = "Congratulation!" mb.showinfo("Hint",output) break elif guess &lt; number: output = "Sorry ,the number is higher than yours!" mb.showinfo("Hint",output) else: output = "Sorry ,the number is higher than yours!" mb.showinfo("Hint",output)print("Done") 运行结果：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript运动事件(基础篇)]]></title>
      <url>%2F2017%2F03%2F16%2FJavaScript%E8%BF%90%E5%8A%A8%E4%BA%8B%E4%BB%B6-%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
      <content type="text"><![CDATA[知识点 运动基础-div移动12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;div移动&lt;/title&gt; &lt;style&gt; #div1 &#123; width: 100px; height: 100px; background-color: orange; position: absolute; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; var oDiv = document.getElementById('div1'); var oBtn = document.getElementById('btn1'); var timer = null;//创建一个定时器对象。方便后面对定时器的存在与否进行设置 oBtn.onclick = function () &#123; startMove(7); &#125; //封装一个移动函数 function startMove(iSpeed) &#123;//iSpeed移动的速度也就是定时器中每次加多少像素 clearInterval(timer);//防止多次点击按钮定时器相加，移动速度变快 timer = setInterval(function () &#123; if(oDiv.offsetLeft &gt;= 300)//一定要是大于等于，因为如果==300如果速度不能被整除就不会停了 &#123; clearInterval(timer);//在大于等于300像素的时候清除定时器 &#125;else &#123; oDiv.style.left = oDiv.offsetLeft + iSpeed + "px";//offsetLeft就是指当前的div的左边距 &#125; &#125;,30); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" id="btn1" value="开始运动"/&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 这里的startMove函数其实就是一个运动框架。 运动框架的应用分享侧边栏实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;分享到运动框架&lt;/title&gt; &lt;style&gt; #div1 &#123; width: 100px; height: 200px; background-color: #cccccc; position: absolute; left: -100px; &#125; #div1 span &#123; width: 20px; height: 60px; line-height: 20px; text-align: center; left: 100px; top: 70px; background-color: orange; position: absolute; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; var oDiv = document.getElementById('div1'); var timer = null; oDiv.onmouseover = function () &#123; startMove(0); &#125; oDiv.onmouseout = function () &#123; startMove(-100); &#125; function startMove(iTarget) &#123; clearInterval(timer); timer = setInterval(function () &#123; var iSpeed; if(oDiv.offsetLeft &lt; iTarget)&#123; iSpeed = 10; &#125;else&#123; iSpeed = -10; &#125; if(oDiv.offsetLeft == iTarget)&#123; clearInterval(timer); &#125;else &#123; oDiv.style.left = oDiv.offsetLeft + iSpeed + 'px'; &#125;1 &#125;,30); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt; &lt;span&gt;分享到&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行效果： 淡入淡出的图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;淡入淡出图片&lt;/title&gt; &lt;style&gt; #img1 &#123; filter: alpha(opacity:30);/*IE用的*/ opacity : 0.3; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; var timer = null; var oImg = document.getElementById('img1'); oImg.onmouseover = function () &#123; startChangeAlpha(1,30,100); &#125; oImg.onmouseout = function () &#123; startChangeAlpha(-1,100,30); &#125; function startChangeAlpha(iSpeed,startAlpha,iTarget) &#123;//参数解释：变化的速度，开始的alpha，目标alpha值 clearInterval(timer); var oAlpha = startAlpha;//因为没有offsetAlpha类似的方法获取他的透明度，所以需要通过一个值将它取出来。 timer = setInterval(function()&#123; if(oAlpha == iTarget)&#123; clearInterval(timer); &#125;else &#123; oAlpha += iSpeed; oImg.style.filter = "alpha(opacity:"+oAlpha+")"; oImg.style.opacity = oAlpha/100; &#125; &#125;,30) &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img src="Desert.jpg" alt="" id="img1"/&gt;&lt;/body&gt;&lt;/html&gt; 运行效果： 缓冲运动缓冲变慢： 越接近终点，速度越小；距离越大，速度越大；距离越小，速度越小。 div缓冲运动123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;缓冲运动&lt;/title&gt; &lt;style&gt; #div1 &#123; width: 100px; height: 100px; background-color: orange; position: absolute; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; var oDiv = document.getElementById('div1'); var oBtn = document.getElementById('btn1'); var timer = null; oBtn.onclick = function () &#123; startMove(300); &#125; function startMove(iTarget) &#123; clearInterval(timer); timer = setInterval(function () &#123; var iSpeed = (iTarget - oDiv.offsetLeft)/8;//动态改变速度就可以了。 if(oDiv.offsetLeft == iTarget)&#123; clearInterval(timer); &#125;else &#123; oDiv.style.left = oDiv.offsetLeft + iSpeed + "px"; &#125; &#125;,30); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" id="btn1" value="开始运动"/&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 看上去效果不错，但是里面有个小问题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;缓冲运动&lt;/title&gt; &lt;style&gt; #div1 &#123; width: 100px; height: 100px; background-color: orange; position: absolute; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; var oDiv = document.getElementById('div1'); var oBtn = document.getElementById('btn1'); var timer = null; oBtn.onclick = function () &#123; startMove(300); &#125; function startMove(iTarget) &#123; clearInterval(timer); timer = setInterval(function () &#123; var iSpeed = (iTarget - oDiv.offsetLeft)/8;//动态改变速度就可以了。 if(oDiv.offsetLeft == iTarget)&#123; clearInterval(timer); &#125;else &#123; oDiv.style.left = oDiv.offsetLeft + iSpeed + "px"; &#125; document.title = iSpeed + "距离" + oDiv.offsetLeft; &#125;,30); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" id="btn1" value="开始运动"/&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;span style="width: 1px;height: 300px;background-color:orange;position: absolute;left: 300px;top: 10px;"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 我们可以看到：速度到了后面就是小数了,div距离左边到达297的位置之后就不运动了，而且移动的div并没有完全和那条线重合。这是因为，计算机不会识别小数。当我们运行到297 + iSpeed的时候因为iSpeed是小数，计算机就自动忽略了。所以不会加上去。 这个时候我们需要用到两个函数：Math.ceil()向上取整和Math.floor()向下取整。所以我们需要将上面代码中的 1oDiv.style.left = oDiv.offsetLeft + iSpeed + "px"; 改成： 1oDiv.style.left = oDiv.offsetLeft + Math.ceil(iSpeed) + "px";//速度向上取整 运行结果： 看上去完美，但是如果我已开始就把div放在竖线的右边呢？比如，我把div的left属性改成500px。 结果就会如下： 你会发现，这个时候，运动到307就停止了。此时我们就需要完善一下我们的代码； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;缓冲运动&lt;/title&gt; &lt;style&gt; #div1 &#123; width: 100px; height: 100px; background-color: orange; position: absolute; left: 500px; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; var oDiv = document.getElementById('div1'); var oBtn = document.getElementById('btn1'); var timer = null; oBtn.onclick = function () &#123; startMove(300); &#125; function startMove(iTarget) &#123; clearInterval(timer); timer = setInterval(function () &#123; var iSpeed = (iTarget - oDiv.offsetLeft)/8;//动态改变速度就可以了。 iSpeed = iSpeed &gt; 0 ? Math.ceil(iSpeed) : Math.floor(iSpeed);// if(iSpeed &gt; 0)&#123;// iSpeed = Math.ceil(iSpeed);// &#125;else// &#123;// iSpeed = Math.floor(iSpeed);// &#125; if(oDiv.offsetLeft == iTarget)&#123; clearInterval(timer); &#125;else &#123; oDiv.style.left = oDiv.offsetLeft + Math.ceil(iSpeed) + "px";//速度向上取整 &#125; document.title = iSpeed + "距离" + oDiv.offsetLeft;//速度计算机对小数无法识别 &#125;,30); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" id="btn1" value="开始运动"/&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;span style="width: 1px;height: 300px;background-color:orange;position: absolute;left: 300px;top: 10px;"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 运行结果：正向的和上面的一样的效果。反向的如下： 缓冲菜单制作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #div1 &#123; width: 100px; height: 100px; background-color: orange; position: absolute; right: 0; &#125; &lt;/style&gt; &lt;script&gt; window.onscroll = function () &#123; var oDiv = document.getElementById('div1'); var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;// oDiv.style.top = scrollTop + (document.documentElement.clientHeight - oDiv.offsetHeight)/2 + "px"; var targets = scrollTop + (document.documentElement.clientHeight - oDiv.offsetHeight)/2; startMove(parseInt(targets));//这里是为了防止出现除不尽，会导致div上下抖动半个像素 &#125; var timer = null; function startMove(iTarget) &#123; clearInterval(timer); var oDiv = document.getElementById('div1'); var oInput = document.getElementsByTagName('input'); timer = setInterval(function()&#123; var iSpeed = (iTarget - oDiv.offsetTop) / 7; iSpeed = iSpeed &gt; 0? Math.ceil(iSpeed) : Math.floor(iSpeed); if(oDiv.offsetTop == iTarget)&#123; clearInterval(timer); &#125;else &#123; oDiv.style.top = oDiv.offsetTop + iSpeed + "px"; &#125; &#125;,30); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body style="height: 2000px;"&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 匀速运动我们需要用到一个绝对值函数:Math.abs() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;匀速运动&lt;/title&gt; &lt;style&gt; #div1 &#123; width: 100px; height: 100px; background-color: orange; position: absolute; left: 0px; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; var oBtn = document.getElementById('btn1'); oBtn.onclick = function()&#123; startMove(300); &#125; &#125; var timer = null; function startMove(iTarget) &#123; var oDiv = document.getElementById('div1'); clearInterval(timer); timer = setInterval(function()&#123; var iSpeed = iTarget - oDiv.offsetLeft; if(iSpeed &gt; 0)&#123; iSpeed = 7; &#125;else &#123; iSpeed = -7; &#125; if(Math.abs(iTarget - oDiv.offsetLeft)&lt;7)&#123; clearInterval(timer); oDiv.style.left = iTarget+ "px"; &#125;else &#123; oDiv.style.left = oDiv.offsetLeft + iSpeed + "px"; &#125; &#125;,30); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" id="btn1" value="开始运动"/&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;span style="width: 1px;height: 300px;background-color:orange;position: absolute;left: 300px;top: 10px;"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 运行效果：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript基础-AJAX]]></title>
      <url>%2F2017%2F03%2F15%2FJavaScript%E5%9F%BA%E7%A1%80-AJAX%2F</url>
      <content type="text"><![CDATA[知识点 Ajax基础什么是服务器？传统的表单form，当我提交的时候整个页面都会刷新，这个时候用户体验就不好，而且也会给浏览器一些负担。Ajax是在不刷新页面的前提下提交页面数据或者从服务器上读取数据。但是他只能从服务器上读取数据。 下面介绍一下AMP的安装：(因为我的是MAC系统，所以安装MAMP) 首先在官方网站下载(MAMP):https://www.mamp.info/en/downloads/ 然后点击安装，如果没有修改安装地址的话，默认会在 下面我们设置一下访问方式： 点击set web &amp; mysql ports to 80 &amp; 3306。 然后就可以直接在浏览器中输入http://localhost/FeyddyBlog.txt,这个时候浏览器会访问你本地的服务器。 运行结果： 举例使用Ajax库简单介绍一下Ajax.js这个库，它是异步读取数据的： 12345678910111213141516171819202122232425262728293031323334353637function ajax(url, fnSucc, fnFaild)&#123; //1.创建Ajax对象 var oAjax=null; if(window.XMLHttpRequest) &#123; oAjax=new XMLHttpRequest(); &#125; else &#123; oAjax=new ActiveXObject("Microsoft.XMLHTTP"); &#125; //2.连接服务器 oAjax.open('GET', url, true); //3.发送请求 oAjax.send(); //4.接收服务器的返回 oAjax.onreadystatechange=function () &#123; if(oAjax.readyState==4) //完成 &#123; if(oAjax.status==200) //成功 &#123; fnSucc(oAjax.responseText); &#125; else &#123; if(fnFaild) fnFaild(oAjax.status); &#125; &#125; &#125;;&#125; 简介解析一下： function ajax(文件的地址, 函数, fnFaild) 下面正式用一下： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;读取文件&lt;/title&gt; &lt;script src="ajax.js"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function () &#123; var oBtn = document.getElementById('btn1'); oBtn.onclick = function () &#123; //ajax能且仅能从服务器中读取数据 ajax('FeyddyBlog.txt', function (str) &#123; alert(str);//str为从服务器中获取的数据 &#125;) &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;点击按钮获取服务器中的数据：注意这里的文件路径必须放在服务器路径里面,文件名不能为中文&lt;input type="button" value="读取文件" id="btn1"/&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 字符集编码下面我们对服务器下多个文档进行读取切换，但是这三个文档的文件编码格式不一样。让我们看一下运行结果。 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;获取多个文件内容字符编码问题&lt;/title&gt; &lt;style&gt; div&#123; width: 200ex; height: 200px; background-color: #cccccc; border: 1px solid orange; &#125; &lt;/style&gt; &lt;script src="ajax.js"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function () &#123; var aBtns = document.getElementsByTagName('input'); var oDiv = document.getElementById('div1'); var i = 0; for(i = 0; i &lt; aBtns.length;i++)&#123; aBtns[i].index = i;//不能通过i来获取文件 aBtns[i].onclick = function () &#123; ajax('FeyddyBlog_' + this.index + '.txt', function (str) &#123; oDiv.innerHTML = str; &#125;) &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" id="btn1" value="按钮1"/&gt;&lt;input type="button" id="btn2" value="按钮2"/&gt;&lt;input type="button" id="btn3" value="按钮3"/&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 按按钮2显示的乱码是因为这个文件里面的内容不是UT-8格式的。需要修改成统一的。 缓存、阻止缓存所谓的缓存也就是说他只读一次，也就是第一次进入页面的时候从服务器获取数据，后面再进入的时候会直接从缓存本地读取，而服务器中的数据就不会重新获取了。它可以加速网络的访问。但是却不能及时更新数据的显示。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;缓存&lt;/title&gt; &lt;script src="ajax.js"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function () &#123; var oBtn = document.getElementById('btn1'); oBtn.onclick = function () &#123; ajax('cache_test.txt', function (str) &#123; alert(str); &#125;) &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;点击按钮读取文件&lt;input type="button" id="btn1" value="读取文件"/&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 然后我们将文本内容改成good good study,day day up!。 显示的还是 这就是缓存的结果。 那么怎么解决这个问题呢？ 首先我们了解一下缓存的机制： 缓存其实是根据地址来缓存东西的，也就是同样的地址这个东西只存储一次。所以只需要让地址不一样就行了。 我们可以给每个地址后面加上一个时间。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;缓存&lt;/title&gt; &lt;script src="ajax.js"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function () &#123; var oBtn = document.getElementById('btn1'); oBtn.onclick = function () &#123; alert('cache_test.txt?t=' + new Date().getTime()); ajax('cache_test.txt?t=' + new Date().getTime(), function (str) &#123; alert(str); &#125;) &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;点击按钮读取文件&lt;input type="button" id="btn1" value="读取文件"/&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 地址：数据：文件修改后： 地址：内容： 动态数据请求eval我们做个小例子：读取文件中的数组并使用。文件中的数组[1,4,6,87,45,75] Ajax请求后获取的数据都是文本字符型；我们要做的就是将返回的文本转换成数组的形式。 我们就可以使用eval:计算字符串里面的值。他的功能比较强大，可以识别字符串里面的是数组，还是方法，还是其他的具有特殊功能性的字符串。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;请求并使用文件中的数组&lt;/title&gt; &lt;script src="ajax.js"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function () &#123; var oBtn = document.getElementById('btn1'); oBtn.onclick = function () &#123; ajax('data_array.txt', function (str) &#123; var array = eval(str); alert(array[0]); &#125;) &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;请求服务器中的一个文件，文件中是一个数组 &lt;br/&gt;&lt;input type="button" value="读取数组文件" id="btn1"/&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： json新建一个json文件：[{job:&quot;iOS开发工程师&quot;,experience:3},{name:&quot;Feyddy&quot;,age:25}] 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;json&lt;/title&gt; &lt;script src="ajax.js"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function () &#123; var oBtn = document.getElementById('btn1'); oBtn.onclick = function () &#123; ajax('data_json.json', function (str) &#123; var jsonArray = eval(str); alert(jsonArray[0].job); &#125;) &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;请求服务器中的一个文件，文件中是一个json &lt;br/&gt;&lt;input type="button" value="读取json文件" id="btn1"/&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 实现换页的效果123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;page&lt;/title&gt; &lt;script src="ajax.js"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function () &#123; var oUl = document.getElementById('ul1'); var aAs = document.getElementsByTagName('a'); var i; for(i = 0; i &lt;aAs.length;i++)&#123; aAs[i].index = i; aAs[i].onclick = function () &#123; ajax("page"+(this.index+1) + ".txt", function (str) &#123; var aData = eval(str); oUl.innerHTML = "";//清空所有的元素 for(i = 0; i &lt; aData.length;i++) &#123; var oLi = document.createElement('li'); oLi.innerHTML = '&lt;strong&gt;用户名：'+aData[i].userName+'；&lt;/strong&gt;' + "&lt;i&gt;密码：" + aData[i].passWorld + "。&lt;/i&gt;"; oUl.appendChild(oLi); &#125; &#125;) &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id="ul1"&gt;&lt;/ul&gt;&lt;a href="javascript:;"&gt;1&lt;/a&gt;&lt;a href="javascript:;"&gt;2&lt;/a&gt;&lt;a href="javascript:;"&gt;3&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 点击1 点击2 Ajax原理HTTP请求方法GET方法下面通过表单介绍一下： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;http请求&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="http://www.feyddy.com" method="get"&gt; 用户名：&lt;input type="text" name="userName"/&gt;&lt;!--name 属性是给后台使用的，就是字段--&gt; 密码：&lt;input type="password" name="passWorld"/&gt; &lt;input type="submit"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 从上图可以看到，链接后面的一串/?userName=Feyddy&amp;passWorld=LOVE和我提交的内容一样。这就是GET方法，直接拼接上。 POST方法1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;http请求&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="http://www.feyddy.com" method="post"&gt; 用户名：&lt;input type="text" name="userName"/&gt;&lt;!--name 属性是给后台使用的，就是字段--&gt; 密码：&lt;input type="password" name="passWorld"/&gt; &lt;input type="submit"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 提交后你会发现url里面http://www.feyddy.com/没有自己刚刚输入的内容。 POST方法和GET方法的区别get:把数据放在URL（网址）里面来提交post:把数据放在http content里面提交，在url里面不会显示 get：安全性很低，容易在历史记录里面看到自己的用户名等等、容量很低、便于分享post：安全性一般、容量几乎无限 写一个自己的Ajax库Ajax请求的步骤： 创建Ajax对象； 连接服务器； 发送请求； 接受返回值； 小知识点：全局变量和函数其实是window的一个属性，只不过window可以不写。当你用一个不存在的变量的时候，会出错；但是用一个不存在的属性的时候，只会显示未定义（undefined）； 下面我们开始自己写Ajax库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Ajax&lt;/title&gt; &lt;script&gt; window.onload = function () &#123; var oBtn = document.getElementById('btn1'); oBtn.onclick = function () &#123; //1.创建ajax对象,但是XMLHttpRequest在IE6以下无法使用 // var oAjax = new XMLHttpRequest(); //IE6 // var oAjax = new ActiveXObject("Microsoft.XMLHTTP");//插件 var oAjax = null; //这里如果用if (XMLHttpRequest)的话还是在IE6下报错，因为IE6下没有XMLHttpRequest函数。所以只能使用属性函数 if (window.XMLHttpRequest) &#123; oAjax = new XMLHttpRequest(); &#125; else &#123; oAjax = new ActiveXObject("Microsoft.XMLHTTP"); &#125; //2.连接服务器 //open(方法,url，是否异步) oAjax.open('GET','FeyddyBlog_0.txt',true); //3.发送请求 oAjax.send(); //4.接受返回信息 //onreadystatechange类似于window.onload，但是不一样。当Aajx和服务器之间有通讯发生的时候，有状态变化的时候会调用 oAjax.onreadystatechange = function () &#123; //oAjax.readyState告诉我们ajax和服务器之间的通信完成到哪一步了。他总共有5种状态。详情看知识点。其实我们观察的只是状态4（完成），其他的都不重要。 if (oAjax.readyState == 4) &#123;//只能代表请求完成，但是不一定是成功 //oAjax.status 这个代表请求的相关结果是否成功。200代表成功 if (oAjax.status == 200) &#123; //oAjax.responseText请求得到的返回值 alert('请求成功：' + oAjax.responseText); &#125;else &#123; alert('请求失败'); &#125; &#125; &#125; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id="btn1" type="button" name="" value="读取文件"&gt; &lt;/body&gt;&lt;/html&gt; 下面我们对js代码进行提取封装： 12345678910111213141516171819202122232425262728293031323334353637383940function ajax(url,fnSucc,fnFaild) &#123; //1.创建ajax对象,但是XMLHttpRequest在IE6以下无法使用 // var oAjax = new XMLHttpRequest(); //IE6 // var oAjax = new ActiveXObject("Microsoft.XMLHTTP");//插件 var oAjax = null; //这里如果用if (XMLHttpRequest)的话还是在IE6下报错，因为IE6下没有XMLHttpRequest函数。所以只能使用属性函数 if (window.XMLHttpRequest) &#123; oAjax = new XMLHttpRequest(); &#125; else &#123; oAjax = new ActiveXObject("Microsoft.XMLHTTP"); &#125; //2.连接服务器 //open(方法,url，是否异步) oAjax.open('GET',url,true); //3.发送请求 oAjax.send(); //4.接受返回信息 //onreadystatechange类似于window.onload，但是不一样。当Aajx和服务器之间有通讯发生的时候，有状态变化的时候会调用 oAjax.onreadystatechange = function () &#123; //oAjax.readyState告诉我们ajax和服务器之间的通信完成到哪一步了。他总共有5种状态。详情看知识点。其实我们观察的只是状态4（完成），其他的都不重要。 if (oAjax.readyState == 4) &#123;//只能代表请求完成，但是不一定是成功 //oAjax.status 这个代表请求的相关结果是否成功。200代表成功 if (oAjax.status == 200) &#123; //oAjax.responseText请求得到的返回值 // alert('请求成功：' + oAjax.responseText); fnSucc(oAjax.responseText) &#125;else &#123; // alert('请求失败'); if (fnFaild) &#123; fnFaild(); &#125; &#125; &#125; &#125;&#125; 下面用我们封装的Ajax库使用： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Ajax&lt;/title&gt; &lt;script src="myAjax.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; ajax('FeyddyBlog_0.txt',function (str) &#123; alert(str); &#125;,function () &#123; alert('失败了'); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 运行结果：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript事件详解(进阶篇)]]></title>
      <url>%2F2017%2F03%2F14%2FJavaScript%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3-%E8%BF%9B%E9%98%B6%E7%AF%87%2F</url>
      <content type="text"><![CDATA[JavaScript基础(进阶篇)知识点首先我们来进行知识点的预览： 默认行为什么叫默认行为？举个小例子。比如说，如果我们在浏览器中不写任何代码，直接右键，那么会出现一个弹出菜单框，这就是系统默认行为。 oncontextmenu(环境菜单-上下文菜单)它其实是系统的右键响应事件。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;oncontextmenu&lt;/title&gt; &lt;script&gt; document.oncontextmenu = function () &#123; alert('a'); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 当我们右键的时候首先出现： 然后点击确定又会弹出 这个就是系统的默认行为。 那么我们怎么阻止默认行为呢？使用return false 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;oncontextmenu&lt;/title&gt; &lt;script&gt; document.oncontextmenu = function () &#123; alert('Feyddy'); return false; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 这样系统的弹出框就不会显示出来。 下面我们结合表单来了解一下return false。 阻止表单提交1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;阻止表单提交&lt;/title&gt; &lt;script&gt; window.onload = function () &#123; var oForm = document.getElementById('form1'); oForm.onsubmit = function () &#123; return false; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="http://www.feyddy.com" id="form1"&gt; &lt;input type="submit"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 此时点击按钮完全不会跳转界面。 这个方法一般用来验证表单的信息： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;验证表单&lt;/title&gt; &lt;script&gt; window.onload = function () &#123; var oBtn = document.getElementById('btn1'); var oTxt = document.getElementById('txt1'); var oForm = document.getElementById('form1'); oForm.onsubmit = function () &#123; if(oTxt.value != "Feyddy")&#123; alert("请输入\"Feyddy\""); return false; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="http://www.feyddy.com" id="form1"&gt; &lt;input type="text" id="txt1"/&gt; &lt;input type="submit" id="btn1"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 此时，如果你不输入，或者说输入的字符串不是Feyddy的话，就会弹出提示框。如果输入正确就会直接跳转到我的博客。 阻止onkeydown事件123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;阻止onkeydown&lt;/title&gt; &lt;script&gt; window.onload = function () &#123; var oTxt = document.getElementById('txt1'); oTxt.onkeydown = function () &#123; return false; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text" id="txt1"/&gt;&lt;/body&gt;&lt;/html&gt; 这个时候无论你怎么敲键盘上的字都不会显示。 弹出自定义的右键菜单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;自定义弹出框&lt;/title&gt; &lt;style media="screen"&gt; * &#123; margin: 0; padding: 0; &#125; #ul1 &#123; width: 100px; height: 100px; background-color: #ccc; border: 1px solid black; position: absolute; display: none; &#125; li &#123; list-style: none; &#125; &lt;/style&gt; &lt;script type="text/javascript"&gt; document.oncontextmenu = function (ev) &#123; var oEvent = ev || event; var oUl = document.getElementById('ul1'); oUl.style.display = 'block'; oUl.style.left = oEvent.clientX + "px"; oUl.style.top = oEvent.clientY + "px"; return false; &#125; document.onclick = function (ev) &#123; var oUl = document.getElementById('ul1'); oUl.style.display = 'none'; return false; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;ul id="ul1"&gt; &lt;li&gt;登录&lt;/li&gt; &lt;li&gt;回到首页&lt;/li&gt; &lt;li&gt;注销&lt;/li&gt; &lt;li&gt;加入VIP&lt;/li&gt;&lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 运行结果： 只能输入数字的输入框123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;只能输入数字的文本框&lt;/title&gt; &lt;script type="text/javascript"&gt; window.onload = function () &#123; var oTxt = document.getElementById('txt1'); oTxt.onkeydown = function (ev) &#123; var oEvent = ev || event; if (oEvent.keyCode!=8 &amp;&amp; (oEvent.keyCode&lt;48 || oEvent.keyCode&gt;57)) &#123; return false; &#125; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="text" name="" value="" id="txt1"&gt; &lt;/body&gt;&lt;/html&gt; 拖拽鼠标拖拽div移动我们需要用到三个事件： onmousedown:存储div与鼠标的距离onmousemove:根据距离，计算div最新位置onmouseup:将onmousemove停止 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;拖拽&lt;/title&gt; &lt;style media="screen"&gt; #div1 &#123; width: 100px; height: 100px; background-color: orange; position: absolute; &#125; &lt;/style&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; var oDIV = document.getElementById('div1'); var distanceX = 0; var distanceY = 0; oDIV.onmousedown = function (ev) &#123; var oEvent = ev||event; distanceX = oEvent.clientX - oDIV.offsetLeft; distanceY = oEvent.clientY - oDIV.offsetTop; oDIV.onmousemove = function(ev) &#123; var oEvent = ev || event; oDIV.style.left = oEvent.clientX - distanceX + 'px'; oDIV.style.top = oEvent.clientY - distanceY + 'px'; &#125; oDIV.onmouseup = function () &#123; oDIV.onmousemove = null; oDIV.onmouseup = null; &#125; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="div1"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 运行下来你会发现一个问题：如果鼠标移动过快，会移出div区域，但是我们的事件施加在div上面，所有此时的div将不会移动。这个时候我们就可以用到document 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;拖拽&lt;/title&gt; &lt;style media="screen"&gt; #div1 &#123; width: 100px; height: 100px; background-color: orange; position: absolute; &#125; &lt;/style&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; var oDIV = document.getElementById('div1'); var distanceX = 0; var distanceY = 0; document.onmousedown = function (ev) &#123; var oEvent = ev||event; distanceX = oEvent.clientX - oDIV.offsetLeft; distanceY = oEvent.clientY - oDIV.offsetTop; document.onmousemove = function(ev) &#123; var oEvent = ev || event; oDIV.style.left = oEvent.clientX - distanceX + 'px'; oDIV.style.top = oEvent.clientY - distanceY + 'px'; &#125; document.onmouseup = function () &#123; document.onmousemove = null; document.onmouseup = null; &#125; return false;//为了解决都版本FF空的div无法拖拽的问题 &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="div1"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 但是此时又会有一个问题，那就是可以把div拖到页面的外面去。下面进行完善： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;拖拽&lt;/title&gt; &lt;style media="screen"&gt; #div1 &#123; width: 100px; height: 100px; background-color: orange; position: absolute; &#125; &lt;/style&gt; &lt;script type="text/javascript"&gt; window.onload = function() &#123; var oDIV = document.getElementById('div1'); var distanceX = 0; var distanceY = 0; document.onmousedown = function (ev) &#123; var oEvent = ev||event; distanceX = oEvent.clientX - oDIV.offsetLeft; distanceY = oEvent.clientY - oDIV.offsetTop; document.onmousemove = function(ev) &#123; var oEvent = ev || event; var leftV = oEvent.clientX - distanceX; var topV = oEvent.clientY - distanceY; if (leftV&lt;0) &#123; leftV = 0; &#125;else if (leftV &gt; document.documentElement.clientWidth - oDIV.offsetWidth) &#123; leftV = document.documentElement.clientWidth - oDIV.offsetWidth;//document.documentElement.clientWidth为可视区的宽度 &#125; if (topV&lt;0) &#123; topV = 0; &#125;else if (topV &gt; document.documentElement.clientHeight - oDIV.offsetHeight) &#123; topV = document.documentElement.clientHeight - oDIV.offsetHeight; &#125; oDIV.style.left = leftV + "px"; oDIV.style.top = topV + "px"; &#125; document.onmouseup = function () &#123; document.onmousemove = null; document.onmouseup = null; &#125; return false;//为了解决都版本FF空的div无法拖拽的问题 &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="div1"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript事件详解(基础篇)]]></title>
      <url>%2F2017%2F03%2F13%2FJavaScript%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3-%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
      <content type="text"><![CDATA[JavaScript事件详解-基础篇知识点介绍： 小知识点 首先，我们做个小例子：点击页面中的任何一个位置，弹出提示框。我们第一个想到的就是给body增加一个点击事件。然后结果并没有用什么用。 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;点击页面任何地方弹出提示框&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; document.body.onclick = function()&#123; alert('aaa'); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body style="background-color:red;"&gt;&lt;/body&gt;&lt;/html&gt; 下面我们该怎么做呢？可以给document这个节点添加点击事件。 document是什么？他其实是最外层的父节点，平时是看不到的。如下： 123456789101112131415&lt;document&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;document是什么&lt;/title&gt; &lt;script&gt; alert(document.childNodes[0]); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&lt;/document&gt; 所以我们可以通过它来找到它里面的所有的东西。 因此，我们不论点击页面的哪个位置，它都不会出document的范围，所以我们只要将点击事件加在document上面之后就可以点击页面的任何地方都能触发这个事件了。而且，还有就是document不需要再window.onload里面进行 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;document是什么&lt;/title&gt; &lt;script&gt; document.onclick = function() &#123; alert("我是document点击事件"); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下： event对象和事件冒泡event对象123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;event事件对象&lt;/title&gt; &lt;script&gt; document.onclick = function(ev) &#123; //IE下很正常// alert("鼠标点击的位置" + "横坐标："+ event.clientX + "纵坐标："+ event.clientY);//鼠标点击地方的横坐标和纵坐标 //FF下不兼容,需要在点击方法加上参数，这个参数就是系统返还的点击的对象---但是IE下不兼容// alert("鼠标点击的位置" + "横坐标："+ ev.clientX + "纵坐标："+ ev.clientY);//鼠标点击地方的横坐标和纵坐标 //处理兼容性方法 if(ev)&#123; alert("鼠标点击的位置" + "横坐标："+ ev.clientX + "纵坐标："+ ev.clientY);//鼠标点击地方的横坐标和纵坐标 &#125;else &#123; alert("鼠标点击的位置" + "横坐标："+ event.clientX + "纵坐标："+ event.clientY);//鼠标点击地方的横坐标和纵坐标 &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 下面对源代码进行完善，用||。他的基本使用如下: a||b：他会把a和b中真的那个返回出来；如果都为真，返回第一个；如果都为假也返回第二个。 这样我们就可以完善一下： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;event事件对象&lt;/title&gt; &lt;script&gt; document.onclick = function(ev) &#123; var Event = alert("鼠标点击的位置" + "横坐标："+ ev.clientX + "纵坐标："+ ev.clientY) || alert("鼠标点击的位置" + "横坐标："+ event.clientX + "纵坐标："+ event.clientY); alert(Event); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 事件冒泡它的意思就是当我们点击一个事件的时候，他完成事件之后并不是就消失了，而是继续向他的父级传递，让父级也相应父级的事件。这样一级一级的向上传递。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en" onclick="alert(this.tagName)"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;事件冒泡&lt;/title&gt;&lt;/head&gt;&lt;body onclick="alert(this.tagName)"&gt;&lt;div style="width: 300px;height: 300px;background-color:orange;" onclick="alert(this.style.backgroundColor)"&gt; &lt;div style="width: 200px;height: 200px;background-color:purple;" onclick="alert(this.style.backgroundColor)"&gt; &lt;div style="width: 100px;height: 100px;background-color:#dddddd;" onclick="alert(this.style.backgroundColor)"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 一般情况下，这个功能只会给我困扰。下面我们举个小例子： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;事件冒泡困扰例子&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 150px; background-color: orange; display: none; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oDiv = document.getElementById('div1'); oBtn.onclick = function() &#123; oDiv.style.display = 'block'; &#125; document.onclick = function() &#123; oDiv.style.display = 'none'; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" value="显示菜单" id="btn1"/&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 当我们点击按钮的时候，首先触发window.onload里面的oBtn.onclick，div就显示了，然后再执行document.onclick。这样div就又被隐藏了。 那么怎么让按钮的点击事件不冒泡呢？ 那就是取消冒泡:cancelBubble。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;事件冒泡困扰例子&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 150px; background-color: orange; display: none; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oDiv = document.getElementById('div1'); oBtn.onclick = function(ev) &#123; var oEvent = event||ev; oDiv.style.display = 'block'; oEvent.cancelBubble = true; &#125; document.onclick = function() &#123; oDiv.style.display = 'none'; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" value="显示菜单" id="btn1"/&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这样，点击按钮显示，点击其他地方消失。 用来获取事件的详细信息：鼠标位置、键盘按键##鼠标的位置 首先做个小例子：div随着鼠标移动 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;跟随鼠标的div&lt;/title&gt; &lt;style&gt; div&#123; width: 100px; height: 100px; background-color: orange; position: absolute; &#125; &lt;/style&gt; &lt;script&gt; document.onmousemove = function(ev) &#123; var oDiv = document.getElementById('div1'); var oEvent = ev||event; oDiv.style.left = oEvent.clientX + 'px';//可视区坐标 oDiv.style.top = oEvent.clientY + 'px';//可视区坐标 &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 但是这个有一个BUG，那就是如果页面可以滑动，那么鼠标和div之间就会出现一个间隙。这个原因是因为clientX和clientY是可视区坐标(可视区坐标是鼠标相对于可视区的顶部)，所以像上面这么写就会有一个差。所以正确的应该是：鼠标相对于可视区顶部的距离+可视区顶部相对于整个界面的顶部的距离（scrollTop）。 下面简单举个小例子来介绍一下如何获取scrollTop。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;scrollTop&lt;/title&gt; &lt;script&gt; document.onclick = function () &#123; //非Chrome及safari// alert(document.documentElement.scrollTop); //chrome及safari// alert(document.body.scrollTop); var oScrollTop = document.documentElement.scrollTop|| document.body.scrollTop; alert(oScrollTop); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body style="height: 2000px;"&gt;&lt;/body&gt;&lt;/html&gt; 通过这个，我们可以进一步完善我们的div跟随鼠标移动的demo 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;跟随鼠标的div&lt;/title&gt; &lt;style&gt; div&#123; width: 100px; height: 100px; background-color: orange; position: absolute; &#125; &lt;/style&gt; &lt;script&gt; document.onmousemove = function(ev) &#123; var oDiv = document.getElementById('div1'); var oEvent = ev||event; var oScrollTop = document.documentElement.scrollTop|| document.body.scrollTop; var oScrollLeft = document.documentElement.scrollLeft|| document.body.scrollLeft; oDiv.style.left = oEvent.clientX + oScrollLeft + 'px' ;//可视区坐标 oDiv.style.top = oEvent.clientY + oScrollTop + 'px';//可视区坐标 &#125; &lt;/script&gt;&lt;/head&gt;&lt;body style="height: 2000px;"&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 下面我们在举个小例子：一串儿跟随鼠标的div： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;一串儿跟随鼠标的div&lt;/title&gt; &lt;style&gt; div &#123; width: 10px; height: 10px; background-color: orange; position: absolute; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; var oDiv = document.getElementsByTagName('div'); var i = 0; document.onmousemove = function (ev) &#123; var oEvent = ev || event; for(i = oDiv.length - 1;i&gt;0;i--) &#123; oDiv[i].style.left = oDiv[i-1].style.left; oDiv[i].style.top = oDiv[i-1].style.top; &#125; oDiv[0].style.left = oEvent.clientX + "px"; oDiv[0].style.top = oEvent.clientY + "px"; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 键盘事件keyCode（键值&amp;键码)onpress = onkeydown+onkeyup这一整个完整的键盘操作； onkeydown:键盘按下去； onkeyup:键盘抬起来； 键盘上的每一个键都会对应一个数值。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;keyCode&lt;/title&gt; &lt;script&gt; document.onkeydown = function (ev) &#123; var oEvent = ev||event; alert(oEvent.keyCode); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 接下来你每按一个键就会弹出该键对应的竖直。 下面我们做一个用键盘控制div移动方向的例子 知识补充 offsetWidth系列123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background-color: orange; border: 1px solid blue; padding: 10px; margin: 20px; position: absolute; left: 120px; top: 120px; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; var oDiv = document.getElementById('div1'); alert("offsetWidth" + oDiv.offsetWidth);//包含width+border+padding alert("offsetLeft" + oDiv.offsetLeft);//包含左边的margin + left &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 下面我们可以做例子了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;键盘控制div&lt;/title&gt; &lt;style&gt; div &#123; width: 100px; height: 100px; background-color: orange; position: absolute; &#125; &lt;/style&gt; &lt;script&gt; document.onkeydown = function (ev) &#123; var oEvent = ev||event; var oDiv = document.getElementById('div1'); //⬅️ 37 //⤴️ 38 //➡️ 39 //⬇️ 40// alert(oEvent.keyCode); if(oEvent.keyCode == 37)&#123; oDiv.style.left = oDiv.offsetLeft - 10 + "px"; &#125;else if(oEvent.keyCode == 39) &#123; oDiv.style.left = oDiv.offsetLeft + 10 + "px"; &#125; else if(oEvent.keyCode == 38) &#123; oDiv.style.top = oDiv.offsetTop - 10 + "px"; &#125; else if(oEvent.keyCode == 40) &#123; oDiv.style.top = oDiv.offsetTop + 10 + "px"; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 接下来，div就可以通过键盘来上下左右移动了。 其他属性 ctrlKey shiftKey altKey:有特殊用途，建议不要用。一般是呼叫系统菜单的，是个系统键。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Ctrl+return提交留言&lt;/title&gt; &lt;script&gt; window.onload = function () &#123; var oBtn = document.getElementById('btn1'); var oTxt1 = document.getElementById('txt1'); var oTxt2 = document.getElementById('txt2'); //点击按钮发送 oBtn.onclick = function () &#123; oTxt1.value += oTxt2.value + '\n'; oTxt2.value = ""; &#125; //按下return键发送 oTxt2.onkeydown = function (ev) &#123; var oEvent = ev||event; if(oEvent.keyCode == 13&amp;&amp; oEvent.ctrlKey) &#123; //Ctrl+return提交留言 oTxt1.value += oTxt2.value + "\n"; oTxt2.value = ""; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;textarea name="留言框" id="txt1" cols="30" rows="10"&gt;&lt;/textarea&gt;&lt;input type="text" id="txt2" value="留言输入框" /&gt;&lt;input type="button" id="btn1" value="提交"/&gt;&lt;/body&gt;&lt;/html&gt; 这就是模拟留言板的方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BOM基础学习]]></title>
      <url>%2F2017%2F03%2F09%2FBOM%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[BOM基础知识点 知识点源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;BOM基础&lt;/title&gt; &lt;style&gt; div &#123; border: 1px solid purple; &#125; dl &#123; border: 1px solid purple; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;BOM基础 &lt;dl&gt;打开、关闭窗口 &lt;dt&gt;open&lt;/dt&gt; &lt;dd&gt;- 蓝色理想运行代码功能&lt;/dd&gt; &lt;dt&gt;close&lt;/dt&gt; &lt;dd&gt;- 关闭时提示问题&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt;常用属性 &lt;dt&gt;window.navigator.userAgent&lt;/dt&gt; &lt;dt&gt;window.location&lt;/dt&gt; &lt;/dl&gt;&lt;/div&gt;&lt;div&gt;尺寸及坐标 &lt;dl&gt;窗口尺寸、工作区尺寸 &lt;dt&gt;可视区尺寸&lt;/dt&gt; &lt;dd&gt;- document.documentElement.clientWidth&lt;/dd&gt; &lt;dd&gt;- document.documentElement.clientHeight&lt;/dd&gt; &lt;dt&gt;滚动距离&lt;/dt&gt; &lt;dd&gt;- document.body.scrollTop&lt;/dd&gt; &lt;dd&gt;- document.documentElement.scrollTop&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt;&lt;div&gt;常用方法和事件 &lt;dl&gt;系统对话框 &lt;dt&gt;警告框：alert(“内容”)，没有返回值&lt;/dt&gt; &lt;dt&gt;选择框：confirm(“提问的内容”)，返回boolean&lt;/dt&gt; &lt;dt&gt;输入框：prompt()，返回字符串或null&lt;/dt&gt; &lt;/dl&gt; &lt;dl&gt;window对象常用事件 &lt;dt&gt;onload&lt;/dt&gt; &lt;dt&gt;onscroll&lt;/dt&gt; &lt;dt&gt;onresize&lt;/dt&gt; &lt;dt&gt;例子：回到顶部按钮、侧边栏广告&lt;/dt&gt; &lt;dt&gt;- 闪烁问题&lt;/dt&gt; &lt;/dl&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 打开窗口window.open(&quot;链接&quot;,&quot;窗口的打开形式target&quot;):打开窗口。 窗口的打开形式： _self:在本窗口中打开_blank:在新窗口打开（默认）_parent:在父框架集中打开被链接文档_top:在整个窗口中打开被链接文档（默认） 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;open&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); oBtn.onclick = function() &#123; window.open("http://www.baidu.com"); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" id="btn1" value="打开窗口"/&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 下面用它做个小应用：首先学点小知识： document.write它的作用是清空当前界面并输出东西 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var obtn = document.getElementById('btn1'); obtn.onclick = function() &#123; document.write("Feyddy"); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" id="btn1" value="write"/&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 点击按钮后 好了，学会了这个我们继续来实现我们想要的应用。 需求： 我们创建一个文本输入框，然后再创建一个按钮。当我们点击按钮的时候将文本中的文字执行到新的窗口中。 先进行一些小的知识点的补充： document.getElementById(&#39;btn1&#39;);与window.document.getElementById(&#39;btn1&#39;);是一样的，只不过window一般都省略了。 window.open()是有返回值的,如果使用var newWindow = window.open(&quot;about:blank&quot;);返回的就是新创建的一个窗口。 通过newWindow.document.write(&quot;显示的文字&quot;);就可以在新的窗口中显示文字。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;运行代码&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oTxt = window.document.getElementById('txt1'); var oBtn = window.document.getElementById('btn1'); oBtn.onclick = function() &#123; //about:blank var newWindow = window.open("about:blank"); newWindow.document.write(oTxt.value); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;textarea name="" id="txt1" cols="30" rows="10"&gt;&lt;/textarea&gt;&lt;input type="button" id="btn1" value="运行代码"/&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 点击运行代码按钮： 关闭窗口close 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;close&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); oBtn.onclick = function() &#123; window.close(); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" id="btn1" value="关闭窗口"/&gt;&lt;/body&gt;&lt;/html&gt; 关于这个关闭，不同的浏览器有不同的处理方式： IE:会弹出一个提示框，询问是否关闭； Chrome:直接关闭； FF:不会操作，因为他是我们直接打开的，不是通过js脚本另外打开的，所以需要我们先open，才能close； 如果我们不需要提示，想让所有的浏览器都直接关掉： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;open-close&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); oBtn.onclick = function() &#123; window.open("close.html","_blank"); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" id="btn1" value="打开窗口"/&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 然后点击打开 再关闭就和刚运行的结果一样了。 window上的常用属性window.navigator.userAgent告诉我们当前浏览器用的版本是什么。（配合正则使用） window.location告诉我们当前页面的地址。 不仅可以读取地址，也可以赋值给它；这样他就直接加载赋值给他的地址。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;window.navigator.userAgent和window.location&lt;/title&gt; &lt;script&gt; window.location = "http://www.feyddy.com";//我的博客 &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 窗口尺寸可视区尺寸1234alert(document.documentElement.clientHeight);//可视窗口 的高度alert(document.body.clientHeight);//body标签的高度alert(document.documentElement.clientWidth);//可视窗口 的宽度alert(document.body.clientWidth);//body标签的宽度 滚动距离12alert(document.documentElement.scrollTop);//FF下可视区距离顶部的距离alert( document.body.scrollTop);//IE下可视区距离顶部的距离 系统对话框警告框 :alert(内容)，没有返回值123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;alert&lt;/title&gt; &lt;script&gt; alert('我是警告框。我没有返回值'); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 选择框 :confirm(内容)，有返回值，可以根据返回值来执行不同的操作12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;confirm&lt;/title&gt; &lt;script&gt; var b = confirm('今天下雨吗？');//如果点击的确定，就是true,反之就是false alert(b); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 点击确定 点击取消 输入框 : prompt12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;prompt&lt;/title&gt; &lt;script&gt; var yourName = prompt('请输入你的姓名','Feyddy');//后一个参数为默认值.如果点击确定，那么返回值就是你写的东西，如果没有写那就是空字符串。如果点击取消返回的就是null alert(yourName); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 点击取消 点击确定 如果输入框里面没有写任何东西，然后点击确定： window对象常用事件onload: 页面刚加载的时候onscroll: 页面滚动的时候onresize: 页面缩放的时候例子：回到顶部按钮、侧边栏广告 侧边栏广告：页面怎么滚都不动，都显示在可见区域的固定位置。 下面我们先画张图： 这下就好办了。 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;侧边栏&lt;/title&gt; &lt;style&gt; #div1 &#123; width: 100px; height: 100px; background-color: red; position: absolute; right: 0; &#125; &lt;/style&gt; &lt;script&gt; window.onresize = window.onload = window.onscroll = function () &#123; var oDiv = document.getElementById('div1'); //可视区顶部到顶部的高度 var scrollTop = document.documentElement.scrollTop||document.body.scrollTop; //div到可视区顶部的高度=(可视区的高度-div本身的高)/2 var t = (document.documentElement.clientHeight - oDiv.offsetHeight)/2; oDiv.style.top = scrollTop + t + "px"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body style="height: 2000px;"&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 闪烁问题 法一：完全通过布局的方式定位。position: fixed;（但是在IE6下不支持） 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;侧边栏&lt;/title&gt; &lt;style&gt; #div1 &#123; width: 100px; height: 100px; background-color: red; position: fixed; right: 0; top: 50%; margin-top: -50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body style="height: 2000px;"&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 法二：运动解决 这个是运动的一个框架： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function getStyle(obj, attr)&#123; if(obj.currentStyle) &#123; return obj.currentStyle[attr]; &#125; else &#123; return getComputedStyle(obj, false)[attr]; &#125;&#125;function startMove(obj, json, fn)&#123; clearInterval(obj.timer); obj.timer=setInterval(function ()&#123; var bStop=true; for(var attr in json) &#123; //1. var iCur=0; if(attr=='opacity') &#123; iCur=parseInt(parseFloat(getStyle(obj, attr))*100); &#125; else &#123; iCur=parseInt(getStyle(obj, attr)); &#125; //2. var iSpeed=(json[attr]-iCur)/8; iSpeed=iSpeed&gt;0?Math.ceil(iSpeed):Math.floor(iSpeed); //3. if(iCur!=json[attr]) &#123; bStop=false; &#125; if(attr=='opacity') &#123; obj.style.filter='alpha(opacity:'+(iCur+iSpeed)+')'; obj.style.opacity=(iCur+iSpeed)/100; &#125; else &#123; obj.style[attr]=iCur+iSpeed+'px'; &#125; &#125; if(bStop) &#123; clearInterval(obj.timer); if(fn) &#123; fn(); &#125; &#125; &#125;, 30)&#125; 将它引入到我们的代码中： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;侧边栏&lt;/title&gt; &lt;script src="move.js"&gt;&lt;/script&gt; &lt;style&gt; #div1 &#123; width: 100px; height: 100px; background-color: red; position: absolute; right: 0; top: 0; &#125; &lt;/style&gt; &lt;script&gt; window.onresize = window.onload = window.onscroll = function () &#123; var oDiv = document.getElementById('div1'); //可视区顶部到顶部的高度 var scrollTop = document.documentElement.scrollTop||document.body.scrollTop; //div到可视区顶部的高度=(可视区的高度-div本身的高)/2 var t = (document.documentElement.clientHeight - oDiv.offsetHeight)/2; startMove(oDiv, &#123;top: scrollTop+t&#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body style="height: 2000px;"&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 回到顶部按钮 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;回到顶部&lt;/title&gt; &lt;style&gt; #btn1 &#123; position: fixed; bottom: 0; right: 0; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var Obtn = document.getElementById('btn1'); var bSys = true;//检测是不是系统也就是定时器代码让他滚动的。 var timer = null; //如何检测用户拖动滚动条,但是他没办法区分是用户自己滚动的，还是定时器代码设置滚动的。 window.onscroll = function() &#123; if(!bSys)&#123; clearInterval(timer); &#125; bSys = false; &#125; Obtn.onclick = function() &#123; //创建一个定时器 timer = setInterval(function () &#123; var scrollTop = document.documentElement.scrollTop||document.body.scrollTop; ///速度 var iSpeed = Math.floor(-scrollTop/8);//向下取整 //如果置顶，消除定时器 if(scrollTop == 0) &#123; clearInterval(timer); &#125; bSys=false; //赋值:为了兼容两者都写 document.body.scrollTop = document.documentElement.scrollTop = scrollTop+iSpeed; &#125;,30); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" id="btn1" value="回到顶部"/&gt;&lt;ul&gt; &lt;li&gt;我是li1&lt;/li&gt; &lt;li&gt;我是li2&lt;/li&gt; &lt;li&gt;我是li3&lt;/li&gt; &lt;li&gt;我是li4&lt;/li&gt; &lt;li&gt;我是li5&lt;/li&gt; &lt;li&gt;我是li6&lt;/li&gt; &lt;li&gt;我是li7&lt;/li&gt; &lt;li&gt;我是li8&lt;/li&gt; &lt;li&gt;我是li9&lt;/li&gt; &lt;li&gt;我是li10&lt;/li&gt; &lt;li&gt;我是li11&lt;/li&gt; &lt;li&gt;我是li12&lt;/li&gt; &lt;li&gt;我是li13&lt;/li&gt; &lt;li&gt;我是li14&lt;/li&gt; &lt;li&gt;我是li15&lt;/li&gt; &lt;li&gt;我是li16&lt;/li&gt; &lt;li&gt;我是li17&lt;/li&gt; &lt;li&gt;我是li18&lt;/li&gt; &lt;li&gt;我是li19&lt;/li&gt; &lt;li&gt;我是li20&lt;/li&gt; &lt;li&gt;我是li21&lt;/li&gt; &lt;li&gt;我是li22&lt;/li&gt; &lt;li&gt;我是li23&lt;/li&gt; &lt;li&gt;我是li24&lt;/li&gt; &lt;li&gt;我是li25&lt;/li&gt; &lt;li&gt;我是li26&lt;/li&gt; &lt;li&gt;我是li27&lt;/li&gt; &lt;li&gt;我是li28&lt;/li&gt; &lt;li&gt;我是li29&lt;/li&gt; &lt;li&gt;我是li30&lt;/li&gt; &lt;li&gt;我是li31&lt;/li&gt; &lt;li&gt;我是li32&lt;/li&gt; &lt;li&gt;我是li33&lt;/li&gt; &lt;li&gt;我是li34&lt;/li&gt; &lt;li&gt;我是li35&lt;/li&gt; &lt;li&gt;我是li36&lt;/li&gt; &lt;li&gt;我是li37&lt;/li&gt; &lt;li&gt;我是li38&lt;/li&gt; &lt;li&gt;我是li39&lt;/li&gt; &lt;li&gt;我是li40&lt;/li&gt; &lt;li&gt;我是li41&lt;/li&gt; &lt;li&gt;我是li42&lt;/li&gt; &lt;li&gt;我是li43&lt;/li&gt; &lt;li&gt;我是li44&lt;/li&gt; &lt;li&gt;我是li45&lt;/li&gt; &lt;li&gt;我是li46&lt;/li&gt; &lt;li&gt;我是li47&lt;/li&gt; &lt;li&gt;我是li48&lt;/li&gt; &lt;li&gt;我是li49&lt;/li&gt; &lt;li&gt;我是li50&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM基础学习]]></title>
      <url>%2F2017%2F03%2F08%2FDOM%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[DOM基础知识点 知识点源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;DOM基础&lt;/title&gt; &lt;style&gt; div &#123; border: 1px solid purple; &#125; dl &#123; border: 1px solid purple; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;DOM基础 &lt;dl&gt;DOM基础 &lt;dt&gt;什么是DOM&lt;/dt&gt; &lt;dt&gt;浏览器支持情况&lt;/dt&gt; &lt;/dl&gt; &lt;dl&gt;DOM节点 &lt;dt&gt;childNodes nodeType&lt;/dt&gt; &lt;dd&gt;- 获取子节点&lt;/dd&gt; &lt;dd&gt;- children&lt;/dd&gt; &lt;dt&gt;parentNode&lt;/dt&gt; &lt;dd&gt;- 例子：点击链接，隐藏整个li&lt;/dd&gt; &lt;dt&gt;offsetParent&lt;/dt&gt; &lt;dd&gt;- 例子：获取元素在页面上的实际位置&lt;/dd&gt; &lt;dt&gt;首尾子节点&lt;/dt&gt; &lt;dd&gt;- 有兼容性问题&lt;/dd&gt; &lt;dd&gt;- firstChild、firstElementChild&lt;/dd&gt; &lt;dd&gt;- lastChild 、lastElementChild&lt;/dd&gt; &lt;dt&gt;兄弟节点&lt;/dt&gt; &lt;dd&gt;- 有兼容性问题&lt;/dd&gt; &lt;dd&gt;- nextSibling、nextElementSibling&lt;/dd&gt; &lt;dd&gt;- previousSibling、previousElementSibling&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt;&lt;div&gt;操纵元素属性 &lt;dl&gt;元素属性操作 &lt;dt&gt;第一种：oDiv.style.display=“block”;&lt;/dt&gt; &lt;dt&gt;第二种：oDiv.style[“display”]=“block”;&lt;/dt&gt; &lt;dt&gt;第三种：Dom方式&lt;/dt&gt; &lt;/dl&gt; &lt;dl&gt;DOM方式操作元素属性 &lt;dt&gt;获取：getAttribute(名称)&lt;/dt&gt; &lt;dt&gt;设置：setAttribute(名称, 值)&lt;/dt&gt; &lt;dt&gt;删除：removeAttribute(名称)&lt;/dt&gt; &lt;/dl&gt;&lt;/div&gt;&lt;div&gt;DOM元素灵活查找 &lt;dl&gt;用className选择元素 &lt;dt&gt;如何用className选择元素&lt;/dt&gt; &lt;dd&gt;- 选出所有元素&lt;/dd&gt; &lt;dd&gt;- 通过className条件筛选&lt;/dd&gt; &lt;dt&gt;封装成函数&lt;/dt&gt; &lt;/dl&gt;&lt;/div&gt;&lt;div&gt;创建、插入和删除元素 &lt;dl&gt;创建DOM元素 &lt;dt&gt;createElement(标签名) 创建一个节点&lt;/dt&gt; &lt;dt&gt;appendChild(节点) 追加一个节点&lt;/dt&gt; &lt;dd&gt;- 例子：为ul插入li&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt;插入元素 &lt;dt&gt;insertBefore(节点, 原有节点) 在已有元素前插入&lt;/dt&gt; &lt;dd&gt;- 例子：倒序插入li&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt;删除DOM元素 &lt;dt&gt;removeChild(节点) 删除一个节点&lt;/dt&gt; &lt;dd&gt;- 例子：删除li&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt;&lt;div&gt;文档碎片 &lt;dl&gt;文档碎片 &lt;dt&gt;文档碎片可以提高DOM操作性能(理论上)&lt;/dt&gt; &lt;dt&gt;文档碎片原理&lt;/dt&gt; &lt;dt&gt;document.createDocumentFragment()&lt;/dt&gt; &lt;/dl&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; DOM简介DOM的作用是可以帮助JS操作浏览器页面里的那些元素，各种各样的操作都是通过DOM来完成的，例如：改变背景颜色，字体大小等。DOM不仅仅是JS的一个组件，它还是一套标准。它有两个标准:DOM1和DOM2。而火狐基本上完全实现了两个标准。而IE是最不标准的，DOM1实现了一点，DOM2完全没实现。其他的类似于Chrome和Safari,DOM1实现了大班，DOM2实现了一点。 DOM节点HTML标签也叫做节点。下面我们举个例子： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;DOM节点&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;&lt;a href=""&gt;111&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;222&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;333&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 根据上面的例子，我们进行讲解; 父节点：一个标签的父节点永远只会有一个；例如：li的父节点就是ul；子节点：一个标签的子节点只有一层；例如：ul的子节点就是li，a不是ul的子节点； 获取节点的方法childNodes子节点1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;DOM节点&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oUl = document.getElementById("ul1"); alert(oUl.childNodes.length); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id="ul1"&gt; &lt;li&gt;&lt;a href=""&gt;111&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;222&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;333&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 如果在IE浏览器中打开，就睡显示3。但是在chrome下打开却是： 但是如果你把代码改成这样： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;DOM节点&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oUl = document.getElementById("ul1"); alert(oUl.childNodes.length); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id="ul1"&gt;&lt;li&gt;&lt;a href=""&gt;111&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=""&gt;222&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=""&gt;333&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 运行结果就会是正常的： 这是为什么呢？ 原因是因为有一个文本节点。像这种节点属于元素节点，文本节点就是只是一个文字显示。在火狐和Chrome中会自动把文本节点也算是一个节点，但是在IE中就不算。 这样就出现兼容性问题了。 nodeType可以解决这个问题。 nodeType类型解释： 3:代表文本节点 1:代表元素节点（标签） 这样解决方法就出来了。 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;DOM节点&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oUl = document.getElementById("ul1"); var i; for(i=0; i&lt; oUl.childNodes.length;i++)&#123; //在IE下改变了，但是在Chrome下却没有出现，而且报错。因为不能给文本添加样式。// oUl.childNodes[i].style.backgroundColor='red'; if(oUl.childNodes[i].nodeType == 1)&#123; oUl.childNodes[i].style.backgroundColor='red'; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id="ul1"&gt; &lt;li&gt;&lt;a href=""&gt;111&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;222&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;333&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 还有一种方法就是使用children。大家可以认为他是兼容版的childNodes。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;children&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oUl = document.getElementById("ul1"); var i; for(i=0; i&lt; oUl.children.length;i++)&#123; oUl.children[i].style.background = "orange"; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id="ul1"&gt; &lt;li&gt;&lt;a href=""&gt;111&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;222&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;333&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： parentNode父节点它获取的是结构上的父节点。 我们下面来通过一个小例子来理解这个parentNode。 需求：点击链接隐藏当前行。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var aA = document.getElementsByTagName("a"); var i; for(i=0; i&lt; aA.length;i++)&#123; aA[i].onclick = function () &#123; //这里的this是a，a的父节点就是我们需要隐藏的li this.parentNode.style.display = "none"; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;点击链接隐藏当前行（li）&lt;ul id="ul1"&gt; &lt;li&gt;first&lt;a href="javascript:;"&gt;隐藏&lt;/a&gt;&lt;/li&gt; &lt;li&gt;second&lt;a href="javascript:;"&gt;隐藏&lt;/a&gt;&lt;/li&gt; &lt;li&gt;third&lt;a href="javascript:;"&gt;隐藏&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果： 点击隐藏后： offsetParent它获取的是物体相对于某个的定位。 下面通过举例说明： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;offsetParent&lt;/title&gt; &lt;style&gt; #div1 &#123; width: 100px; height: 100px; background-color:red; &#125; #div2 &#123; width: 100px; height: 100px; background-color:orange; position: absolute; left: 100px; top: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt; &lt;div id="div2"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 此时如果我们为div1添加一个margin: 50px;的样式后，橙色的div2完全没有移动。 但是如果为div1添加一个position: relative;之后，橙色的div2就会随着div1移动而移动。 为什么呢？ 这是因为，一开始div2不是相对于div1在定位的，而绝对定位是相对于有定位的父级来定位的，所以给div1加上了相对定位：position: relative;之后，div1就可以跟着div1移动了。换句话说，用来定位的那个父级不一定是结构上的父级。 下面我们弹出div2的offsetParent.id 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;offsetParent&lt;/title&gt; &lt;style&gt; #div1 &#123; width: 100px; height: 100px; background-color:red; margin: 50px; position: relative; &#125; #div2 &#123; width: 100px; height: 100px; background-color:orange; position: absolute; left: 100px; top: 100px; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var oDiv2= document.getElementById("div2"); oDiv2.onclick = function() &#123; alert(this.offsetParent.id); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt; &lt;div id="div2"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 可以知道div2的offsetParent是div1。 但是如果我们去除div1的定位的话,他就会不断地向上找。 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;offsetParent&lt;/title&gt; &lt;style&gt; #div1 &#123; width: 100px; height: 100px; background-color:red; margin: 50px; /*position: relative;*/ &#125; #div2 &#123; width: 100px; height: 100px; background-color:orange; position: absolute; left: 100px; top: 100px; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var oDiv2= document.getElementById("div2"); oDiv2.onclick = function() &#123; alert(this.offsetParent.id); alert(this.offsetParent.tagName); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt; &lt;div id="div2"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 可以看出来，此时的div2的offsetParent是body标签。 所以offsetParent是找出有定位的父级。 首尾子节点firstChild和firstElementChild获取第一个子元素。 firstChild一样也是存在兼容性问题，只有在IE下可以用。在火狐下可以使用firstElementChild。 举个小例子： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;firstChild&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oUl= document.getElementById("ul1"); //IE// oUl.firstChild.style.backgroundColor = "red"; //FF oUl.firstElementChild.style.backgroundColor = "orange"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id="ul1"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 那怎么处理这个兼容性问题呢？？ 可以通过一个中间变量。具体操作如下; 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;firstChild&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oUl= document.getElementById("ul1"); var oFirst=oUl.firstElementChild||oUl.firstChild; oFirst.style.backgroundColor = "orange"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id="ul1"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 这样就没问题了。 注意这里有一个小细节问题，oUl.firstElementChild||oUl.firstChild必须将firstElementChild写在前面，否则会出错。 lastChild和lastElementChild方法和注意点同上。 兄弟节点previousSibling和previousElementSibling上一个兄弟节点。 previousSibling只能IE使用previousElementSibling只能FF使用 方法和注意点和上面的差不多。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Sibling&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oli= document.getElementById("li2"); //IE// oli.previousSibling.style.backgroundColor = "red"; //FF oli.previousElementSibling.style.backgroundColor = "orange"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id="ul1"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li id="li2"&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 运行结果: 解决方法也和上面一样 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Sibling&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oli= document.getElementById("li2"); var oPrevious = oli.previousElementSibling||oli.previousSibling; oPrevious.style.backgroundColor = "orange"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id="ul1"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li id="li2"&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 注意：var oPrevious = oli.previousElementSibling||oli.previousSibling;中的previousElementSibling一定要写在前面，否则不管用。 nextSibling和nextElementSibling方法与注意点同上。 操纵元素属性元素属性操作有三种方式可以操作元素的属性： 采用.语法； 采用[]语法。他和.语法一样，但是唯一区别就是，[]里面的属性可以变的。相当于传一个参数; 采用DOM方式；用setAttribute(&#39;属性&#39;,&#39;值&#39;)（设置属性值）和getAttribute(&#39;属性&#39;)（获取属性值）以及removeAttribute(&#39;属性&#39;)（删除属性值）。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;DOM方式操作元素属性&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oTxt = document.getElementById('txt1');// //1.采用.语法// oTxt.value = '123';//// //2.采用[]方式,他和.语法一样，但是唯一区别就是，[]里面的属性可以变的。相当于传一个参数// oTxt['value']='123'; //3.DOM方式 oTxt.setAttribute('value','123'); alert(oTxt.getAttribute('value')); oTxt.removeAttribute('value'); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text" id="txt1"/&gt;&lt;/body&gt;&lt;/html&gt; DOM元素灵活查找className选择元素123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;用Class选元素&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oUl = document.getElementById('ul1'); var aLi = document.getElementsByTagName('li'); var i=0; for(i=0;i&lt;aLi.length;i++)&#123; if(aLi[i].className=='box')&#123; aLi[i].style.backgroundColor="red"; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id="ul1"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li class="box"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li class="box"&gt;&lt;/li&gt; &lt;li class="box"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 这个方法完全可以使用了，但是这样实在太麻烦了。下面我们将这个方法封装成一个函数。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;用Class选元素&lt;/title&gt; &lt;script&gt; function getByClass(oParent,sClass)&#123;//(父级，子级的class) var aEle = oParent.getElementsByName('*');//‘*’代表所有的标签元素 var aResult=[];//存放sClass的所有元素。 var i=0; for(i=0;i&lt;aEle.length;i++)&#123; if(aEle[i].className==sClass)&#123; aResult.push(aEle[i]); &#125; &#125; &#125; window.onload = function() &#123; var oUl = document.getElementById('ul1'); var aLi = getByClass(oUl,'box'); var i=0; for(i=0;i&lt;aLi.length;i++)&#123; aLi[i].style.backgroundColor = "red"; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id="ul1"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li class="box"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li class="box"&gt;&lt;/li&gt; &lt;li class="box"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 创建一个DOM元素createElement(元素名)创建一个元素。appendChild(子节点)将创建的子节点添加到调用这个方法的父节点里面。innerHTML元素的内容 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;创建DOM元素li&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oTxt = document.getElementById('txt1'); var oUl = document.getElementById('ul1'); oBtn.onclick = function() &#123; var newlI = document.createElement('li');//创建一个li标签 newlI.innerHTML = oTxt.value;//innerHTML是向li里面添加内容 //父.appendChild(子节点) oUl.appendChild(newlI); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text" id="txt1"/&gt;&lt;input type="button" value="创建li" id="btn1"/&gt;&lt;ul id="ul1"&gt; &lt;li&gt;aaa&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 上述代码中，newlI.innerHTML = oTxt.value;和oUl.appendChild(newlI);添加的先后顺序，有一丁点区别。如果先赋值，再添加新标签，那么页面只会渲染一遍；如果先添加新标签，再赋值就会渲染两遍。 插入一个子节点父节点.inserBefore(子节点，谁之前)。注意：使用insertBefore的时候一定要先判断是否一开始就有一个标签 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;insertBefore&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oTxt = document.getElementById('txt1'); var oUl = document.getElementById('ul1'); var aLi = oUl.getElementsByTagName('li'); oBtn.onclick = function() &#123; var newlI = document.createElement('li');//创建一个li标签 newlI.innerHTML = oTxt.value;//innerHTML是向li里面添加内容 //判断是否一开始就有一个li if(aLi.length == 0) &#123; oUl.appendChild(newlI); &#125;else &#123; oUl.insertBefore(newlI,aLi[0]); &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text" id="txt1"/&gt;&lt;input type="button" value="创建li" id="btn1"/&gt;&lt;ul id="ul1"&gt; &lt;li&gt;aaa&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 删除DOM元素父节点.removeChild(子节点)。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;removeChild&lt;/title&gt; &lt;script&gt; window.onload = function () &#123; var oA = document.getElementsByTagName('a'); var oUL = document.getElementById('ul1'); var i=0; for(i = 0; i &lt; oA.length;i++)&#123; oA[i].onclick = function()&#123; oUL.removeChild(this.parentNode); &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id="ul1"&gt; &lt;li&gt;feyddy&lt;a href="javascript:;"&gt;删除&lt;/a&gt;&lt;/li&gt; &lt;li&gt;xuzhonglin&lt;a href="javascript:;"&gt;删除&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 文档碎片createDocumentFragment() 就拿创建li来解释：如果我们需要创建10000个li的话，普通的循环创建是创建一个添加一个，页面就渲染一个，这样就需要10000次。但是文档碎片就是将创建的1000个li先保存在文档碎片里面，然后最后一次性添加和渲染，只需要一遍。（当然这只是理论上的，实际应用怎么样？也许不尽如人意。） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;文档碎片&lt;/title&gt; &lt;script&gt; window.onload = function () &#123; var oBtn1 = document.getElementById('btn1'); var oBtn2 = document.getElementById('btn2'); var oUL = document.getElementById('ul1'); oBtn1.onclick = function() &#123; var startTime = new Date().getTime();//时间戳 var i = 0; for(i = 0;i &lt; 10000; i++)&#123; var oli = document.createElement('li'); oUL.appendChild(oli); &#125; var finishTime = new Date().getTime(); var differ = finishTime - startTime; alert("普通创建li"+'时间差'+differ+'毫秒'); &#125; oBtn2.onclick = function() &#123; var startTime = new Date().getTime();//时间戳 var oFrag = document.createDocumentFragment();//创建文档碎片对象 var i = 0; for(i = 0;i &lt; 10000; i++)&#123; var oli = document.createElement('li'); oFrag.appendChild(oli);//添加到文档碎片 &#125; oUL.appendChild(oFrag);//将文档碎片添加到oUL中 var finishTime = new Date().getTime(); var differ = finishTime - startTime; alert("碎片创建li"+'时间差'+differ+'毫秒'); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" value="普通创建li" id="btn1"/&gt;&lt;input type="button" value="碎片创建li" id="btn2"/&gt;&lt;ul id="ul1"&gt; &lt;li&gt;aaa&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 从图中可以看出来用了碎片反而变慢了。。。。。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript基础学习（二）]]></title>
      <url>%2F2017%2F03%2F07%2FJavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[JavaScript基础知识点（二）本文主要学习函数和数组两个。知识点见下图： 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;js-基础3&lt;/title&gt; &lt;style&gt; div &#123; border: 1px solid purple; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;函数返回值 &lt;dl&gt;1、函数返回值 &lt;dt&gt;什么是函数返回值&lt;/dt&gt; &lt;dd&gt;- 函数的执行结果&lt;/dd&gt; &lt;dd&gt;- 可以没有return&lt;/dd&gt; &lt;dt&gt;一个函数应该只返回一种类型的值&lt;/dt&gt; &lt;/dl&gt;&lt;/div&gt;&lt;div&gt;函数传参 &lt;dl&gt;1、可变参（不定参）：arguments &lt;dt&gt;参数的个数可变，参数数组&lt;/dt&gt; &lt;/dl&gt; &lt;dl&gt;2、例子1：求和 &lt;dt&gt;求所有参数的和&lt;/dt&gt; &lt;/dl&gt; &lt;dl&gt;3、例子2：CSS函数 &lt;dt&gt;判断arguments.length&lt;/dt&gt; &lt;dt&gt;给参数取名，增强可读性&lt;/dt&gt; &lt;dt&gt;取非行间样式（不能用来设置）：&lt;/dt&gt; &lt;dd&gt;- objc.currentStyle[attr]&lt;/dd&gt; &lt;dd&gt;- getComputedStyle(obj,false)[attr]&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt;&lt;div&gt;数组基础 &lt;dl&gt;1、数组的使用 &lt;dt&gt;定义&lt;/dt&gt; &lt;dd&gt;- var arr = [12,23];&lt;/dd&gt; &lt;dd&gt;- var arr = new Array(12,23,45);&lt;/dd&gt; &lt;dd&gt;- 没有任何差别，[]的性能略高，因为代码短&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt;2、数组的属性 &lt;dt&gt;length&lt;/dt&gt; &lt;dd&gt;- 既可以获取，又可以设置&lt;/dd&gt; &lt;dd&gt;- 例子：快速清空数组&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt;3、数组使用原则：数组中应该只存放一种类型的变量 &lt;/dl&gt; &lt;dl&gt;4、数组的方法 &lt;dt&gt;添加&lt;/dt&gt; &lt;dd&gt;- push（元素），从尾部添加&lt;/dd&gt; &lt;dd&gt;- unshift（元素），从头部添加&lt;/dd&gt; &lt;dt&gt;删除&lt;/dt&gt; &lt;dd&gt;- pop（），从尾部删除&lt;/dd&gt; &lt;dd&gt;- shift（），从头部删除&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt;5、数组的排序 &lt;dt&gt;sort（[比较函数]），排序一个数组 &lt;/dt&gt; &lt;dd&gt;- 排序一个字符串数组&lt;/dd&gt; &lt;dd&gt;- 排序一个数字数组&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt;6、转换类 &lt;dt&gt;concat（数组2） &lt;/dt&gt; &lt;dd&gt;- 连接两个数组&lt;/dd&gt; &lt;dt&gt;join（分隔符）&lt;/dt&gt; &lt;dd&gt;- 用分隔符，组合数组元素，生成字符串&lt;/dd&gt; &lt;dd&gt;字符串split&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt;7、插入、删除 &lt;dt&gt;splice &lt;/dt&gt; &lt;dd&gt;splice（开始，长度，元素...）&lt;/dd&gt; &lt;dd&gt;先删除，后插入&lt;/dd&gt; &lt;dt&gt;删除&lt;/dt&gt; &lt;dd&gt;splice（开始，长度）&lt;/dd&gt; &lt;dt&gt;插入&lt;/dt&gt; &lt;dd&gt;splice（开始，0，元素...）&lt;/dd&gt; &lt;dt&gt;替换&lt;/dt&gt; &lt;/dl&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; #函数 函数返回值123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;函数返回值&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; function sum(a,b) &#123; return a+b; &#125; alert(sum(6,12)); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 函数返回值就是通过return将一个函数里面的东西传至外面。上面例子中如果没有返回值或者说返回一个空return ;，这样就会undefined。 arguments它其实就是函数里面的参数数组。下面举个小例子： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;arguments&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; function show() &#123; alert(arguments.length); alert(arguments[0]); alert(arguments[1]); &#125; show(12,5); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果; 这样我们就很清楚的明白arguments的意思了。 举个arguments的小应用:求和函数。arguments,也叫可变参（不定参），意思就是他可以随着传入参数个数的变化而变化。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;求和函数&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; function sum() &#123; var sum = 0; for(i = 0;i&lt;arguments.length;i++)&#123; sum += arguments[i]; &#125; return sum; &#125; alert(sum(12,5,23)); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： CSS函数例子1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;CSS函数&lt;/title&gt; &lt;style&gt; #div1 &#123; width: 200px; height: 20px; background-color: red; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oDiv = document.getElementById('div1'); oBtn.onclick = function() &#123; css(oDiv,'backgroundColor','green'); alert(css(oDiv,'width')); &#125; function css() &#123; if(arguments.length == 2) &#123;//获取 return arguments[0].style[arguments[1]]; &#125;else if(arguments.length == 3) &#123;//设置 arguments[0].style[arguments[1]] = arguments[2]; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" id="btn1" value="样式"/&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 从上面的第二附图中可以看出，并没有获取到div的宽度属性。这就是style的问题，因为这个style只能获取到行间样式，不能获取到在style标签里面设置的样式。 如何取非行间的样式–currentStyle（获取计算后的样式），如果对于同一个标签有多个样式设置，他会显示优先级最高的那个样式。但是兼容性有问题，只能在IE下使用。 在火狐下可以使用getComputedStyle(oDiv,false).width;但是在IE又不可以使用。 那么怎么解决这两个兼容性问题呢？ 我们可以发现在IE下的oDiv.currentStyle是个对象，但是在火狐下是个undefined。于是解决兼容性方法就出现了。利用if判断 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;CSS函数&lt;/title&gt; &lt;style&gt; #div1 &#123; width: 200px; height: 20px; background-color: red; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oDiv = document.getElementById('div1'); oBtn.onclick = function() &#123; css(oDiv,'backgroundColor','green'); alert(css(oDiv,'width')); &#125; function css() &#123; if(arguments.length == 2) &#123;//获取 if(oDiv.currentStyle)&#123; //IE return arguments[0].currentStyle[arguments[1]]; &#125;else &#123; //火狐 return getComputedStyle(arguments[0])[arguments[1]]; &#125; &#125;else if(arguments.length == 3) &#123;//设置 arguments[0].style[arguments[1]] = arguments[2]; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" id="btn1" value="样式"/&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 通过判断oDiv.currentStyle是否为真，然后分类操作。 但是这样感觉太乱了，我们可以对判断进行一下封装，这样可以到处使用。于是我们先要明白两点： 哪个元素 哪个样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;CSS函数&lt;/title&gt; &lt;style&gt; #div1 &#123; width: 200px; height: 20px; background-color: red; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oDiv = document.getElementById('div1'); oBtn.onclick = function() &#123; css(oDiv,'backgroundColor','green'); alert(css(oDiv,'width')); &#125; function getStyle(obj, attr) &#123; if(obj.currentStyle)&#123; //IE return obj.currentStyle[attr]; &#125;else &#123; //火狐 return getComputedStyle(obj)[attr]; &#125; &#125; function css() &#123; if(arguments.length == 2) &#123;//获取 return getStyle(arguments[0],arguments[1]); &#125;else if(arguments.length == 3) &#123;//设置 arguments[0].style[arguments[1]] = arguments[2]; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" id="btn1" value="样式"/&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这样封装的getStyle(obj, attr)函数就可以直接放在任何地方使用了。 currentStyle优缺点：优点： 可以取一些默认值 缺点： 复合样式：例如background，它有backgroundColor，backgroundImage等等，所以无法获取background，但是可以获取它有backgroundColor 基本样式：如width，就可以直接获取 但是你知道arguments[0]是什么吗？ 所以我们还需要继续优化： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;CSS函数&lt;/title&gt; &lt;style&gt; #div1 &#123; width: 200px; height: 20px; background-color: red; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oDiv = document.getElementById('div1'); oBtn.onclick = function() &#123; css(oDiv,'backgroundColor','green'); alert(css(oDiv,'width')); &#125; function getStyle(obj, attr) &#123; if(obj.currentStyle)&#123; //IE return obj.currentStyle[attr]; &#125;else &#123; //火狐 return getComputedStyle(obj)[attr]; &#125; &#125; function css(obj,attr,value) &#123; if(arguments.length == 2) &#123;//获取 return getStyle(obj,attr); &#125;else if(arguments.length == 3) &#123;//设置 obj.style[attr] = value; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" id="btn1" value="样式"/&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 因为css(obj,attr,value)中的三个参数分别对应arguments[0],arguments[1],arguments[2]。它们是等价的。但是这样我就知道参数的用意了。 数组数组的定义123456//性能高一点点,因为代码少 var arr = [1,2,3,4,5,6]; alert(arr[0]);//很少用 var arr1 = new Array(1,2,3,4,5,6,7,8); alert(arr1); 数组的个数length这个length没什么特别的，但是有一点比较好玩，那就是它可以赋值，然后影响数组的个数。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;数组的定义&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var arr = [1,2,3,4,5,6]; alert(arr); arr.length = 4; alert(arr); arr.length = 10; alert(arr); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 上面的很多空的那就是undefined。如果想快速清空数组们只需要让length=0就行了。 数组使用原则–数组中只存一种类型的变量。数组的方法添加元素push（数组尾部添加）12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;数组的方法&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var arr = [1,2,3,4,5,6]; arr.push(4); alert(arr); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： unshift（数组头部添加）12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;数组的方法&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var arr = [1,2,3,4,5,6]; arr.unshift(100); alert(arr); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 删除元素pop（数组尾部删除）12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;数组的方法&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var arr = [1,2,3,4,5,6]; arr.pop(); alert(arr); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： shift（数组头部删除）12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;数组的方法&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var arr = [1,2,3,4,5,6]; arr.shift(); alert(arr); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果: 数组的排序sort():这个函数只能对字符串进行排序。如果遇到数字就会出现问题。如下： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;数组排序&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; //按照首字母排序 var arr = ["feyddy","crise","blue","haohao"]; arr.sort(); alert(arr); //数字 var arr2 = [12,345,1,34,53,24]; arr2.sort(); alert(arr2); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 这样我们可以看出： 对于字母来说，完全是按照首字母的顺序进行排列的；但是对于数字，也是按照第一个数字的大小进行排序的，这就出问题了。 那怎么解决呢？ 给sort一个比较函数作为参数。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;数组排序&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; //数字 var arr2 = [12,345,1,34,53,24]; arr2.sort(function(num1,num2)&#123; return num1 - num2; &#125;); alert(arr2); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 数组的转换类concat(数组2)连接两个数组将数组2里的元素全部添加到前面的数组中，但是两个数组本身不会改变，生成的是一个新的数组。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; var arr1 = [2,4,6,8]; var arr2 = [1,3,5,7,9]; alert(arr1.concat(arr2)); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 运行结果： join（把数组变成字符串）将数组的元素拼接成一个大的字符串。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;join&lt;/title&gt; &lt;script&gt; var arr = ['1','2','3']; alert(arr.join('-')); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： split（把字符串改成数组）split与join相反。但是取出来每一个的值的类型也是字符型。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;split&lt;/title&gt; &lt;script&gt; var str = "1-2-3-4-5-6-7"; var arr = str.split("-"); alert(arr); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： splice 中间删除 splice(开始位置，删除的长度) 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;splice&lt;/title&gt; &lt;script&gt; var arr = [1,2,3,4,5,6,7]; arr.splice(3,2); alert(arr); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 中间插入 splice(开始位置，删除的长度(为0个)，添加的元素(多个)) 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;splice&lt;/title&gt; &lt;script&gt; var arr = [1,2,3,4,5,6,7]; arr.splice(3,0,11,12,13); alert(arr); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 替换元素 splice(开始位置，删除的长度，添加的元素(删除的长度个)) 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;splice&lt;/title&gt; &lt;script&gt; var arr = [1,2,3,4,5,6,7]; arr.splice(3,2,"a","b"); alert(arr); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 总结：其实splice方法说到底就是一种：先删除，后插入。只不过有个个数正好相同，所以巧妙的实现了不同的效果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript基础学习（一）]]></title>
      <url>%2F2017%2F03%2F07%2FJavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[丛今天开始我将会接触JavaScript，当然我还是会继续我的学习笔记的分享。所有的笔记我都会通过代码的形式以网页版显示出来。 JavaScript基础知识点（一） 下面是笔记的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .base &#123; border: 1px solid purple; &#125; .varType &#123; border: 1px solid purple; &#125; dl &#123; border: 1px solid purple; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="base"&gt; &lt;dl&gt; &lt;dt&gt;JavaScript组成&lt;/dt&gt; &lt;dd&gt;ECMAScript：解释器、翻译。几乎没有兼容性问题。能力很少，一般也就是加减乘除，创建变量等&lt;/dd&gt; &lt;dd&gt;DOM:Document Object Model。他给了JS能够操作界面的能力。有一些兼容性问题&lt;/dd&gt; &lt;dd&gt;BOM:Browser Object Model。它给了JS操作浏览器的能力，也就是对window的操作。它没有兼容性问题，几乎不兼容&lt;/dd&gt; &lt;dd&gt;各组成部分的兼容性，兼容性问题的由来。&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt;&lt;div class="varType"&gt; &lt;dl&gt;变量类型（1） &lt;dt&gt;类型：typeof运算符&lt;/dt&gt; &lt;dd&gt;用法、返回值&lt;/dd&gt; &lt;dd&gt;常见类型：number、string、boolean、undefined、object、function&lt;/dd&gt; &lt;dt&gt;一个变量应该只存放一种类型的数据&lt;/dt&gt; &lt;/dl&gt; &lt;dl&gt;变量类型（2） &lt;dt&gt;数据类型转换&lt;/dt&gt; &lt;dd&gt;例子：计算两个文本框的和&lt;/dd&gt; &lt;dd&gt;显式类型转换（强制类型转换）--- parseInt()、parseFloat()---NaN的意义和检测&lt;/dd&gt; &lt;dd&gt;隐式类型转换 --- ==、===、减法&lt;/dd&gt; &lt;/dl&gt; &lt;/dl&gt; &lt;dl&gt;变量作用域和闭包 &lt;dt&gt;变量作用域（作用范围）&lt;/dt&gt; &lt;dd&gt;局部变量、全局变量&lt;/dd&gt; &lt;dt&gt;什么是闭包&lt;/dt&gt; &lt;dd&gt;子函数可以使用父函数中的局部变量&lt;/dd&gt; &lt;dd&gt;之前一直在使用闭包&lt;/dd&gt; &lt;dd&gt;网上对于闭包的定义&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt;命名规范（1） &lt;dt&gt;命名规范及必要性&lt;/dt&gt; &lt;dd&gt;可读性---能看懂&lt;/dd&gt; &lt;dt&gt;规范性---符合规则&lt;/dt&gt; &lt;dd&gt;匈牙利命名法&lt;/dd&gt; &lt;dd&gt;类型前缀&lt;/dd&gt; &lt;dd&gt;首字母大写&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt;运算符&lt;/dl&gt; &lt;dl&gt;程序流程控制 &lt;dt&gt;判断：if、switch、？&lt;/dt&gt; &lt;dt&gt;循环：while、for&lt;/dt&gt; &lt;dt&gt;跳出：break、continue&lt;/dt&gt; &lt;dt&gt;什么是真、什么是假&lt;/dt&gt; &lt;/dl&gt; &lt;dl&gt;Json &lt;dt&gt;什么是Json&lt;/dt&gt; &lt;dt&gt;Json和数组&lt;/dt&gt; &lt;dt&gt;Json和for in&lt;/dt&gt; &lt;/dl&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; typeof通过下面的代码，你可以很详细的知道JS里面的几种类型： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; var a = 12; alert(typeof (a));//number a = 'abc' alert(typeof (a));//string a = true; alert(typeof (a));//boolean window.onload = function() &#123; a = document.getElementById('div1'); alert(typeof (a));//object a = function() &#123; print('adddd'); &#125; alert(typeof (a));//function alert(typeof (b));//undefined var b; alert(typeof (b));//undefined /* * undefined出现的情况 * 1.真的没定义 * 2.虽然定义了，但是没给值 */ &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1"&gt;asdf&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 数据类型转换有的时候数据类型转换是必须的。下面我们举一个例子： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;变量类型（2）-数据类型转换&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var txt1 = document.getElementById('txt1'); var txt2 = document.getElementById('txt2'); var btn1 = document.getElementById('btn1'); btn1.onclick = function()&#123; alert(txt1.value + txt2.value);//这个时候里面的是string类型，所以简单的+只是拼接。 &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input id="txt1" type="text"/&gt;&lt;input id="txt2" type="text"/&gt;&lt;input id="btn1" type="button" value="求和"/&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码运行结果： 从运行结果我们看出并不是我们需要的结果：35 为什么呢？因为这个时候里面的是两个字符串，也就是’12’+’23’，这样的话电脑只会进行字符串的拼接而已。这里我们就要强制转换一下数据类型了。 显式类型转换–[字符转数字parseInt()和parseFloat()]parseInt()与其说他是字符串转数字，还不如说是从字符串中提取数字。 就拿上面的例子来说： 如果我们将alert(txt1.value + txt2.value);这段代码改成alert(parseInt(txt1.value)+ parseInt(txt2.value));之后，运行结果就会是我们想要的35。 如果我在其中的一个输入框中先输入数字后面紧跟字母的话，会出现什么情况呢？ 从运行结果可以看出：parseInt()是从一串字符串中提取数字出来，不是数字的就自动忽略。 如果我们在字母后面再加上数字，他会不会也提取呢？ 从运行结果可以看出：答案是不会，也就是说，他是从第一位开始搜索，遇到数字后提取数字，只要一遇见字母就不往后判断了。 如果我们个输入数字，一个输入字母，会怎么办？ 从运行结果可以看出：NaN(Not a Number)不是一个数字。也就是无法提取出一个合理的数字。 parseFloat()他的用法和parseInt()用法一样，只不过是提取小数。 检测NaN首先列举一个好玩儿又奇怪的例子： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;检测NaN&lt;/title&gt; &lt;script&gt; var a=parseInt('abc'); alert(a==NaN); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 按照上面的写法，我们预测的结果应该是true。但是实际上的结果却是： 由此，我们可以总结出一个规律：不要拿任何类型和NaN比较，因为他们永远不会相等的。 此时，我们需要使用到一个函数’isNaN(值)’。我们将上面代码里的alert(a==NaN);替换成alert(isNaN(a));运行结果如下; 学到这里，我觉得有必要完善一下一开始的代码：最起码提醒下用户输入的那个有错误： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;数据类型转换完善&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var txt1 = document.getElementById('txt1'); var txt2 = document.getElementById('txt2'); var btn1 = document.getElementById('btn1'); btn1.onclick = function()&#123; var firstValue = parseFloat(txt1.value); var secondValue = parseFloat(txt2.value); if(isNaN(firstValue)) &#123; alert("第一个输入有误"); &#125;else if(isNaN(secondValue)) &#123; alert("第二个输入有误"); &#125;else &#123; alert(firstValue+secondValue); &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input id="txt1" type="text"/&gt;&lt;input id="txt2" type="text"/&gt;&lt;input id="btn1" type="button" value="求和"/&gt;&lt;/body&gt;&lt;/html&gt; 运行结果 隐式类型转换–[‘==’和’===’以及减、乘、除]====：先把两边的东西转成一样的类型，然后比较 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;隐式类型转换&lt;/title&gt; &lt;script&gt; var a = '12'; var b = 12; alert(a==b); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： ======：不转换，直接比较 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;隐式类型转换&lt;/title&gt; &lt;script&gt; var a = '12'; var b = 12; alert(a===b); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 减法我们知道如果两个字符串相加，那结果肯定是字符串的拼接，但是如果是两个字符串相减呢？ 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;隐式类型转换&lt;/title&gt; &lt;script&gt; var a = '12'; var b = 12; alert(a-b); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 乘法和除法也一样。 那为什么加法就不行呢？ 原因是因为+有两层含义： 字符串连接（如果遇到有字符串的话，计算机优先会选择字符串拼接） 数字相加 变量作用域（作用范围）局部变量：定义在一个函数里，只能在这个函数里用。全部变量：不定义在任何一个函数里，可以在任何地方使用。 下面的例子中a为局部变量，b为全局变量。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;变量作用域&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var b;//全部变量：不定义在任何一个函数里，可以在任何地方使用。 function aaa()&#123; var a = 12;//局部变量：定义在一个函数里，只能在这个函数里用 b=20; &#125; function bbb()&#123;// alert(a); alert(b); &#125; aaa(); bbb(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 另外还有一个作用域例子就是闭包： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;变量作用域&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; function aaa() &#123;//父函数 var a = 12; function bbb()&#123;//子函数 alert(a);//子函数可以使用父函数的局部变量 &#125; bbb(); &#125; aaa(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 命名规范匈牙利命名法： 命名前缀： 驼峰命名法 运算符+加、-减、*乘、/除、%取模（取余）重点讲解下取模。下面我们通过一个小例子来解释下取模的应用：隔行变色。 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;隔行变色&lt;/title&gt; &lt;script&gt; window.onload = function () &#123; var oUl = document.getElementById('ul1'); var oLis = document.getElementsByTagName('li'); for(i = 0;i&lt;oLis.length;i++) &#123; if(i%2==0) &#123; oLis[i].style.backgroundColor = "purple"; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id="ul1"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 再举一个时间转换的例子： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;秒转时间&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var a = 67; alert(parseInt(a/60)+"分"+a%60+"秒");//parseInt有取整的意思。 &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 其他的一些运算符就不多说了，基本上和其他语言都是差不多的。 break和continue的区别break：终止整个循环continue：终止本次循环 Json和for in的结合1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Json和for in&lt;/title&gt; &lt;script&gt; window.onload = function() &#123; var objc = &#123;a: 5,b: 12,c:"我是c"&#125;;//一个json对象 var attr=""; for(attr in objc) &#123; alert(attr);//显示所有的a,b,c alert(attr + '=' + objc[attr]);//显示a,b,c和对应的值5,12,"我是c" &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DIV+CSS页面布局学习笔记（二）]]></title>
      <url>%2F2017%2F03%2F05%2FDIV-CSS%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[DIV+CSS页面布局（二）登录注册界面的简单实现首先我们要解决的问题就是，无论怎么缩放浏览器，登录注册界面始终都要显示在窗口的中间。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;登录界面&lt;/title&gt; &lt;style&gt; .login &#123; position: absolute; left: 50%; top: 50%; width: 300px; height: 200px; margin-top: -100px; margin-left: -150px; background-color: purple; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="login"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 但是我们往往看到的注册界面都比较大气，基本都是整个页面的布局。但是如果我们一味的缩小界面，而让注册界面整个都适配界面大小，那样的话，如果达到太小的时候就很难看了。所以一般设置页面加上一个最小的宽度或者高度。那么怎么实现呢？ 其实很简单，那就是在一个div1里面加上一个div2来设置这个div2的宽度就可以了。 区块居中设计1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; body &#123; text-align: center; &#125; .container &#123; width: 960px; height: 800px; background-color: #cccccc; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body style="font-size: 50px;"&gt;&lt;div class="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行效果： 标准的浏览器只需要设置margin为自动就行，但是IE浏览器不兼容，就需要设置body的text-align: center。但是这样的话body里面所有的文本都默认是设置的center。 设置两列浮动的布局12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; body &#123; text-align: center; &#125; .container &#123; width: 960px; height: 800px; background-color: #cccccc; margin: 0 auto; &#125; .leftside &#123; float: left; background-color: orange; width: 600px; height: 400px; &#125; .rightside &#123; float: right; background-color: purple; width: 300px; height: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body style="font-size: 50px;"&gt;&lt;div class="container"&gt; &lt;div class="leftside"&gt;&lt;/div&gt; &lt;div class="rightside"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行效果： 设置三列浮动的布局1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; body &#123; text-align: center; &#125; .container &#123; width: 960px; height: 800px; background-color: #cccccc; margin: 0 auto; &#125; .leftside &#123; float: left; background-color: orange; width: 200px; height: 400px; margin-right: 10px; &#125; .main &#123; float: left; background-color: yellow; width: 530px; height: 400px; &#125; .rightside &#123; float: right; background-color: purple; width: 200px; height: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body style="font-size: 50px;"&gt;&lt;div class="container"&gt; &lt;div class="leftside"&gt;&lt;/div&gt; &lt;div class="main"&gt;&lt;/div&gt; &lt;div class="rightside"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行效果： 设置多列浮动的布局与上面的类似。我们可以通过一个类名，设置所有的div，float:left+margin-left。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DIV+CSS页面布局学习笔记（一）]]></title>
      <url>%2F2017%2F03%2F05%2FDIV-CSS%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[DIV+CSS页面布局（一）采用DIV+CSS模式的网站具有以下优势 表现和内容相分离 代码简洁，提高页面浏览速度 易于维护和改版 提高搜索引擎对网页的索引效率 “无意义”的HTML元素div和span HTML只是赋予内容的手段，大部分HTML标签都有其意义（例如，标签p创建段落，h1标签创建标题等等）的，然而div和span标签似乎没有任何内容上的意义，听起来就像一个泡沫做成的锥子一样无用。但实际上，与CSS结合起来后，它们被用的十分广泛。你所需要记住的就是span和div是“无意义”的标签。它们的存在纯粹是应用样式，所以当样式表失效时，它就没有任何作用。 它们被用来组合成一大块的HTML代码并赋予一定的信息，大部分用类属性class和标识属性id与元素联系起来。span和div的不同之处在于span是内联的，用在一小块的内联HTML中。而div元素是块级的（简单地说，它等同于前后有断行），用于组合一大块的代码，为HTML文档内大块的内容提供结构和背景的方法，可以包含段落，标题，表格，甚至其他部分，这使div便于建立不同集成的类。 div的其实标签和结束标签之间的所有内容都是用来构建这个块的，其中所包含元素的特性由div标签的属性来控制，或者是通过使用样式表格化这个块来进行控制。 下面举个例子来简单的解释下什么叫无意义 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body style="font-size: 50px;"&gt;This is a line of words &lt;br&gt;&lt;h1&gt;This is a line of words&lt;/h1&gt; &lt;br&gt;&lt;u&gt;This is a line of words&lt;/u&gt;&lt;br&gt;&lt;div&gt;This is a line of words&lt;/div&gt;&lt;br&gt;This is a line of words &lt;br&gt;&lt;div&gt;This is a line of words&lt;/div&gt;&lt;div&gt;This is a line of words&lt;/div&gt;&lt;div&gt;This is a line of words&lt;/div&gt;&lt;span&gt;This is a line of words&lt;/span&gt;&lt;span&gt;This is a line of words&lt;/span&gt;&lt;span&gt;This is a line of words&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 由运行结果，我们可以看出： div里面的内容和不加任何标签显示的效果是一样的。但是有些标签内的文字本身具有不同的样式，这样的话，我们就可以用div标签来自己定义样式，不用其他的标签的样式。 span标签不带换行功能，是内联用；div带有换行功能，是大的区块用。 页面布局的W3C盒子模型 每个HTML元素都可以看作一个装了东西盒子，盒子具有宽度（width）和高度（height），盒子里面的内容到盒子的边框之间的距离即填充（padding），盒子本身有边框（border），而盒子边框外和其他盒子之间，还有边界（margin）。 一般的浏览器是符合W3C标准的，也就是 设置的宽高是内容的宽高，然后在外面加上padding,border,margin。最后整个盒子完全比设置的宽高要大。 IE浏览器不符合W3C标准，即设置的宽高是除margin之外的宽高，也就是，先是最外面有一个margin，然后里面是设置的宽高，宽高里面是border以及padding。最后盒子里面显示的内容比设置的要小很多。 那么怎么解决IE与非IE浏览器div大小兼容问题？ 我们可以使用一个!important。它在IE浏览器里面不会被识别，但是在非IE浏览器中会被识别。所以我们可以对一个div属性设置两个值。如： 1234.box &#123;width: 250px !important;width: 300px;&#125; 这样的话，在IE浏览器中就不会识别!important，于是就会采用后设置的属性值；但是在非IE浏览器中就会识别，从而优先使用!important的属性值。 那么什么时候该考虑到兼容性的问题呢？在设置了宽度和高度之后且使用了border或者padding之后。 &lt;!DOCTYPE html&gt;这个貌似可以强制IE符合标准。 和页面布局有关的CSS属性position属性这个属性一般会和top和left两个属性一起使用， static(默认为静态的)absolute(一般用的不多)absolute是为了让盒子以网页的顶部（top）和左边（left）为起始点进行固定布局。如果内容较多，上下左右滑动网页内容，盒子也会跟随着滑动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; position: absolute; top: 100px; left: 50px; width: 100px; height: 100px; background-color: yellow; &#125; .two &#123; position: absolute; top: 100px; left:160px; width: 100px; height: 100px; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;&lt;div class="one"&gt;这是第一个内容&lt;/div&gt;&lt;div class="two"&gt;这是第二个内容&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行效果： 当我向下滑动网页到最底部的时候： relative相对于自己默认的位置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; position: absolute; top: 100px; left: 50px; width: 200px; height: 200px; background-color: yellow; &#125; .two &#123; position: absolute; top: 150px; left:160px; width: 200px; height: 200px; background-color: orange; &#125; .three &#123; /*position: relative;*/ top: 0px; left:0px; width: 200px; height: 200px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="one"&gt;这是第一个内容&lt;/div&gt;&lt;div class="two"&gt;这是第二个内容 &lt;div class="three"&gt; three的原始位置 &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 下面设置相对于上面的原始位置向上偏移10像素，向左偏移20像素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; position: absolute; top: 100px; left: 50px; width: 200px; height: 200px; background-color: yellow; &#125; .two &#123; position: absolute; top: 150px; left:160px; width: 200px; height: 200px; background-color: orange; &#125; .three &#123; position: relative; top: -10px; left:-20px; width: 200px; height: 200px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="one"&gt;这是第一个内容&lt;/div&gt;&lt;div class="two"&gt;这是第二个内容 &lt;div class="three"&gt; 相对位置的DIV &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 我们可以看出，.three的div的原始位置是.two的，但是为什么原始位置没有和.two的重叠起来，那是因为里面还有个文字盒子，所以.three按照文档流就被挤到文字下面。 fixed固定在当前窗口的某个界面，这个和absolute的效果相反，他不会随着页面的上下左右滑动而滑动。一直会让你看到他的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; position: fixed; top: 100px; left: 50px; width: 200px; height: 200px; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;&lt;div class="one"&gt;这是fixedDiv&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;/html&gt; 运行效果： 从图中的滑动条可以看到，无论怎么滑动页面，fixedDiv一直在窗口显示着。而且位置也在同一个地方。 z-index决定层的先后顺序和覆盖关系，值高的元素会覆盖值低的元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; position: absolute; top: 100px; left: 50px; width: 200px; height: 200px; background-color: yellow; &#125; .two &#123; position: absolute; top: 150px; left:160px; width: 200px; height: 200px; background-color: orange; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;这是一些文字内容 &lt;br&gt;&lt;div class="one"&gt;这是第一个内容&lt;/div&gt;&lt;div class="two"&gt;这是第二个内容&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行效果： 由图我们可以知道，两个盒子重合了。这个时候我们可以用z-index指定重叠顺序。 如果我们将上面的.one添加z-index: 1;,.two添加z-index: 0;,就会出现下面的结果 text-align文本对齐方式:靠左对齐（left）、居中对齐（center）、靠右对齐（right） 那么怎么才能使文本在垂直方向居中对齐呢？下面介绍两种方法： 利用padding。不设置盒子的高度，用padding使得内容距离上下相同的距离。此时的盒子高度会随着内容的高度自动变化。 1234567891011121314151617181920212223 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; width: 800px; padding: 100px 10px; background-color: yellow; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="one"&gt;这是居中文本&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行效果： ![](https://ww1.sinaimg.cn/large/006tKfTcgy1fdbmd5t4grj30mv06g0st.jpg) 但是这个会随着内容的变化高度变化，所以必须限定死文字的内容和大小。不推荐使用。 利用行高（line-height） 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; width: 800px; line-height: 200px; background-color: yellow; text-align: center; /*font-size: 1cm;*/ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="one"&gt;这是居中文本&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 运行效果（font-size增加之前和之后的高度都没有改变）： ![](https://ww2.sinaimg.cn/large/006tKfTcgy1fdbmjbqa3sj30ny07z41y.jpg) ![](https://ww3.sinaimg.cn/large/006tKfTcgy1fdbmjmed00j30nz08a427.jpg) display它是一个显示属性，设定block值是以块状显示，在元素后面添加换行符，即其他元素不能在其后面并列显示，如果设定inline值则内联显示，在元素后面删除换行符，多个元素可以在一行内并列显示。使用值none将关闭指定元素及其子元素的显示。 将块级元素转成内联的 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; width: 300px; line-height: 200px; background-color: yellow; text-align: center; font-size: 1cm; display: inline; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="one"&gt;这是文本一&lt;/div&gt;&lt;div class="one"&gt;这是文本二&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行效果： 将内联元素转成块级 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; width: 300px; margin: 10px; line-height: 200px; background-color: yellow; text-align: center; font-size: 1cm; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;span class="one"&gt;这是文本一&lt;/span&gt;&lt;span class="one"&gt;这是文本二&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 运行效果： 隐藏盒子并且盒子的位置也没了 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; width: 300px; margin: 10px; line-height: 200px; background-color: yellow; text-align: center; font-size: 1cm; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;span class="one"&gt;这是文本一&lt;/span&gt;&lt;span class="two" style="background-color:orange;"&gt;这是文本二&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 运行效果： 但是这个效果就类似于页面没有创建这个盒子的样子，隐藏的同时，位置也没了。但是我们想隐藏，但是位置还保留的话，就需要用到下面的属性了。 visibility这个属性是针对嵌套层的设置，如果存在嵌套的层（子层）和被嵌套的层（父层）时，可以使用inherit值设置子层继承父层的可见性，如果父层可见，子层也可见。当使用vivible值时，无论父层是否可见，子层都可见。而值hidden时，无论父层是否可见，子层都隐藏。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; width: 300px; margin: 10px; line-height: 200px; background-color: yellow; text-align: center; font-size: 1cm; visibility: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;span class="one"&gt;这是文本一&lt;/span&gt;&lt;span class="two" style="background-color:orange;"&gt;这是文本二&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 运行效果： 可以看出来，上面的位置还是存在的，没有影响页面的布局。 overflow用于设置层内的内容超出层所能容的范围处理方式，为该属性设置visible值时，无论层的大小，内容都会显示出来。当设置hidden值时，会隐藏超出层大小的内容。当设置值为scroll时，不管内容是否超出层的范围，选中此项都会为层添加滚动条。而值使用auto值时，只在内容超出层的范围时才显示滚动条。 注意：他是设置超出部分内容隐藏，所以必须设置宽度和高度。 hidden（设置超出部分隐藏） 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; width: 100px; height: 100px; /*line-height: 200px;*/ background-color: orange; text-align: center; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="one"&gt;这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行效果 scroll（设置超出部分通过滚动条可见） 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; width: 100px; height: 100px; /*line-height: 200px;*/ background-color: orange; text-align: center; overflow: scroll; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="one"&gt;这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一这是文本一&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行效果 auto（设置自动判断是否有内容超出，如果有，显示滚动条，如果没有不显示滚动条） float设置区块漂浮属性，允许网页制作者将文本环绕在一个元素的周围，可以使用左漂浮left值，右漂浮right值。 下面我们创建三个盒子并且把中间的盒子漂浮着，但是你会看到只有两个盒子，第三个盒子消失了。那是因为第三个盒子在第二个漂浮的盒子下面。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; width: 200px; height: 210px; background-color: blue; &#125; .two &#123; width: 200px; height: 200px; background-color: orange; float: left; &#125; .three &#123; width: 200px; height: 220px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="one"&gt;&lt;/div&gt;&lt;div class="two"&gt;&lt;/div&gt;&lt;div class="three"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 但是有时候我们看见IE下面的就不好使，直接第三个盒子在第二个盒子的后面显示。要解决这个兼容性问题只能将所有的盒子都漂浮。 使用漂浮的好处就是，如果一行的漂浮的盒子不够空间，盒子会自动换行。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; width: 200px; height: 210px; background-color: blue; float: left; &#125; .two &#123; width: 200px; height: 200px; background-color: orange; float: left; &#125; .three &#123; width: 200px; height: 200px; background-color: green; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="one"&gt;&lt;/div&gt;&lt;div class="two"&gt;&lt;/div&gt;&lt;div class="three"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果： 当我们将界面宽度缩小的时候，就会自动换行。注意：只要前面的盒子有一点高度漏出来，换行的盒子就会以他为标准的，不会在第一个盒子下面 clear清除属性指定一个元素是否允许有元素漂浮在它的旁边。值left移动元素到在其左边的漂浮的元素的下面；同样的值right移动到其右边的漂浮的元素下面。其他的还有缺省的none值，和移动元素到其两边的漂浮的元素的下面的both的值。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .one &#123; width: 200px; height: 210px; background-color: blue; float: left; &#125; .two &#123; width: 200px; height: 200px; background-color: orange; float: left; &#125; .three &#123; width: 200px; height: 220px; background-color: green; float: left; clear: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="one"&gt;&lt;/div&gt;&lt;div class="two"&gt;&lt;/div&gt;&lt;div class="three"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Core Data的基本使用]]></title>
      <url>%2F2017%2F03%2F01%2FCore-Data%2F</url>
      <content type="text"><![CDATA[Core Data什么是Core DataCore Data是一个框架，他提供了对象-关系映射的功能，即能够将OC对象转化成数据，保存在SQLite数据库文件中，也能够将保存的数据库中的数据还原成OC对象。在此数据操作期间，我们不需要编写任何SQL语句，这个有点类似于著名的Hibernate持久化框架，不过功能肯定是没有Hibernate强大的。 用来保存数据 用户偏好设置 规档 sqlite CoreData 是基于sqlite的封装 ，数据保存到一个数据库文件数据库文件：表结构 CoreData的使用步骤 创建模型文件 相当于数据库 添加实体 相当表 创建实体类 相于模型类 生成上下文 关联模型文件生成数据库 保存对象到数据库 从数据库获取对象 更新数据 删除数据 下面我们使用一个简单的demo来演示一下怎么使用. 需求： 创建一个数据库company.sqlite 数据库要一张员工表（name,age,height） 往数据库添加员工信息 下面按照步骤来进行： 首先创建一个模型文件： 创建完成后会出现一个Company.xcdatamodeld文件。 已添加实体 点击左下角的Add Entity来创建一个表Employee 然后按照需求在表里面添加信息字段： 创建实体类 下面介绍的是xcode8以上的版本的创建方法 创建完成后你将会发现项目中多了四个文件 生成上下文，关联模型文件生成数据库 12345678910111213141516171819202122232425// 1.上下文 关联Company.xcdatamodeld 模型文件 NSManagedObjectContext *context = [[NSManagedObjectContext alloc] init]; // 关联模型文件 // 创建一个模型对象 // 传一个nil 会把 bundle下的所有模型文件 关联起来 NSManagedObjectModel *model = [NSManagedObjectModel mergedModelFromBundles:nil]; // 持久化存储调度器 NSPersistentStoreCoordinator *store = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:model]; // 存储数据库的名字 NSError *error = nil; // 获取docment目录 NSString *doc = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; // 数据库保存的路径 NSString *sqlitePath = [doc stringByAppendingPathComponent:@&quot;company.sqlite&quot;]; [store addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:[NSURL fileURLWithPath:sqlitePath] options:nil error:&amp;error]; context.persistentStoreCoordinator = store; self.context = context; 添加员工信息 12345678910111213141516// 创建员工 Employee *emp1 = [NSEntityDescription insertNewObjectForEntityForName:@&quot;Employee&quot; inManagedObjectContext:self.context]; // 设置员工属性 emp1.name = @&quot;lisi&quot;; emp1.age = @28; emp1.height = @2.10; //保存 - 通过上下文操作 NSError *error = nil; [self.context save:&amp;error]; if (!error) &#123; NSLog(@&quot;success&quot;); &#125;else&#123; NSLog(@&quot;%@&quot;,error); &#125; 读取员工信息 123456789101112131415161718192021222324252627282930 //创建一个请求对象 （填入要查询的表名-实体类） NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@&quot;Employee&quot;]; // 过滤查询 // 查找张三 并且身高大于1.8// NSPredicate *pre = [NSPredicate predicateWithFormat:@&quot;name=%@ AND height &gt; %@&quot;,@&quot;zhangsan&quot;,@(1.8)];// request.predicate = pre; //排序 以身高进行升序// NSSortDescriptor *sort = [NSSortDescriptor sortDescriptorWithKey:@&quot;height&quot; ascending:NO];// request.sortDescriptors = @[sort]; // 分页查询 总共13条数据 每页显示5条数据 //第一页的数据 request.fetchLimit = 5; //设置起始数据是第几个 request.fetchOffset = 10;//这是第3页数据 //读取信息 NSError *error = nil; NSArray *emps = [self.context executeFetchRequest:request error:&amp;error]; if (!error) &#123; NSLog(@&quot;emps: %@&quot;,emps); for (Employee *emp in emps) &#123; NSLog(@&quot;%@ %@ %@&quot;,emp.name,emp.age,emp.height); &#125; &#125;else&#123; NSLog(@&quot;%@&quot;,error); &#125; 删除员工信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144 // 删除zhangsan // 1.查找到zhangsan NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@&quot;Employee&quot;]; NSPredicate *pre = [NSPredicate predicateWithFormat:@&quot;name=%@&quot;,name]; request.predicate = pre; // 2.删除zhangsan NSArray *emps = [self.context executeFetchRequest:request error:nil]; for (Employee *emp in emps) &#123; NSLog(@&quot;删除员工的人 %@&quot;,emp.name); [self.context deleteObject:emp]; &#125; // 3.用context同步下数据库 //所有的操作暂时都是在内存里，调用save 同步数据库 [self.context save:nil]; ``` - 查找员工信息 ```objective-c - (NSArray *)findEmployeeWithName:(NSString *)name&#123; // 1.查找员工 NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@&quot;Employee&quot;]; NSPredicate *pre = [NSPredicate predicateWithFormat:@&quot;name=%@&quot;,name]; request.predicate = pre; return [self.context executeFetchRequest:request error:nil]; &#125; ``` - 修改员工信息 ```objective-c // 把wangwu的身高更改成 1.7 // 1.查找wangwu NSArray *emps = [self findEmployeeWithName:@&quot;wangwu&quot;]; // 2.更新身高 if (emps.count == 1) &#123; Employee *emp = emps[0]; emp.height = @1.7; &#125; // 3.同步（保存）到数据 [self.context save:nil]; ``` - 模糊查询员工信息 ```objective-c // 查询 NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@&quot;Employee&quot;]; // 过滤 // 1.查询以wang开头员工 //NSPredicate *pre = [NSPredicate predicateWithFormat:@&quot;name BEGINSWITH %@&quot;,@&quot;wang&quot;]; // 2.以si 结尾 //NSPredicate *pre = [NSPredicate predicateWithFormat:@&quot;name ENDSWITH %@&quot;,@&quot;si&quot;]; // 3.名字包含 g //NSPredicate *pre = [NSPredicate predicateWithFormat:@&quot;name CONTAINS %@&quot;,@&quot;g&quot;]; // 4.like 以si结尾 NSPredicate *pre = [NSPredicate predicateWithFormat:@&quot;name like %@&quot;,@&quot;li*&quot;]; request.predicate = pre; //读取信息 NSError *error = nil; NSArray *emps = [self.context executeFetchRequest:request error:&amp;error]; if (!error) &#123; NSLog(@&quot;emps: %@&quot;,emps); for (Employee *emp in emps) &#123; NSLog(@&quot;%@ %@ %@&quot;,emp.name,emp.age,emp.height); &#125; &#125;else&#123; NSLog(@&quot;%@&quot;,error); &#125; ``` ### 表关联在项目里面我们新建一个表 Department：![](https://ww4.sinaimg.cn/large/006tNbRwgy1fd8sn5fg44j30tf0jndge.jpg)- 创建实体类![](https://ww3.sinaimg.cn/large/006tKfTcgy1fd8stosthwj30tf0jndge.jpg)![](https://ww4.sinaimg.cn/large/006tKfTcgy1fd8stv7y4sj30gb0cwq3m.jpg)![](https://ww3.sinaimg.cn/large/006tKfTcgy1fd8stypoxzj30ka0e8wee.jpg)![](https://ww1.sinaimg.cn/large/006tKfTcgy1fd8su8n0vmj30kc0efwee.jpg)![](https://ww2.sinaimg.cn/large/006tKfTcgy1fd8sutz3zej306602ba9x.jpg)- 员工应该属于哪一个部门？我们在员工的表里面建立一个与部门表的关联![](https://ww3.sinaimg.cn/large/006tKfTcgy1fd8syvds7gj30so09ujs1.jpg)下面我们需要把之前由员工表创建的实体类删除，然后重新创建一个员工实体类。这是因为我们刚刚给员工表添加了一个关联，需要重新生成最新的。具体的步骤参考上面：只是最后生成的属性里面会多出刚刚关联的部门属性。- 添加员工信息```objective-c// 创建员工// 1.添加zhangsan 属于ios部门Employee *emp1 = [NSEntityDescription insertNewObjectForEntityForName:@&quot;Employee&quot; inManagedObjectContext:self.context];emp1.name = @&quot;zhangsan&quot;;emp1.height = @1.7;emp1.age = @27; // 创建ios部门Department *dep1 = [NSEntityDescription insertNewObjectForEntityForName:@&quot;Department&quot; inManagedObjectContext:self.context];dep1.name = @&quot;ios&quot;;dep1.createDate = [NSDate date];dep1.departNo = @&quot;D001&quot;; emp1.depart = dep1; // 2.添加lisi 属于android 部门Employee *emp2 = [NSEntityDescription insertNewObjectForEntityForName:@&quot;Employee&quot; inManagedObjectContext:self.context];emp2.name = @&quot;lisi&quot;;emp2.height = @1.7;emp2.age = @27; // 创建android部门Department *dep2 = [NSEntityDescription insertNewObjectForEntityForName:@&quot;Department&quot; inManagedObjectContext:self.context];dep2.name = @&quot;android&quot;;dep2.createDate = [NSDate date];dep2.departNo = @&quot;D002&quot;; emp2.depart = dep2; //一次保存[self.context save:nil]; 查找iOS部门的员工 123456789101112131415161718//查找ios部门的员工NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@&quot;Employee&quot;]; // 过滤查询NSPredicate *pre = [NSPredicate predicateWithFormat:@&quot;depart.name = %@&quot;,@&quot;ios&quot;];request.predicate = pre;//读取信息NSError *error = nil;NSArray *emps = [self.context executeFetchRequest:request error:&amp;error];if (!error) &#123; NSLog(@&quot;emps: %@&quot;,emps); for (Employee *emp in emps) &#123; NSLog(@&quot;name:%@ departName:%@ &quot;,emp.name,emp.depart.name); &#125;&#125;else&#123; NSLog(@&quot;%@&quot;,error);&#125; 多个数据库一个模型文件对应一个数据库。 我们在创建一个数据库模型，步骤参考上面。 注意点： 一个数据库文件对应一个上下文。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#import &quot;ViewController.h&quot;#import &lt;CoreData/CoreData.h&gt;#import &quot;Employee.h&quot;#import &quot;Department.h&quot;#import &quot;Status.h&quot;@interface ViewController ()@property(strong,nonatomic)NSManagedObjectContext *companyContext;@property(strong,nonatomic)NSManagedObjectContext *weiboContext;@end@implementation ViewController#pragma mark 添加员工和微博信息信息- (IBAction)addEmployee:(id)sender &#123; //创建员工 Employee *emp = [NSEntityDescription insertNewObjectForEntityForName:@&quot;Employee&quot; inManagedObjectContext:self.companyContext]; emp.name = @&quot;zhangsan&quot;; emp.height = @1.8; emp.age = @25; [self.companyContext save:nil]; //创建微博 Status *sts = [NSEntityDescription insertNewObjectForEntityForName:@&quot;Status&quot; inManagedObjectContext:self.weiboContext]; sts.text = @&quot;祝愿大家找到好工作&quot;; sts.author = @&quot;gzios 1期&quot;; sts.createDate = [NSDate date]; [self.weiboContext save:nil]; &#125;- (void)viewDidLoad &#123; [super viewDidLoad]; [self setupContext];&#125;/** * 创建两个上下文 */- (void)setupContext &#123; //创建company上下文 self.companyContext = [self setupContextWithModelName:@&quot;Company&quot;]; //创建weibo上下文 self.weiboContext = [self setupContextWithModelName:@&quot;Weibo&quot;];&#125;/** * 根据模型文件名 返回上下文 */-(NSManagedObjectContext *)setupContextWithModelName:(NSString *)modelName&#123; // 1.上下文 关联Company.xcdatamodeld 模型文件 NSManagedObjectContext *context = [[NSManagedObjectContext alloc] init]; // 关联模型文件 // 创建一个模型对象 // 传一个nil 会把 bundle下的所有模型文件 关联起来 // 查找model文件的URL NSURL *modelURL = [[NSBundle mainBundle] URLForResource:modelName withExtension:@&quot;momd&quot;]; NSManagedObjectModel *model = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL]; // 持久化存储调度器 NSPersistentStoreCoordinator *store = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:model]; // 存储数据库的名字 NSError *error = nil; // 获取docment目录 NSString *doc = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; // 数据库保存的路径 NSString *sqlitePath = [doc stringByAppendingFormat:@&quot;/%@.slqite&quot;,modelName]; [store addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:[NSURL fileURLWithPath:sqlitePath] options:nil error:&amp;error]; context.persistentStoreCoordinator = store; return context;&#125;@end 之前也说过Core Data是基于SQLITE的封装，我们也可以看到SQL语句，只需要进行下面的设置，就可以在控制台看到SQL的语句。 sqlite 和 CoreData 对比 sqlite 是纯c语言存储数据方式 coredata 也是对sqlite的封装 ，它数据的保存直接使用对象，不用再写sql语句 sqlite 性能优于 coredata 什么时候使用sqlite 什么时候使用CoreData Coredata功能不是很强大 如果你的数据库表关联大复杂 三四张表都关联 -sqlite 如果数据表结构比较简单 就只有两三张，这些表没有关联关系 coreData]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LLDB的使用（一）]]></title>
      <url>%2F2017%2F02%2F28%2FLLDB%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[LLDB简介LLDB 是一个有着 REPL 的特性和 C++ ,Python 插件的开源调试器。LLDB 绑定在 Xcode 内部，存在于主窗口底部的控制台中。LLDB是Xcode默认的调试器，它与LLVM编译器一起，带给我们更丰富的流程控制和数据检测的调试功能。调试器允许你在程序运行的特定时暂停它，你可以查看变量的值，执行自定的指令，并且按照你所认为合适的步骤来操作程序的进展。平时用Xcode运行程序，实际走的都是LLDB。熟练使用LLDB，可以让你debug事半功倍。 LLDB控制台LLDB控制台平时会输出一些log信息。如果我们想输入命令调试，必须让程序进入暂停状态。让程序进入暂停状态的方式主要有2种： 断点或者watchpoint: 在代码中设置一个断点（watchpoint），当程序运行到断点位置的时候，会进入stop状态 直接暂停，控制台上方有一个暂停按钮，上图红框已标出，点击即可暂停程序 注：下面所有的实现都必须遵从一个原则：程序暂停！！！！ LLDB语法1&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;...]] &lt;action&gt; [-options [option-value]] [argument [argument...]] 下面对上面出现的语法点进行解释一下： &lt;command&gt;(命令)和&lt;subcommand&gt;(子命令)：LLDB调试命令的名称。命令和子命令按层级结构来排列：一个命令对象为跟随其的子命令对象创建一个上下文，子命令又为其子命令创建一个上下文，依此类推。 &lt;action&gt;：执行命令的操作 &lt;options&gt;：命令选项 &lt;arguement&gt;：命令的参数 []：表示命令是可选的，可以有也可以没有 下面来举个例子： 12(lldb) breakpoint set -n searchBreakpoint 1: 43 locations. 运行效果就是在search这个方法那边设置一个断点： 这个命令对应到上面的语法就是： command: breakpoint 表示断点命令 action: set 表示设置断点 option: -n 表示根据方法name设置断点 arguement: search 表示方法名为search 原始(raw)命令LLDB支持不带命令选项(options)的原始(raw)命令，原始命令会将命令后面的所有东西当做参数(arguement)传递。不过很多原始命令也可以带命令选项，当你使用命令选项的时候，需要在命令选项后面加–区分命令选项和参数。 常用的expression就是raw命令，一般情况下我们使用expression打印一个东西是这样的： 12(lldb) expression selectedPage(NSInteger) $1 = 1 当我们想打印一个对象的时候需要加上-0命令选项，而且需要用–将命令选项和参数区分： 12(lldb) expression -0 --self&lt;ViewController:0x7f9000f17660&gt; 唯一匹配原则LLDB的命令遵循唯一匹配原则：假如根据前n个字母已经能唯一匹配到某个命令，则只写前n个字母等效于写下完整的命令。 例如： 前面提到我设置断点的命令，我们可以使用唯一匹配原则简写，下面2条命令等效： 1234(lldb) breakpoint set -n searchBreakpoint 4: 43 locations.(lldb) br s -n searchBreakpoint 5: 43 locations. ~/.lldbinitLLDB有了一个启动时加载的文件~/.lldbinit，每次启动都会加载。所以一些初始化的事儿，我们可以写入~/.lldbinit中，比如给命令定义别名等。但是由于这时候程序还没有真正运行，也有部分操作无法在里面玩，比如设置断点。 LLDB命令expressionexpression命令的作用是执行一个表达式，并将表达式返回的结果输出。expression的完整语法是这样的： 1expression &lt;cmd-options&gt; -- &lt;expr&gt; &lt;cmd-options&gt;：命令选项，一般情况下使用默认的即可，不需要特别标明。 --: 命令选项结束符，表示所有的命令选项已经设置完毕，如果没有命令选项，--可以省略 &lt;expr&gt;: 要执行的表达式 说expression是LLDB里面最重要的命令都不为过。因为他能实现2个功能。 执行某个表达式。我们在代码运行过程中，可以通过执行某个表达式来动态改变程序运行的轨迹。假如我们在运行过程中，突然想把self.view颜色改成红色，看看效果。我们不必写下代码，重新run，只需暂停程序，用expression改变颜色，再刷新一下界面，就能看到效果: 12(lldb) expression -- self.VIPAllOrderTableView.backgroundColor = [UIColor redColor](UICachedDeviceRGBColor *) $1 = 0x0000608000465880 效果就是： 将返回值输出。 也就是说我们可以通过expression来打印东西。 假如我们想打印self.view： 12(lldb) expression -- self.view(UIView *) $2 = 0x00007fed0e606f60 当然e的更主要的用法是通过执行表达式，动态修改当前线程堆栈变量的值，从而达到调试的目的（其实查询也很主要，只是会用另一种方式查询）。比如，我们可以在某个if..else..的语句前打上断点，直接修改条件表达式的值，使程序覆盖了不同分支，而不用苦心积虑地停止程序、hard code变量值来进行调试，节省了一大坨修改与编译时间。 在上面这份测试代码，在进入条件判断语句前打了断点，那我们可以通过e命令，来自由控制程序走向任何一个分支。 p &amp; print &amp; call一般情况下，我们直接用expression还是用得比较少的，更多时候我们用的是p、print、call。这三个命令其实都是expression –的别名（–表示不再接受命令选项，详情见前面原始(raw）命令这一节） print: 打印某个东西，可以是变量和表达式 p: 可以看做是print的简写 call: 调用某个方法。 表面上看起来他们可能有不一样的地方，实际都是执行某个表达式（变量也当做表达式），将执行的结果输出到控制台上。所以你可以用p调用某个方法，也可以用call打印东西 12345678910(lldb) expression -- self.view(UIView *) $3 = 0x00007fed0e606f60(lldb) p self.view(UIView *) $4 = 0x00007fed0e606f60(lldb) print self.view(UIView *) $5 = 0x00007fed0e606f60(lldb) call self.view(UIView *) $6 = 0x00007fed0e606f60(lldb) e self.view(UIView *) $7 = 0x00007fed0e606f60 根据唯一匹配原则，如果你没有自己添加特殊的命令别名。e也可以表示expression的意思。原始命令默认没有命令选项，所以e也能带给你同样的效果 与po不同，它不会打出对象的详细信息，只会打印出一个$符号，数字，再加上一段地址信息。由于po命令下，对象的description 有可能被随便乱改，没有输出地址消息。 po我们知道，OC里所有的对象都是用指针表示的，所以一般打印的时候，打印出来的是对象的指针，而不是对象本身。如果我们想打印对象。我们需要使用命令选项:-O。为了更方便的使用，LLDB为expression -O --定义了一个别名：po 12345678(lldb) expression -o -- self._VIPAllOrderTableView&lt;UITableView: 0x7fed0f850400; frame = (0 0; 0 0); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x60800025b7e0&gt;; layer = &lt;CALayer: 0x608000235e80&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;0, 0&#125;&gt; Fix-it applied, fixed expression was: self-&gt;_VIPAllOrderTableView (lldb) po self.VIPAllOrderTableView&lt;UITableView: 0x7fed0f850400; frame = (0 0; 0 0); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x60800025b7e0&gt;; layer = &lt;CALayer: 0x608000235e80&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;0, 0&#125;&gt; 还有其他很多命令选项，不过我们一般用得比较少，所以我就不具体的一一介绍了，如果想了解，在LLDB控制台上输入：help expression即可查到expression所有的信息 threadthread backtrace &amp; bt有时候我们想要了解线程堆栈信息，可以使用thread backtrace, thread backtrace作用是将线程的堆栈打印出来。我们来看看他的语法: 1thread backtrace [-c &lt;count&gt;] [-s &lt;frame-index&gt;] [-e &lt;boolean&gt;] thread backtrace后面跟的都是命令选项： -c：设置打印堆栈的帧数(frame) -s：设置从哪个帧(frame)开始打印 -e：是否显示额外的回溯 实际上这些命令选项我们一般不需要使用。 e.g: 当发生crash的时候，我们可以使用thread backtrace查看堆栈调用 12345678910111213141516171819202122232425(lldb) thread backtrace* thread #1: tid = 0x3551a, 0x0000000100b78933 the-master`-[HSTeamUnderwayOrderViewController setUpUI](self=0x00007fed0e66fed0, _cmd=&quot;setUpUI&quot;) + 1139 at HSTeamUnderwayOrderViewController.m:316, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 9.1 * frame #0: 0x0000000100b78933 the-master`-[HSTeamUnderwayOrderViewController setUpUI](self=0x00007fed0e66fed0, _cmd=&quot;setUpUI&quot;) + 1139 at HSTeamUnderwayOrderViewController.m:316 frame #1: 0x0000000100b75941 the-master`-[HSTeamUnderwayOrderViewController viewDidLoad](self=0x00007fed0e66fed0, _cmd=&quot;viewDidLoad&quot;) + 785 at HSTeamUnderwayOrderViewController.m:89 frame #2: 0x0000000105a0ca3d UIKit`-[UIViewController loadViewIfRequired] + 1258 frame #3: 0x0000000105a13062 UIKit`-[UIViewController __viewWillAppear:] + 118 frame #4: 0x0000000105a3e1d3 UIKit`-[UINavigationController _startCustomTransition:] + 1290 frame #5: 0x0000000105a4ee48 UIKit`-[UINavigationController _startDeferredTransitionIfNeeded:] + 697 frame #6: 0x0000000105a4ffdb UIKit`-[UINavigationController __viewWillLayoutSubviews] + 58 frame #7: 0x0000000105c46dd7 UIKit`-[UILayoutContainerView layoutSubviews] + 223 frame #8: 0x000000010592fab8 UIKit`-[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 1237 frame #9: 0x000000010555cbf8 QuartzCore`-[CALayer layoutSublayers] + 146 frame #10: 0x0000000105550440 QuartzCore`CA::Layer::layout_if_needed(CA::Transaction*) + 366 frame #11: 0x00000001055502be QuartzCore`CA::Layer::layout_and_display_if_needed(CA::Transaction*) + 24 frame #12: 0x00000001054de318 QuartzCore`CA::Context::commit_transaction(CA::Transaction*) + 280 frame #13: 0x000000010550b3ff QuartzCore`CA::Transaction::commit() + 475 frame #14: 0x000000010550bd6f QuartzCore`CA::Transaction::observer_callback(__CFRunLoopObserver*, unsigned long, void*) + 113 frame #15: 0x0000000107373267 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 23 frame #16: 0x00000001073731d7 CoreFoundation`__CFRunLoopDoObservers + 391 frame #17: 0x0000000107357f8e CoreFoundation`__CFRunLoopRun + 1198 frame #18: 0x0000000107357884 CoreFoundation`CFRunLoopRunSpecific + 420 frame #19: 0x000000010cce9a6f GraphicsServices`GSEventRunModal + 161 frame #20: 0x000000010586ac68 UIKit`UIApplicationMain + 159 frame #21: 0x0000000100c020bf the-master`main(argc=1, argv=0x00007fff5f45a690) + 111 at main.m:15 frame #22: 0x000000010ab9868d libdyld.dylib`start + 1 LLDB还为backtrace专门定义了一个别名：bt，他的效果与thread backtrace相同，如果你不想写那么长一串字母，直接写下bt即可: 12345678910111213141516171819202122232425(lldb) bt* thread #1: tid = 0x3551a, 0x0000000100b78933 the-master`-[HSTeamUnderwayOrderViewController setUpUI](self=0x00007fed0e66fed0, _cmd=&quot;setUpUI&quot;) + 1139 at HSTeamUnderwayOrderViewController.m:316, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 9.1 * frame #0: 0x0000000100b78933 the-master`-[HSTeamUnderwayOrderViewController setUpUI](self=0x00007fed0e66fed0, _cmd=&quot;setUpUI&quot;) + 1139 at HSTeamUnderwayOrderViewController.m:316 frame #1: 0x0000000100b75941 the-master`-[HSTeamUnderwayOrderViewController viewDidLoad](self=0x00007fed0e66fed0, _cmd=&quot;viewDidLoad&quot;) + 785 at HSTeamUnderwayOrderViewController.m:89 frame #2: 0x0000000105a0ca3d UIKit`-[UIViewController loadViewIfRequired] + 1258 frame #3: 0x0000000105a13062 UIKit`-[UIViewController __viewWillAppear:] + 118 frame #4: 0x0000000105a3e1d3 UIKit`-[UINavigationController _startCustomTransition:] + 1290 frame #5: 0x0000000105a4ee48 UIKit`-[UINavigationController _startDeferredTransitionIfNeeded:] + 697 frame #6: 0x0000000105a4ffdb UIKit`-[UINavigationController __viewWillLayoutSubviews] + 58 frame #7: 0x0000000105c46dd7 UIKit`-[UILayoutContainerView layoutSubviews] + 223 frame #8: 0x000000010592fab8 UIKit`-[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 1237 frame #9: 0x000000010555cbf8 QuartzCore`-[CALayer layoutSublayers] + 146 frame #10: 0x0000000105550440 QuartzCore`CA::Layer::layout_if_needed(CA::Transaction*) + 366 frame #11: 0x00000001055502be QuartzCore`CA::Layer::layout_and_display_if_needed(CA::Transaction*) + 24 frame #12: 0x00000001054de318 QuartzCore`CA::Context::commit_transaction(CA::Transaction*) + 280 frame #13: 0x000000010550b3ff QuartzCore`CA::Transaction::commit() + 475 frame #14: 0x000000010550bd6f QuartzCore`CA::Transaction::observer_callback(__CFRunLoopObserver*, unsigned long, void*) + 113 frame #15: 0x0000000107373267 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + 23 frame #16: 0x00000001073731d7 CoreFoundation`__CFRunLoopDoObservers + 391 frame #17: 0x0000000107357f8e CoreFoundation`__CFRunLoopRun + 1198 frame #18: 0x0000000107357884 CoreFoundation`CFRunLoopRunSpecific + 420 frame #19: 0x000000010cce9a6f GraphicsServices`GSEventRunModal + 161 frame #20: 0x000000010586ac68 UIKit`UIApplicationMain + 159 frame #21: 0x0000000100c020bf the-master`main(argc=1, argv=0x00007fff5f45a690) + 111 at main.m:15 frame #22: 0x000000010ab9868d libdyld.dylib`start + 1 thread returnDebug的时候，也许会因为各种原因，我们不想让代码执行某个方法，或者要直接返回一个想要的值。这时候就该thread return上场了。 12thread return [-x] -- [&lt;expr&gt;]thread return [&lt;expr&gt;] thread return可以接受一个表达式，调用命令之后直接从当前的frame返回表达式的值。 举例：我们有一个someMethod方法，默认情况下是返回YES。我们想要让他返回NO。我们只需在方法的开始位置加一个断点，当程序中断的时候，输入命令即可: 1(lldb) thread return NO 效果相当于在断点位置直接调用return NO;，不会执行断点后面的代码 c &amp; n &amp; s &amp; finish一般在调试程序的时候，我们经常用到下面这4个按钮： 用触摸板的孩子们可能会觉得点击这4个按钮比较费劲。其实LLDB命令也可以完成上面的操作，而且如果不输入命令，直接按Enter键，LLDB会自动执行上次的命令。按一下Enter就能达到我们想要的效果，有木有顿时感觉逼格满满的！！！ 我们来看看对应这4个按钮的LLDB命令： c/ continue/ thread continue: 这三个命令效果都等同于上图中第一个按钮的。表示程序继续运行 n/ next/ thread step-over: 这三个命令效果等同于上图第二个按钮。表示单步运行 s/ step/ thread step-in: 这三个命令效果等同于上图第三个按钮。表示进入某个方法 finish/ step-out: 这两个命令效果等同于第四个按钮。表示直接走完当前方法，返回到上层frame frame前面我们提到过很多次frame（帧）。可能有的朋友对frame这个概念还不太了解。随便打个断点. 我们在控制台上输入命令bt，可以打印出来所有的frame。如果仔细观察，这些frame和左边红框里的堆栈是一致的。平时我们看到的左边的堆栈就是frame。 frame variable平时Debug的时候我们经常做的事就是查看变量的值，通过frame variable命令，可以打印出当前frame的所有变量 1234(lldb) frame variable(HSTeamUnderwayOrderViewController *) self = 0x00007fed0e65a7a0(SEL) _cmd = &quot;setUpUI&quot;(NSInteger) selectedPage = 1 将self,_cmd,selectedPage 等本地变量都打印了出来 如果我们要需要打印指定变量，也可以给frame variable传入参数: 12(lldb) frame variable selectedPage(NSInteger) selectedPage = 1 不过frame variable只接受变量作为参数，不接受表达式，也就是说我们无法使用frame variable self.string，因为self.string是调用string的getter方法。所以一般打印指定变量，我更喜欢用p或者po。 其他不常用命令一般frame variable打印所有变量用得比较多，frame还有2个不怎么常用的命令： frame info: 查看当前frame的信息 12(lldb) frame infoframe #0: 0x0000000100b78933 the-master`-[HSTeamUnderwayOrderViewController setUpUI](self=0x00007fed0e65a7a0, _cmd=&quot;setUpUI&quot;) + 1139 at HSTeamUnderwayOrderViewController.m:316 frame select: 选择某个frame 123456789(lldb) frame select 1frame #1: 0x0000000100b75941 the-master`-[HSTeamUnderwayOrderViewController viewDidLoad](self=0x00007fed0e65a7a0, _cmd=&quot;viewDidLoad&quot;) + 785 at HSTeamUnderwayOrderViewController.m:89 86 orderContent = @&quot;0&quot;; 87 88 self.orderDateArray = @[@&quot;时间&quot;, @&quot;一个月&quot;,@&quot;三个月&quot;,@&quot;六个月&quot;,@&quot;一年&quot;];-&gt; 89 [self setUpUI]; 90 91 [self setupRefreshView]; 92 当我们选择frame 1的时候，他会把frame1的信息和代码打印出来。不过一般我都是直接在Xcode左边点击某个frame，这样更方便 breakpoint调试过程中，我们用得最多的可能就是断点了。LLDB中的断点命令也非常强大 breakpoint setbreakpoint set命令用于设置断点，LLDB提供了很多种设置断点的方式： 使用-n根据方法名设置断点： 12(lldb) breakpoint set -n searchBreakpoint 10: 43 locations. 使用-f指定文件 我们只给HSTeamUnderwayOrderViewController.m文件中的search方法加上断点。 12(lldb) breakpoint set -f HSTeamUnderwayOrderViewController.m -n searchBreakpoint 11: where = the-master`-[HSTeamUnderwayOrderViewController search] + 16 at HSTeamUnderwayOrderViewController.m:262, address = 0x0000000100b78180 这里需要注意，如果方法未写在文件中（比如写在category文件中，或者父类文件中），指定文件之后，将无法给这个方法设置断点。 使用-l指定文件某一行设置断点我们想给HSTeamUnderwayOrderViewController.m第38行设置断点 12(lldb) breakpoint set -f HSTeamUnderwayOrderViewController.m -l 286Breakpoint 13: where = the-master`-[HSTeamUnderwayOrderViewController setupRefreshView] + 20 at HSTeamUnderwayOrderViewController.m:288, address = 0x0000000100b783d4 使用-c设置条件断点 text:方法接受一个ret的参数，我们想让ret == YES的时候程序中断： 12(lldb) breakpoint set -n text: -c ret == YESBreakpoint 7: where = TLLDB`-[ViewController text:] + 30 at ViewController.m:37, address = 0x0000000105ef37ce 使用-o设置单次断点 如果刚刚那个断点我们只想让他中断一次： 123(lldb)breakpoint set -n text: -o&apos;breakpoint 3&apos;:where=TLLDB`-[ViewController text:]+30 at ViewController.m:37, address=0x000000010b6f97ce breakpoint command有的时候我们可能需要给断点添加一些命令，比如每次走到这个断点的时候，我们都需要打印self对象。我们只需要给断点添加一个po self命令，就不用每次执行断点再自己输入po self了 breakpoint command addbreakpoint command add命令就是给断点添加命令的命令。 假设我们需要在HSHomeViewController的getData中查看loginName(自己创建的一个NSString类型的变量)的值 我们首先给-[ViewController viewDidLoad]添加一个断点 12(lldb) breakpoint set -n &quot;-[HSHomeViewController getData]&quot;Breakpoint 2: where = the-master`-[HSHomeViewController getData] + 35 at HSHomeViewController.m:70, address = 0x00000001025fb263 可以看到添加成功之后，这个breakpoint的id为2，然后我们给他增加一个命令：po loginName 1(lldb) breakpoint command add -o &quot;po loginName&quot; -o完整写法是–one-liner，表示增加一条命令。2表示对id为2的breakpoint增加命令。 添加完命令之后，每次程序执行到这个断点就可以自动打印出loginName的值了 如果我们一下子想增加多条命令，比如我想在viewDidLoad中打印当前frame的所有变量，但是我们不想让他中断，也就是在打印完成之后，需要继续执行。我们可以这样玩： 12345(lldb) breakpoint command add 6Enter your debugger command(s). Type &apos;DONE&apos; to end.&gt; frame variable&gt; continue&gt; DONE 输入breakpoint command add 3对断点3增加命令。他会让你输入增加哪些命令，输入’DONE’表示结束。这时候你就可以输入多条命令了 多次对同一个断点添加命令，后面命令会将前面命令覆盖 breakpoint command list如果想查看某个断点已有的命令，可以使用breakpoint command list。 例如: 我们查看一下刚刚的断点6已有的命令 12345(lldb) breakpoint command list 6Breakpoint 6: Breakpoint commands: frame variable continue 可以看到一共有2条命令，分别为frame variable和continue breakpoint command delete有增加就有删除，breakpoint command delete可以让我们删除某个断点的命令。 例如: 我们将断点3中的命令删除: 123(lldb) breakpoint command delete 1(lldb) breakpoint command list 1Breakpoint 1 does not have an associated command.c 可以看到删除之后，断点1就没有命令了 breakpoint list如果我们想查看已经设置了哪些断点，可以使用breakpoint list 12345678910111213141516171819202122(lldb) breakpoint listCurrent breakpoints:1: name = &apos;-[HSHomeViewController getData]&apos;, locations = 1, resolved = 1, hit count = 3 1.1: where = the-master`-[HSHomeViewController getData] + 35 at HSHomeViewController.m:70, address = 0x000000010252d263, resolved, hit count = 3 2: name = &apos;-[HSSubTeamUnderwayOrderSearchViewController search]&apos;, locations = 0 (pending) Breakpoint commands: po self.view5: name = &apos;-[HSTeamUnderwayOrderViewController search]&apos;, locations = 1, resolved = 1, hit count = 2 Breakpoint commands: po self.view 5.1: where = the-master`-[HSTeamUnderwayOrderViewController search] + 16 at HSTeamUnderwayOrderViewController.m:262, address = 0x00000001024b7b40, resolved, hit count = 2 6: name = &apos;-[HSTeamUnderwayOrderViewController headerRereshing]&apos;, locations = 1, resolved = 1, hit count = 2 Breakpoint commands: frame variable continue 6.1: where = the-master`-[HSTeamUnderwayOrderViewController headerRereshing] + 27 at HSTeamUnderwayOrderViewController.m:267, address = 0x00000001024b7bfb, resolved, hit count = 2 breakpoint disable/enable有的时候我们可能暂时不想要某个断点，可以使用breakpoint disable让某个断点暂时失效。 例如: 我们来让刚刚的断点1失效 12(lldb) breakpoint disable 11 breakpoints disabled. 输入完命令之后，显示断点已经失效 当我们又需要这个断点的时候，可以使用breakpoint enable再次让他生效 例如: 重新启用断点1 12(lldb) breakpoint enable 11 breakpoints enabled. breakpoint delete如果我们觉得这个断点以后再也用不上了，可以用breakpoint delete直接删除断点. 例如: 删除断点1 12(lldb) breakpoint delete 11 breakpoints deleted; 0 breakpoint locations disabled. 如果我们想删除所有断点，只需要不指定breakpoint delete参数即可 123(lldb) breakpoint deleteAbout to delete all breakpoints, do you want to do that?: [Y/n] yAll breakpoints removed. (3 breakpoints) 删除的时候他会提示你，是不是真的想删除所有断点，需要你再次输入Y确认。如果想直接删除，不需要他的提示，使用-f命令选项即可 12(lldb) breakpoint delete -fAll breakpoints removed. (1 breakpoint) 实际平时我们真正使用breakpoint命令反而比较少，因为Xcode已经内置了断点工具。我们可以直接在代码上打断点，可以在断点工具栏里面查看编辑断点，这比使用LLDB命令方便很多。不过了解LLDB相关命令可以让我们对断点理解更深刻。 如果你想了解怎么使用Xcode设置断点，可以阅读这篇文章《Xcode中断点的威力》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS开发进阶-Runtime学习笔记]]></title>
      <url>%2F2017%2F02%2F27%2FiOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6-Runtime%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[Objective-C Runtime到底是什么东西？Objective-C Runtime是一个将C语言转化为面向对象语言的扩展。Objective-C是基于动态运行时类型，与静态类型的C++不一样。也就是说用C++编写的程序编译时就直接编译成了可令机器读懂的机器语言；用Objective-C编写的程序不能直接编译成可令机器读懂的机器语言，而是在程序运行的时候，通过Runtime把程序转为可令机器读懂的机器语言。Runtime是Objective不可缺少的重要一部分。 Objective-C的基本元素的认识1. id和Class打开/Runtime-/runtime/objc.h文件可以看到如下定义： 123456789101112#if !OBJC_TYPES_DEFINED/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class; /// Represents an instance of a class.struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;; /// A pointer to an instance of a class.typedef struct objc_object *id;#endif Class是一个指向objc_class结构体的指针，而id是一个指向objc_object结构体的指针，其中的isa是一个指向objc_class结构体的指针。其中的id就是我们所说的对象，Class就是我们所说的类。 PS:isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见官方文档 打开/Runtime-/runtime/runtime.h文件可以看到如下定义： 12345678910111213141516typedef struct objc_class *Class;struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY; // metaclass#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; // 父类 const char *name OBJC2_UNAVAILABLE; // 类名 long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0，可以通过runtime函数class_setVersion或者class_getVersion进行修改、读取 long info OBJC2_UNAVAILABLE; // 类信息，供运行时期使用的一些位标识，如CLS_CLASS (0x1L) 表示该类为普通 class，其中包含实例方法和变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法; long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小（包括从父类继承下来的实例变量） struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量地址列表 struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法地址列表，与 info 的一些标志位有关，如CLS_CLASS (0x1L)，则存储实例方法，如CLS_META (0x2L)，则存储类方法; struct objc_cache *cache OBJC2_UNAVAILABLE; // 缓存最近使用的方法地址，用于提升效率； struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 存储该类声明遵守的协议的列表#endif&#125;/* Use `Class` instead of `struct objc_class *` */ 由以上代码可见，类与对象的区别就是类比对象多了很多特征成员，类也可以当做一个objc_object来对待，也就是说类和对象都是对象，分别称作类对象（class object）和实例对象（instance object），这样我们就可以区别对象和类了。可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。 PS:OBJC2_UNAVAILABLE之类的宏定义是苹果在 Objc 中对系统运行版本进行约束的黑魔法，为的是兼容非Objective-C 2.0的遗留逻辑，但我们仍能从中获得一些有价值的信息，有兴趣的可以查看源代码。 在objc_class结构体中：ivars是objc_ivar_list指针；methodLists是指向objc_method_list指针的指针。也就是说可以动态修改*methodLists的值来添加成员方法，这也是Category实现的原理，同样解释了Category不能添加属性的原因。而最新版的 Runtime 源码对这一块的描述已经有很大变化，可以参考下美团技术团队的深入理解Objective-C：Category。 PS：任性的话可以在Category中添加@dynamic的属性，并利用运行期动态提供存取方法或干脆动态转发；或者干脆使用关联度对象（AssociatedObject） 不知道你是否注意到了objc_class中也有一个isa对象，这是因为一个 ObjC 类本身同时也是一个对象，为了处理类和对象的关系，runtime 库创建了一种叫做元类 (Meta Class) 的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。类方法就定义于此处，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。当你发出一个类似[NSObject alloc]的消息时，你事实上是把这个消息发给了一个类对象 (Class Object) ，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class) 的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 [NSObject alloc] 这条消息发给类对象的时候，objc_msgSend()会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。 isa：objc_object（实例对象）中isa指针指向的类结构称为class（也就是该对象所属的类）其中存放着普通成员变量与动态方法（“-”开头的方法）；此处isa指针指向的类结构称为metaclass，其中存放着static类型的成员变量与static类型的方法（“+”开头的方法）。 super_class： 指向该类的父类的指针，如果该类是根类（如NSObject或NSProxy），那么super_class就为nil。 类与对象的继承层次关系如图（图片源自网络）： 上图实线是 super_class 指针，虚线是isa指针。 有趣的是根元类的超类是NSObject，而isa指向了自己，而NSObject的超类为nil，也就是它没有超类。 所有的metaclass中isa指针都是指向根metaclass，而根metaclass则指向自身。根metaclass是通过继承根类产生的，与根class结构体成员一致，不同的是根metaclass的isa指针指向自身。 2. SELobjc_msgSend:的真身是这样的： 1id objc_msgSend ( id self, SEL op, ... ); objc_msgSend函数第二个参数类型为SEL，它是selector在Objc中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL: 1typedef struct objc_selector *SEL; 其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令@selector()或者 Runtime 系统的sel_registerName函数来获得一个SEL类型的方法选择器。不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(NSNumber一堆抽象工厂方法拿走不谢)，Cocoa 中有好多长长的方法哦。 objc_selector的定义如下： 1234struct objc_selector &#123; char *name; OBJC2_UNAVAILABLE;// 名称 char *types; OBJC2_UNAVAILABLE;// 类型&#125;; name和types都是char类型。 3. IMPIMP是“implementation”的缩写，它是由编译器生成的一个函数指针。当你发起一个消息后（下文介绍），这个函数指针决定了最终执行哪段代码。它的定义为： 1typedef id (*IMP)(id, SEL, ...); 它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。既然得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面会提到。你会发现IMP指向的方法与objc_msgSend函数类型相同，参数都包含id和SEL类型。每个方法名都对应一个SEL类型的方法选择器，而每个实例对象中的SEL对应的方法实现肯定是唯一的，通过一组id和SEL参数就能确定唯一的方法实现地址；反之亦然。 4. MethodMethod代表类中的某个方法的类型。1typedef struct objc_method *Method; objc_method的定义如下： 12345struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; // 方法名 char *method_types OBJC2_UNAVAILABLE; // 方法类型 IMP method_imp OBJC2_UNAVAILABLE; // 方法实现&#125; 方法名method_name类型为SEL，上文提到过。方法类型method_types是一个char指针，存储着方法的参数类型和返回值类型。方法实现method_imp的类型为IMP，上文提到过。 5. IvarIvar代表类中实例变量的类型 1typedef struct objc_ivar *Ivar; objc_ivar的定义如下： 12345678struct objc_ivar &#123; char *ivar_name OBJC2_UNAVAILABLE; // 变量名 char *ivar_type OBJC2_UNAVAILABLE; // 变量类型 int ivar_offset OBJC2_UNAVAILABLE; // 基地址偏移字节#ifdef __LP64__ int space OBJC2_UNAVAILABLE; // 占用空间#endif&#125; 可以根据实例查找其在类中的名字，也就是“反射”： 12345678910111213141516171819-(NSString *)nameWithInstance:(id)instance &#123; unsigned int numIvars = 0; NSString *key=nil; Ivar * ivars = class_copyIvarList([self class], &amp;numIvars); for(int i = 0; i &lt; numIvars; i++) &#123; Ivar thisIvar = ivars[i]; const char *type = ivar_getTypeEncoding(thisIvar); NSString *stringType = [NSString stringWithCString:type encoding:NSUTF8StringEncoding]; if (![stringType hasPrefix:@&quot;@&quot;]) &#123; continue; &#125; if ((object_getIvar(self, thisIvar) == instance)) &#123;//此处若 crash 不要慌！ key = [NSString stringWithUTF8String:ivar_getName(thisIvar)]; break; &#125; &#125; free(ivars); return key;&#125; class_copyIvarList 函数获取的不仅有实例变量，还有属性。但会在原本的属性名前加上一个下划线。 6. objc_property_tobjc_property_t是属性，它的定义如下： 1typedef struct objc_property *objc_property_t; objc_property是内置的类型，与之关联的还有一个objc_property_attribute_t，它是属性的attribute，也就是其实是对属性的详细描述，包括属性名称、属性编码类型、原子类型/非原子类型等。它的定义如下： 1234typedef struct &#123; const char *name; // 名称 const char *value; // 值（通常是空的）&#125; objc_property_attribute_t; 可以通过class_copyPropertyList 和 protocol_copyPropertyList方法来获取类和协议中的属性： 12objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount) 返回类型为指向指针的指针，哈哈，因为属性列表是个数组，每个元素内容都是一个objc_property_t指针，而这两个函数返回的值是指向这个数组的指针。 举个例子，先声明一个类： 12345@interface Lender : NSObject &#123; float alone;&#125;@property float alone;@end 用下面的代码获取属性列表： 12345id LenderClass = objc_getClass(&quot;Lender&quot;);unsigned int outCount;objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);@end 你可以用property_getName函数来查找属性名称： 1const char *property_getName(objc_property_t property) 你可以用class_getProperty 和 protocol_getProperty通过给出的名称来在类和协议中获取属性的引用： 12objc_property_t class_getProperty(Class cls, const char *name)objc_property_t protocol_getProperty(Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty) 你可以用property_getAttributes函数来发掘属性的名称和@encode类型字符串： 1const char *property_getAttributes(objc_property_t property) 把上面的代码放一起，你就能从一个类中获取它的属性啦： 1234567id LenderClass = objc_getClass(&quot;Lender&quot;);unsigned int outCount, i;objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);for (i = 0; i &lt; outCount; i++) &#123; objc_property_t property = properties[i]; fprintf(stdout, &quot;%s %s\n&quot;, property_getName(property), property_getAttributes(property));&#125; 对比下 class_copyIvarList 函数，使用 class_copyPropertyList 函数只能获取类的属性，而不包含成员变量。但此时获取的属性名是不带下划线的。 7. CacheCatch的定义如下： 1typedef struct objc_cache *Cache objc_cache的定义如下： 12345struct objc_cache &#123; unsigned int mask OBJC2_UNAVAILABLE; unsigned int occupied OBJC2_UNAVAILABLE; Method buckets[1] OBJC2_UNAVAILABLE;&#125;; Cache为方法调用的性能进行优化，通俗地讲，每当实例对象接收到一个消息时，它不会直接在isa指向的类的方法列表中遍历查找能够响应消息的方法，因为这样效率太低了，而是优先在Cache中查找。Runtime 系统会把被调用的方法存到Cache中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高。这根计算机组成原理中学过的 CPU 绕过主存先访问Cache的道理挺像，而我猜苹果为提高Cache命中率应该也做了努力吧。 mask: 指定分配cache buckets的总数。在方法查找中，Runtime使用这个字段确定数组的索引位置。 occupied: 实际占用cache buckets的总数。 buckets: 指定Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。 objc_msgSend（下文讲解）每调用一次方法后，就会把该方法缓存到cache列表中，下次的时候，就直接优先从cache列表中寻找，如果cache没有，才从methodLists中查找方法。 8. Catagory类别可以动态的为已存在的类添加新的方法。它的定义如下： 1typedef struct objc_category *Category; objc_category的定义如下： 1234567struct objc_category &#123; char *category_name OBJC2_UNAVAILABLE; // 类别名称 char *class_name OBJC2_UNAVAILABLE; // 类名 struct objc_method_list *instance_methods OBJC2_UNAVAILABLE; // 实例方法列表 struct objc_method_list *class_methods OBJC2_UNAVAILABLE; // 类方法列表 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议列表&#125; Objective-C的消息传递1. 基本消息传递面向对象编程中，对象调用方法叫做发送消息。在编译时，程序的源代码就会将对象发送消息转换成Runtime的objc_msgSend函数调用。 有关消息发送和消息转发机制的原理，可以查看这篇文章。 下面详细叙述下消息发送步骤： 检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain, release 这些函数了。 检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。 如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。 如果 cache 找不到就找一下方法分发表。 如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。 如果还找不到就要开始进入动态方法解析了，后面会提到。 PS:这里说的分发表其实就是Class中的方法列表，它将方法选择器和方法实现地址联系起来。 例如某实例变量receiver实现某一个方法oneMethod： 1[receiver oneMethod]; Runtime会将其转成类似这样的代码: 1objc_msgSend(receiver, selector); 如果消息有参数： 1objc_msgSend(receiver, selector, arg1, arg2, ...); 如果消息的接收者能够找到对应的selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个selector对应的实现内容，要么就干脆玩完崩溃掉。 Runtime会根据类型自动转换成下列某一个函数：objc_msgSend:普通的消息都会通过该函数发送;objc_msgSend_stret:消息中有数据结构作为返回值（不是简单值）时，通过此函数发送和接收返回值;objc_msgSendSuper:和objc_msgSend类似，这里把消息发送给父类的实例;objc_msgSendSuper_stret:和objc_msgSend_stret类似，这里把消息发送给父类的实例并接收返回值. 当消息被发送到实例对象时，是如图所示处理的（图片源自网络）： objc_msgSend函数的调用过程： 检测这个selector是不是要忽略的。 检测这个target是不是nil对象。nil对象发送任何一个消息都会被忽略掉。 调用实例方法时，它会首先在自身isa指针指向的类（class）methodLists中查找该方法，如果找不到则会通过class的super_class指针找到父类的类对象结构体，然后从methodLists中查找该方法，如果仍然找不到，则继续通过super_class向上一级父类结构体中查找，直至根class； 当我们调用某个类方法时，它会首先通过自己的isa指针找到metaclass，并从其中methodLists中查找该类方法，如果找不到则会通过metaclass的super_class指针找到父类的metaclass对象结构体，然后从methodLists中查找该方法，如果仍然找不到，则继续通过super_class向上一级父类结构体中查找，直至根metaclass； 前三部都找不到就会进入动态方法解析(看下文)。 2. 消息动态解析动态解析流程图（图片来自网络）： 请参照图片品味以下步骤（实例请看下文《Runtime demo6》）： 第一步：通过resolveInstanceMethod：方法决定是否动态添加方法。如果返回Yes则通过class_addMethod动态添加方法，消息得到处理，结束；如果返回No，则进入下一步； 第二步：这步会进入forwardingTargetForSelector:方法，用于指定备选对象响应这个selector，不能指定为self。如果返回某个对象则会调用对象的方法，结束。如果返回nil，则进入第三部； 第三步：这步我们要通过methodSignatureForSelector:方法签名，如果返回nil，则消息无法处理。如果返回methodSignature，则进入下一步； 第四步：这步调用forwardInvocation：方法，我们可以通过anInvocation对象做很多处理，比如修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果失败，则进入doesNotRecognizeSelector方法，若我们没有实现这个方法，那么就会crash。 Runtime实战1. Runtime 初识12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#import &quot;ViewController.h&quot;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // 动态创建对象 创建一个Person 继承自 NSObject类 Class People = objc_allocateClassPair([NSObject class], &quot;Person&quot;, 0); //为该类对象添加NSString *_name成员变量 class_addIvar(People, &quot;_name&quot;, sizeof(NSString*), sizeof(NSString*), @encode(NSString*)); class_addIvar(People, &quot;_age&quot;, sizeof(int), sizeof(int), @encode(int)); //注册一个叫say方法 SEL s = sel_registerName(&quot;say:&quot;); //为该类增加名为say的方法 class_addMethod(People, s , (IMP)sayFunction, &quot;v@:@&quot;); //注册该类 objc_registerClassPair(People); //创建一个了类的实例 id peopleInstance = [[People alloc] init]; //KVC 动态改变 对象peopleInstance 中的实例变量 [peopleInstance setValue:@&quot;Feyddy&quot; forKey:@&quot;name&quot;]; //从类中获取成员变量Ivar Ivar ageIvar = class_getInstanceVariable(People, &quot;_age&quot;); //为peopleInstance的成员变量赋值 object_setIvar(peopleInstance, ageIvar, @25); //调用 peopleInstance 对象中的 s 方法选择器对应的方法 objc_msgSend(peopleInstance, s, @&quot;大家好!&quot;); // 这样写也可以，请看我博客说明 /* //修改的方法有返回值就用IMP，无返回值就用VIMP typedef id (*_IMP) (id,SEL,...); typedef void (*_VIMP) (id,SEL,...); */ ((void (*)(id,SEL,id))objc_msgSend)(peopleInstance, s, @&quot;大家好&quot;); //当People类或者它的子类的实例还存在，则不能调用objc_disposeClassPair这个方法；因此这里要先销毁实例对象后才能销毁类； peopleInstance = nil; // 销毁类 objc_disposeClassPair(People);&#125;// 自定义一个方法void sayFunction(id self, SEL _cmd, id some) &#123; NSLog(@&quot;%@岁的%@说：%@&quot;, object_getIvar(self, class_getInstanceVariable([self class], &quot;_age&quot;)),[self valueForKey:@&quot;name&quot;],some);&#125;@end 最后的结果是: 122017-02-27 14:33:14.211 Runtime初识篇[9442:185921] 25岁的Feyddy说：大家好!2017-02-27 14:33:14.211 Runtime初识篇[9442:185921] 25岁的Feyddy说：大家好 在使用: 1objc_msgSend(peopleInstance, s, @&quot;大家好!&quot;); 默认会出现以下错误：objc_msgSend()报错Too many arguments to function call ,expected 0,have3直接通过objc_msgSend(self, setter, value)是报错，说参数过多。请这样解决：Build Setting–&gt; Apple LLVM 7.0 – Preprocessing–&gt; Enable Strict Checking of objc_msgSend Calls 改为 NO。当然你也可以这样写(推荐)： 1((void (*)(id, SEL, id))objc_msgSend)(peopleInstance, s, @&quot;大家好&quot;); 强制转换objc_msgSend函数类型为带三个参数且返回值为void函数，然后才能传三个参数。 此实战内容是，动态创建一个类，并创建成员变量和方法，最后赋值成员变量并发送消息。其中成员变量的赋值使用了KVC和object_setIvar函数两种方式，这些东西大家举一反三就可以了。 2. Runtime 特征下面我们来获取一下个人的相关信息： Person.h123456789101112131415#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject&#123; NSString *occupation; NSString *nationality;&#125;@property (nonatomic, copy) NSString *name;@property (nonatomic) NSUInteger age;- (NSDictionary *)allProperties;- (NSDictionary *)allIvars;- (NSDictionary *)allMethods;@end Person.m12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#import &quot;Person.h&quot;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif@implementation Person- (NSDictionary *)allProperties &#123; unsigned int count = 0; //获取类的所有属性，如果没有属性count就为0 objc_property_t *properties = class_copyPropertyList([self class], &amp;count); NSMutableDictionary *resultDict = [@&#123;&#125;mutableCopy]; for (NSUInteger i = 0; i &lt; count; i++) &#123; //获取属性的名称和值 const char *propertyName = property_getName(properties[i]); NSString *name = [NSString stringWithUTF8String:propertyName]; id propertyValue = [self valueForKey:name]; if (propertyValue) &#123; resultDict[name] = propertyValue; &#125;else&#123; resultDict[name] = @&quot;字典的key对应的value不能为nil哦！&quot;; &#125; &#125; //这里properties是一个数组指针，我们需要使用free函数来释放内存 free(properties); return resultDict;&#125;- (NSDictionary *)allIvars&#123; unsigned int count = 0; Ivar *ivars = class_copyIvarList([self class], &amp;count); NSMutableDictionary *resultDict = [@&#123;&#125; mutableCopy]; for (NSUInteger i = 0; i &lt; count; i ++) &#123; const char *varName = ivar_getName(ivars[i]); NSString *name = [NSString stringWithUTF8String:varName]; id varValue = [self valueForKey:name]; if (varValue) &#123; resultDict[name] = varValue; &#125; else &#123; resultDict[name] = @&quot;字典的key对应的value不能为nil哦！&quot;; &#125; &#125; free(ivars); return resultDict;&#125;- (NSDictionary *)allMethods&#123; unsigned int count = 0; // 获取类的所有方法，如果没有方法count就为0 Method *methods = class_copyMethodList([self class], &amp;count); NSMutableDictionary *resultDict = [@&#123;&#125; mutableCopy]; for (NSUInteger i = 0; i &lt; count; i ++) &#123; // 获取方法名称 SEL methodSEL = method_getName(methods[i]); const char *methodName = sel_getName(methodSEL); NSString *name = [NSString stringWithUTF8String:methodName]; // 获取方法的参数列表 int arguments = method_getNumberOfArguments(methods[i]); resultDict[name] = @(arguments-2); &#125; free(methods); return resultDict;&#125;@end ViewController.m123456789101112131415161718192021222324252627282930313233343536373839404142#import &quot;ViewController.h&quot;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif#import &quot;Person.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; Person *feyddy = [[Person alloc] init]; feyddy.name = @&quot;Feyddy&quot;; feyddy.age = 25; [feyddy setValue:@&quot;ios developer&quot; forKey:@&quot;occupation&quot;]; NSDictionary *propertiesResultDict = [feyddy allProperties]; for (NSString *propertyName in propertiesResultDict.allKeys) &#123; NSLog(@&quot;propertyName:%@, propertyValue:%@&quot;,propertyName, propertiesResultDict[propertyName]); &#125; NSDictionary *ivarResultDic = [feyddy allIvars]; for (NSString *ivarName in ivarResultDic.allKeys) &#123; NSLog(@&quot;ivarName:%@, ivarValue:%@&quot;,ivarName, ivarResultDic[ivarName]); &#125; NSDictionary *methodResultDic = [feyddy allMethods]; for (NSString *methodName in methodResultDic.allKeys) &#123; NSLog(@&quot;methodName:%@, argumentsCount:%@&quot;, methodName, methodResultDic[methodName]); &#125;&#125;@end 结果： 12345678910111213142017-02-27 14:57:38.049 Runtime 特征篇[9914:198137] propertyName:name, propertyValue:Feyddy2017-02-27 14:57:38.049 Runtime 特征篇[9914:198137] propertyName:age, propertyValue:252017-02-27 14:57:38.050 Runtime 特征篇[9914:198137] ivarName:_name, ivarValue:Feyddy2017-02-27 14:57:38.051 Runtime 特征篇[9914:198137] ivarName:nationality, ivarValue:字典的key对应的value不能为nil哦！2017-02-27 14:57:38.051 Runtime 特征篇[9914:198137] ivarName:_age, ivarValue:252017-02-27 14:57:38.051 Runtime 特征篇[9914:198137] ivarName:occupation, ivarValue:ios developer2017-02-27 14:57:38.052 Runtime 特征篇[9914:198137] methodName:name, argumentsCount:02017-02-27 14:57:38.052 Runtime 特征篇[9914:198137] methodName:setName:, argumentsCount:12017-02-27 14:57:38.053 Runtime 特征篇[9914:198137] methodName:allIvars, argumentsCount:02017-02-27 14:57:38.053 Runtime 特征篇[9914:198137] methodName:age, argumentsCount:02017-02-27 14:57:38.054 Runtime 特征篇[9914:198137] methodName:allMethods, argumentsCount:02017-02-27 14:57:38.054 Runtime 特征篇[9914:198137] methodName:setAge:, argumentsCount:12017-02-27 14:57:38.054 Runtime 特征篇[9914:198137] methodName:allProperties, argumentsCount:02017-02-27 14:57:38.055 Runtime 特征篇[9914:198137] methodName:.cxx_destruct, argumentsCount:0 学习点：如何获取对象所有的属性名称和属性值、获取对象所有成员变量名称和变量值、获取对象所有的方法名和方法参数数量。 3. Runtime 增加新技能篇通过Category和Associated Objects增加技能Person+Associated.h 1234567#import &quot;Person.h&quot;typedef void (^CodingCallBack)();@interface Person (Associated)@property (nonatomic, strong) NSNumber *associatedHeight; // 胸围@property (nonatomic, copy) CodingCallBack associatedCallBack; // 写代码@end Person+Associated.m 123456789101112131415161718192021222324252627282930#import &quot;Person+Associated.h&quot;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif@implementation Person (Associated)- (void)setAssociatedHeight:(NSNumber *)associatedHeight&#123; //设置关联对象 objc_setAssociatedObject(self, @selector(associatedHeight), associatedHeight, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125;- (NSNumber *)associatedHeight &#123; //得到关联对象 return objc_getAssociatedObject(self, @selector(associatedHeight));&#125;- (void)setAssociatedCallBack:(CodingCallBack)associatedCallBack &#123; objc_setAssociatedObject(self, @selector(associatedCallBack), associatedCallBack, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;- (CodingCallBack)associatedCallBack &#123; return objc_getAssociatedObject(self, @selector(associatedCallBack));&#125;@end ViewController.m 12345678910111213141516171819202122232425262728293031323334353637#import &quot;ViewController.h&quot;#import &quot;Person.h&quot;#import &quot;Person+Associated.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; Person *feyddy = [[Person alloc] init]; feyddy.name = @&quot;Feyddy&quot;; feyddy.age = 25; [feyddy setValue:@&quot;ios developer&quot; forKey:@&quot;occupation&quot;]; feyddy.associatedHeight = @175; feyddy.associatedCallBack = ^()&#123; NSLog(@&quot;Feyddy正在写代码~&quot;); &#125;; feyddy.associatedCallBack(); NSDictionary *propertyResultDict = [feyddy allProperties]; for (NSString *propertyName in propertyResultDict.allKeys) &#123; NSLog(@&quot;propertyName:%@, propertyValue:%@&quot;,propertyName, propertyResultDict[propertyName]); &#125; NSDictionary *methodResultDic = [feyddy allMethods]; for (NSString *methodName in methodResultDic.allKeys) &#123; NSLog(@&quot;methodName:%@, argumentsCount:%@&quot;, methodName, methodResultDic[methodName]); &#125;&#125;@end 运行结果多了加上去的属性和回调 12345678910111213141516172017-02-27 15:25:20.995 Runtime增加新技能篇[10457:210981] Feyddy正在写代码~2017-02-27 15:25:20.995 Runtime增加新技能篇[10457:210981] propertyName:associatedHeight, propertyValue:1752017-02-27 15:25:20.995 Runtime增加新技能篇[10457:210981] propertyName:age, propertyValue:252017-02-27 15:25:20.996 Runtime增加新技能篇[10457:210981] propertyName:associatedCallBack, propertyValue:&lt;__NSGlobalBlock__: 0x10b1ee130&gt;2017-02-27 15:25:20.996 Runtime增加新技能篇[10457:210981] propertyName:name, propertyValue:Feyddy2017-02-27 15:25:20.996 Runtime增加新技能篇[10457:210981] methodName:age, argumentsCount:02017-02-27 15:25:20.996 Runtime增加新技能篇[10457:210981] methodName:setAssociatedHeight:, argumentsCount:12017-02-27 15:25:20.996 Runtime增加新技能篇[10457:210981] methodName:allProperties, argumentsCount:02017-02-27 15:25:20.996 Runtime增加新技能篇[10457:210981] methodName:associatedHeight, argumentsCount:02017-02-27 15:25:20.997 Runtime增加新技能篇[10457:210981] methodName:associatedCallBack, argumentsCount:02017-02-27 15:25:20.997 Runtime增加新技能篇[10457:210981] methodName:allMethods, argumentsCount:02017-02-27 15:25:20.997 Runtime增加新技能篇[10457:210981] methodName:.cxx_destruct, argumentsCount:02017-02-27 15:25:21.036 Runtime增加新技能篇[10457:210981] methodName:setName:, argumentsCount:12017-02-27 15:25:21.036 Runtime增加新技能篇[10457:210981] methodName:setAssociatedCallBack:, argumentsCount:12017-02-27 15:25:21.036 Runtime增加新技能篇[10457:210981] methodName:allIvars, argumentsCount:02017-02-27 15:25:21.037 Runtime增加新技能篇[10457:210981] methodName:name, argumentsCount:02017-02-27 15:25:21.037 Runtime增加新技能篇[10457:210981] methodName:setAge:, argumentsCount:1 我们平时在开发过程中用的比较多的就是添加回调了。 4. Runtime 资料归档篇Person.h 12345678#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject&lt;NSCoding&gt;@property (nonatomic, copy) NSString *name; // 姓名@property (nonatomic, strong) NSNumber *age; // 年龄@property (nonatomic, copy) NSString *occupation; // 职业@property (nonatomic, copy) NSString *nationality; // 国籍@end Person.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#import &quot;Person.h&quot;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif@implementation Person- (void)encodeWithCoder:(NSCoder *)aCoder&#123; unsigned int count = 0; Ivar *ivars = class_copyIvarList([self class], &amp;count); for (int i = 0; i &lt; count; i++) &#123; Ivar ivar = ivars[i]; const char *name = ivar_getName(ivar); NSString *key = [NSString stringWithUTF8String:name]; id value = [self valueForKey:key]; [aCoder encodeObject:value forKey:key]; &#125; free(ivars);&#125;- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123; self = [super init]; if ( self) &#123; unsigned int count = 0; Ivar *ivars = class_copyIvarList([self class], &amp;count); for (int i = 0; i &lt; count; i++) &#123; Ivar ivar = ivars[i]; const char *name = ivar_getName(ivar); NSString *key = [NSString stringWithUTF8String:name]; id value = [aDecoder decodeObjectForKey:key]; [self setValue:value forKey:key]; &#125; free(ivars); &#125; return self;&#125;@end 5. Runtime 资料转换篇服务器返回了大量苍老师的数据，当然是要将JSON转换为Model啦！相信平时你们的项目中也用到过这些三方库，下面我们去了解下runtime实现JSON和Model互转。 Person.h 1234567891011121314#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@property (nonatomic, copy) NSString *name; // 姓名@property (nonatomic, strong) NSNumber *age; // 年龄@property (nonatomic, copy) NSString *occupation; // 职业@property (nonatomic, copy) NSString *nationality; // 国籍// 生成model- (instancetype)initWithDictionary:(NSDictionary *)dictionary;// 转换成字典- (NSDictionary *)covertToDictionary;@end Person.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#import &quot;Person.h&quot;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif@implementation Person- (instancetype)initWithDictionary:(NSDictionary *)dictionary &#123; self = [super init]; if (self) &#123; for (NSString *key in dictionary.allKeys) &#123; id value = dictionary[key]; SEL setter = [self propertySetterByKey:key]; if (setter) &#123; // 这里还可以使用NSInvocation或者method_invoke，不再继续深究了，有兴趣google。 ((void (*)(id, SEL, id))objc_msgSend)(self, setter, value); &#125; &#125; &#125; return self;&#125;- (NSDictionary *)covertToDictionary &#123; unsigned int count = 0; objc_property_t *properties = class_copyPropertyList([self class], &amp;count); if (count !=0) &#123; NSMutableDictionary *resultDict = [@&#123;&#125; mutableCopy]; for (int i = 0; i &lt; count; i++) &#123; const void *propertyName = property_getName(properties[i]); NSString *name = [NSString stringWithUTF8String:propertyName]; SEL getter = [self propertyGetterByKey:name]; if (getter) &#123; id value = ((id (*)(id, SEL))objc_msgSend)(self, getter); if (value) &#123; resultDict[name] = value; &#125; else &#123; resultDict[name] = @&quot;字典的key对应的value不能为nil哦！&quot;; &#125; &#125; &#125; free(properties); return resultDict; &#125; free(properties); return nil;&#125;#pragma mark - private methods//生成setter方法- (SEL)propertySetterByKey:(NSString *)key &#123; //首字母大写 NSString *propertySetterName = [NSString stringWithFormat:@&quot;set%@:&quot;,key.capitalizedString]; SEL setter = NSSelectorFromString(propertySetterName); if ([self respondsToSelector:setter]) &#123; return setter; &#125; return nil;&#125;//生成getter方法- (SEL)propertyGetterByKey:(NSString *)key &#123; SEL getter = NSSelectorFromString(key); if ([self respondsToSelector:getter]) &#123; return getter; &#125; return nil;&#125;@end ViewController.m 1234567891011121314151617181920212223242526272829303132333435#import &quot;ViewController.h&quot;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif#import &quot;Person.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSDictionary *dict = @&#123; @&quot;name&quot; : @&quot;Feyddy&quot;, @&quot;age&quot; : @25, @&quot;occupation&quot; : @&quot;ios developer&quot;, @&quot;nationality&quot; : @&quot;China&quot; &#125;; // 字典转模型 Person *feyddy = [[Person alloc] initWithDictionary:dict]; NSLog(@&quot;热烈欢迎，从%@远道而来的%@岁的%@%@&quot;,feyddy.nationality,feyddy.age,feyddy.name,feyddy.occupation); // 模型转字典 NSDictionary *covertedDict = [feyddy covertToDictionary]; NSLog(@&quot;%@&quot;,covertedDict);&#125;@end 运行结果为： 12345672017-02-27 16:08:36.218 Runtime 资料转换篇[11340:233515] 热烈欢迎，从China远道而来的18岁的Feyddyios developer2017-02-27 16:08:36.219 Runtime 资料转换篇[11340:233515] &#123; age = 18; name = Feyddy; nationality = China; occupation = &quot;ios developer&quot;;&#125; 把假设是网络返回的苍老师的资料转化为了model，然后又将model转回字典。 6. Runtime 消息动态解析篇6.1 添加eat实例方法，但是不提供方法的实现。验证当找不到方法的实现时，动态添加方法。 创建Person.h 1234567#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@property (nonatomic, copy) NSString *name;- (void)eat;@end 创建Person.m 123456789101112131415161718192021222324#import &quot;Person.h&quot;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif@implementation Person+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; //我们没有给Person类实现eat方法，我们这里动态添加方法 if ([NSStringFromSelector(sel) isEqualToString:@&quot;eat&quot;]) &#123; class_addMethod(self, sel, (IMP)otherEat, &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;void otherEat(id self, SEL cmd) &#123; NSLog(@&quot;%@正在吃代码！！！&quot;,((Person *)self).name);&#125;@end ViewController.m 123456789101112131415161718192021222324#import &quot;ViewController.h&quot;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif#import &quot;Person.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; Person *feyddy = [[Person alloc] init]; feyddy.name = @&quot;Feyddy&quot;; [feyddy eat];&#125;@end 运行结果： 12017-02-27 16:26:08.839 Runtime 消息动态解析篇[11676:241741] Feyddy正在吃代码！！！ 我们没有提供Feyddy吃的方法实现，因此在调用此方法的时候，会调用resolveInstanceMethod方法，我们动态添加了方法。我们也可以返回No，继续向下传递。 6.2 这里我们不声明eat方法，将调用途中动态更换调用对象。在上面代码的基础上，创建Animal的model. Animal.h 12345#import &lt;Foundation/Foundation.h&gt;@interface Animal : NSObject@property (nonatomic, copy) NSString *name;@end Animal.m 1234567891011121314151617181920212223242526272829303132333435#import &quot;Animal.h&quot;#import &quot;Person.h&quot;@implementation Animal// 第一步：我们不动态添加方法，返回NO，进入第二步；+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; return NO;&#125;// 第二步：我们不指定备选对象响应aSelector，进入第三步；- (id)forwardingTargetForSelector:(SEL)aSelector&#123; return nil;&#125;// 第三步：返回方法选择器，然后进入第四步；- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;eat&quot;]) &#123; return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;]; &#125; return [super methodSignatureForSelector:aSelector];&#125;// 第四步：这步我们修改调用对象- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; // 我们改变调用对象为People Person *feyddy = [[Person alloc] init]; feyddy.name = @&quot;Feyddy&quot;; [anInvocation invokeWithTarget:feyddy];&#125;@end ViewController.m 12345678910111213141516171819202122232425#import &quot;ViewController.h&quot;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif#import &quot;Person.h&quot;#import &quot;Animal.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; Animal *animal = [[Animal alloc] init]; animal.name = @&quot;老鹰&quot;; ((void (*)(id, SEL))objc_msgSend)((id)animal, @selector(eat));&#125;@end 运行结果： 12017-02-27 16:38:16.859 Runtime 消息动态解析篇[11983:249378] Feyddy正在吃代码！！！ 成功更换了对象，把对象更换为feyddy了。 6.3这里我是实现但是不提供声明，不修改调用对象，但是将sing方法修改为dance方法。 Person.h 12345#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@end Person.m 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#import &quot;Person.h&quot;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif@implementation Person// 第一步：我们不动态添加方法，返回NO，进入第二步；+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; return NO;&#125;// 第二部：我们不指定备选对象响应aSelector，进入第三步；- (id)forwardingTargetForSelector:(SEL)aSelector&#123; return nil;&#125;// 第三步：返回方法选择器，然后进入第四部；- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;eat&quot;]) &#123; return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;]; &#125; return [super methodSignatureForSelector:aSelector];&#125;// 第四部：这步我们修改调用方法- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; [anInvocation setSelector:@selector(dance)]; // 这还要指定是哪个对象的方法 [anInvocation invokeWithTarget:self];&#125;// 若forwardInvocation没有实现，则会调用此方法- (void)doesNotRecognizeSelector:(SEL)aSelector&#123; NSLog(@&quot;消息无法处理：%@&quot;, NSStringFromSelector(aSelector));&#125;- (void)dance&#123; NSLog(@&quot;跳舞！！！come on！&quot;);&#125;@end ViewController.m 123456789101112131415161718192021222324#import &quot;ViewController.h&quot;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif#import &quot;Person.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; Person *feyddy = [[Person alloc] init]; ((void(*)(id, SEL)) objc_msgSend)((id)feyddy, @selector(eat)); &#125;@end 运行结果： 12017-02-27 16:44:43.190 Runtime 消息动态解析篇（二）[12150:253339] 跳舞！！！come on！ 成功更换了方法。 总结看完上面的相关学习和demo，我们来总结一下Runtime的一些知识。 与Runtime交互Objc 从三种不同的层级上与 Runtime 系统进行交互，分别是通过 Objective-C 源代码，通过 Foundation 框架的NSObject类定义的方法，通过对 runtime 函数的直接调用。 Objective-C源代码大部分情况下你就只管写你的Objc代码就行，runtime 系统自动在幕后辛勤劳作着。还记得引言中举的例子吧，消息的执行会使用到一些编译器为实现动态语言特性而创建的数据结构和函数，Objc中的类、方法和协议等在 runtime 中都由一些数据结构来定义，这些内容在后面会讲到。（比如objc_msgSend函数及其参数列表中的id和SEL都是啥） NSObject的方法Cocoa 中大多数类都继承于NSObject类，也就自然继承了它的方法。最特殊的例外是NSProxy，它是个抽象超类，它实现了一些消息转发有关的方法，可以通过继承它来实现一个其他类的替身类或是虚拟出一个不存在的类，说白了就是领导把自己展现给大家风光无限，但是把活儿都交给幕后小弟去干。有的NSObject中的方法起到了抽象接口的作用，比如description方法需要你重载它并为你定义的类提供描述内容。NSObject还有些方法能在运行时获得类的信息，并检查一些特性，比如class返回对象的类；isKindOfClass:和isMemberOfClass:则检查对象是否在指定的类继承体系中；respondsToSelector:检查对象能否响应指定的消息；conformsToProtocol:检查对象是否实现了指定协议类的方法；methodForSelector:则返回指定方法实现的地址。 Runtime的函数Runtime 系统是一个由一系列函数和数据结构组成，具有公共接口的动态共享库。头文件存放于/usr/include/objc目录下。许多函数允许你用纯C代码来重复实现 Objc 中同样的功能。虽然有一些方法构成了NSObject类的基础，但是你在写 Objc 代码时一般不会直接用到这些函数的，除非是写一些 Objc 与其他语言的桥接或是底层的debug工作。在Objective-C Runtime Reference中有对 Runtime 函数的详细文档。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git命令及Github项目部署(一)]]></title>
      <url>%2F2017%2F02%2F25%2FGit%E5%91%BD%E4%BB%A4%E5%8F%8AGithub%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%2F</url>
      <content type="text"><![CDATA[Git简介Git是目前世界上最先进的分布式版本控制系统。 与Git相对的就是SVN，它是集中式。 集中式vs分布式：集中式：集中式版本控制系统最大的毛病就是必须联网才能工作。那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 分布式：和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 安装Git本文只介绍MAC上的安装。在MAC上安装git有两种方式。 是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。 第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 安装完成后，还需要最后一步设置，在命令行输入： 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 创建版本库(repository)你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 先找一个地方创建空目录：12345$ cd ~/desktop$ mkdir TestRepository$ cd TestRepository$ pwd/Users/t3/desktop/TestRepository cd ~/desktop：进入桌面目录下； mkdir TestRepository：创建一个空的仓库； cd TestRepository：进入仓库目录； pwd：命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/t3/desktop/TestRepository。 通过git init命令把这个目录变成Git可以管理的仓库：12$ git initInitialized empty Git repository in /Users/t3/Desktop/TestRepository/.git/ 此时，我们就创建了一个空的仓库。此时可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见 12$ ls -ah. .. .git 当然，不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。 把文件添加到版本库首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的。 因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 （这里以iOS项目为例） 创建一个项目(TestRepositoryDemo),里面的ViewController.swift里面添上下面的代码：12345override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. print("我是版本一") &#125; 一定要放到repository目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 用命令git add .告诉Git，把本目录下的文件添加到Git仓库。 1$ git add . 用命令git commit告诉Git，把文件提交到仓库： 123 $ git commit -m &quot;第一次提交版本一&quot;[master (root-commit) d47e787] 第一次提交版本一 15 files changed, 993 insertions(+) git commit：命令执行成功后会告诉你，15个文件被改动，插入了993行内容； -m &quot;&quot;：后面输入的是本次提交的说明； 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：123$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot; 注意：如果修改的文件放在子目录里面的时候，记得一定要先进入这个子目录，然后才能git add .,否则会出错的。 查看修改内容和当前仓库状态首先我们先提交多个版本的项目，分别在代码中添加： 1234567override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. print("我是版本一") print("我是版本二") print("我是版本三") &#125; 运行git status命令看看结果: 12345678910$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: TestRepositoryDemo/TestRepositoryDemo.xcodeproj/project.xcworkspace/xcuserdata/t3.xcuserdatad/UserInterfaceState.xcuserstate modified: TestRepositoryDemo/TestRepositoryDemo/ViewController.swiftno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) git status命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，我们项目被修改过了，但还没有准备提交的修改。我们还可以用git diff看看，我们修改的什么内容：1234567891011121314$ git diffdiff --git a/TestRepositoryDemo/TestRepositoryDemo/ViewController.swift b/TestRepositoryDemo/TestRepositoryDemo/ViewController.swiftindex e90c82d..6d60f42 100644--- a/TestRepositoryDemo/TestRepositoryDemo/ViewController.swift+++ b/TestRepositoryDemo/TestRepositoryDemo/ViewController.swift@@ -15,6 +15,7 @@ class ViewController: UIViewController &#123; // Do any additional setup after loading the view, typically from a nib. print(&quot;我是版本一&quot;) print(&quot;我是版本二&quot;)+ print(&quot;我是版本三&quot;) &#125; override func didReceiveMemoryWarning() &#123;: git diff就是查看与上一次提交的版本不一样的地方，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第15行添加了个print(&quot;我是版本三&quot;)。 然后按Ctrl+Z退出当前命令。 接下来，我们在把它提交到仓库。命令还是git add .和git commit -m &quot;&quot;。 当然，我们也可以在git commit -m &quot;&quot;之前git status一下，看看当前仓库的状态。 1234567891011121314$ git add .$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: TestRepositoryDemo/TestRepositoryDemo.xcodeproj/project.xcworkspace/xcuserdata/t3.xcuserdatad/UserInterfaceState.xcuserstate modified: TestRepositoryDemo/TestRepositoryDemo/ViewController.swift$ git commit -m &quot;版本第三次提交&quot;[master a04e162] 版本第三次提交 2 files changed, 1 insertion(+)$ git statusOn branch masternothing to commit, working directory clean 到此我们就已经提交了新的版本了。 注意：有的时候git status，新的内容一直是红色的，这个时候你可以cd到修改文件的目录下去，这样的话，可以解决该问题: 123456$ lsTestRepositoryDemo$ ls -ah. .DS_Store TestRepositoryDemo.. .gitcd TestRepositoryDemo 版本回退用git log命令显示从最近到最远的提交日志，即查看提交的历史记录： 123456789101112131415161718$ git logcommit a04e1629680d76333bf5c62eb1393772d6b80654Author: Feyddy &lt;Feyddyxu@163.com&gt;Date: Sat Feb 25 11:34:56 2017 +0800 版本第三次提交commit c557e1c93f1ddbe75a59e31d8280954da39ea031Author: Feyddy &lt;Feyddyxu@163.com&gt;Date: Sat Feb 25 11:22:03 2017 +0800 提交第二次版本commit d47e787ad8bf3f8e122f0fa4e0ca153fd26b481bAuthor: Feyddy &lt;Feyddyxu@163.com&gt;Date: Sat Feb 25 11:13:24 2017 +0800 第一次提交版本一 最近的一次是版本第三次提交，上一次是提交第二次版本，最早的一次是第一次提交版本一。 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： 1234$ git log --pretty=onelinea04e1629680d76333bf5c62eb1393772d6b80654 版本第三次提交c557e1c93f1ddbe75a59e31d8280954da39ea031 提交第二次版本d47e787ad8bf3f8e122f0fa4e0ca153fd26b481b 第一次提交版本一 其中一大串的数字和字符组成的是commit id（版本号）. 说了这么多，终于到我们的重点，版本的回退首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164...882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 回退版本的命令可以使用git reset 12$ git reset --hard HEAD^HEAD is now at c557e1c 提交第二次版本 这样你的项目就变成了只有版本二的内容了，版本三的内容就没有了。 此时我们可以用git log看到下面没了版本三的提交记录： 123456789101112$ git logcommit c557e1c93f1ddbe75a59e31d8280954da39ea031Author: Feyddy &lt;Feyddyxu@163.com&gt;Date: Sat Feb 25 11:22:03 2017 +0800 提交第二次版本commit d47e787ad8bf3f8e122f0fa4e0ca153fd26b481bAuthor: Feyddy &lt;Feyddyxu@163.com&gt;Date: Sat Feb 25 11:13:24 2017 +0800 第一次提交版本一 到这里，又有了一个新的问题，如果感觉版本三的内容是正确的，又不想回退了。怎么办？ 没关系，可以的。但是必须记住那个版本的commit id。否则没戏。 12$ git reset --hard a04e1629HEAD is now at a04e162 版本第三次提交 版本号没必要写全，前几位就可以了，Git会自动去找此时，项目又回到了版本三的代码。 内部原理其实很简单：因为Git在内部有个指向当前版本的HEAD指针，所以你让HEAD指向哪个版本号，你就把当前版本定位在哪,然后顺便把工作区的文件更新了。 但是如果没记住第三次的版本号的话，怎么回退呢？ 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到第二次的版本号时，再想恢复到第三次的版本号，就必须找到第三次的版本号的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： 12345678910111213141516171819$ git logcommit c557e1c93f1ddbe75a59e31d8280954da39ea031Author: Feyddy &lt;Feyddyxu@163.com&gt;Date: Sat Feb 25 11:22:03 2017 +0800 提交第二次版本commit d47e787ad8bf3f8e122f0fa4e0ca153fd26b481bAuthor: Feyddy &lt;Feyddyxu@163.com&gt;Date: Sat Feb 25 11:13:24 2017 +0800 第一次提交版本一xuzhonglindeMac-mini:TestRepository t3$ git reflogc557e1c HEAD@&#123;0&#125;: reset: moving to HEAD^a04e162 HEAD@&#123;1&#125;: reset: moving to a04e1629c557e1c HEAD@&#123;2&#125;: reset: moving to HEAD^a04e162 HEAD@&#123;3&#125;: commit: 版本第三次提交c557e1c HEAD@&#123;4&#125;: commit: 提交第二次版本d47e787 HEAD@&#123;5&#125;: commit (initial): 第一次提交版本一 这样不就看到了吗？是不是很强大。 工作区和暂存区工作区工作区就是电脑里面能看到的目录，比如我的TestRepository文件夹。 版本库工作区有个隐藏的目录.git，这个不算是工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 git add：就是把文件修改添加到暂存区；git commit：就是把暂存区的所有内容提交到当前分支可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 下面进行实践检验整理：我们先对项目进行修改，增加print(&quot;我是版本四&quot;),然后在工作区域增加一个文件，这里我随便写了一个main.js文件。 123456789101112131415$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: TestRepositoryDemo/TestRepositoryDemo.xcodeproj/project.xcworkspace/xcuserdata/t3.xcuserdatad/UserInterfaceState.xcuserstate modified: TestRepositoryDemo/TestRepositoryDemo/ViewController.swiftUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) main.jsno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Git非常清楚地告诉我们，TestRepositoryDemo被修改了，而main.js还从来没有被添加过，所以它的状态是Untracked。 现在，使用两次命令git add，把项目和main.js都添加后，用git status再查看一下： 123456789$ git add .$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: TestRepositoryDemo/TestRepositoryDemo.xcodeproj/project.xcworkspace/xcuserdata/t3.xcuserdatad/UserInterfaceState.xcuserstate modified: TestRepositoryDemo/TestRepositoryDemo/ViewController.swift new file: main.js 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 1234567$ git commit -m&quot;暂存区的介绍&quot;[master dc9ebfc] 暂存区的介绍 3 files changed, 23 insertions(+) create mode 100644 main.js$ git statusOn branch masternothing to commit, working directory clean 删除文件一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了;Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了; 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit.现在，文件就从版本库中被删除了。另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本。$ git checkout -- test.txt。 git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 远程仓库添加远程库首先在github上创建一个空的仓库TestRepository.GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。在本地的TestRepository仓库下运行命令：1234567891011$ git remote add repositoryName https://github.com/Feyddy/TestRepository.git$ git push -u repositoryName masterCounting objects: 79, done.Delta compression using up to 4 threads.Compressing objects: 100% (66/66), done.Writing objects: 100% (79/79), 31.55 KiB | 0 bytes/s, done.Total 79 (delta 20), reused 0 (delta 0)remote: Resolving deltas: 100% (20/20), done.To https://github.com/Feyddy/TestRepository.git * [new branch] master -&gt; masterBranch master set up to track remote branch master from repositoryName. 这里对一些出现的东西简单的说明一下: 1https://github.com/Feyddy/TestRepository.git 这里的地址可以再github仓库上直接粘贴过来。当然也可以用SSH的方法进行远程关联。这里就不细讲了。 repositoryName这个是远程库的名字，可以随便取名字。也有默认的取法叫做origin，这个相信大家看到过很多。 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样。 从现在起，只要是本地的master分之之提交最新修改至GitHub，只要 1$ git push origin master 从远程库克隆上面讲的是先有本地仓库，然后再建立远程仓库，之后再关联两者。 下面将的是一开始就在远程建立一个仓库，然后将仓库克隆到本地。 12$ cd ~/desktop$ git clone https://github.com/Feyddy/TestRepository.git 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。 Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 分支管理创建与合并分支每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长： 也就是每执行一次git commit，圆圈就多一个，同时，master和HEAD也指向了新的圆圈。 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并: 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支: 原理讲完了，接下来进行实战： 创建dev分支，然后切换到dev分支: 12$ git checkout -b devSwitched to a new branch &apos;dev&apos; git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： 123$ git branch dev$ git checkout devSwitched to branch &apos;dev&apos; 用git branch命令查看当前分支: 123$ git branch* dev master git branch命令会列出所有分支，当前分支前面会标一个*号。 然后，我们就可以在dev分支上正常提交，比如对项目做个修改，加上一行（print(&quot;我是分支dev提交的&quot;)）： 1234$ git add .$ git commit -m &quot;dev分支提交&quot;[dev af808ab] dev分支提交 2 files changed, 1 insertion(+) 现在，dev分支的工作完成，我们就可以切换回master分支： 123$ git checkout masterSwitched to branch &apos;master&apos;Your branch is up-to-date with &apos;repositoryName/master&apos;. 切换回master分支后，再查看一个项目文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变： 我们把dev分支的工作成果合并到master分支上（git merge dev）：注意：这里每次进行分支之间的操作的时候都会有提示，让你先提交一下。即：git add和git commit。 12345$ git add .$ git commit -m &quot;master merge dev&quot;[master ce6bc2c] master merge dev1 file changed, 0 insertions(+), 0 deletions(-)$ git merge dev git merge命令用于合并指定分支到当前分支。合并后，再查项目的内容，就可以看到，和dev分支的最新提交是完全一样的。合并完成后，就可以放心地删除dev分支了。 12$ git branch -d devDeleted branch dev (was 651f881). 删除后，查看branch，就只剩下master分支了： 12$ git branch* master 解决冲突 创建一个分支feature1分支 12$ git checkout -b feature1Switched to a new branch &apos;feature1&apos; 修改最后一段代码，并在分支上提交： 1234$ git add .$ git commit -m &quot;feature1提交&quot;[feature1 d9f022a] feature1提交 2 files changed, 1 insertion(+), 1 deletion(-) 切换到master主分支： 123$ git checkout masterSwitched to branch &apos;master&apos;Your branch is up-to-date with &apos;repositoryName/master&apos;. 在master分支上修改最后一行代码，并且提交。 现在，master分支和feature1分支各自都分别有新的提交，变成了这样： 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看： 12$ git merge feature1Automatic merge failed; fix conflicts and then commit the result. 果然冲突了！Git告诉我们，项目文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件： 1234567891011121314$ git statusOn branch masterYour branch is ahead of &apos;repositoryName/master&apos; by 2 commits. (use &quot;git push&quot; to publish your local commits)You have unmerged paths. (fix conflicts and run &quot;git commit&quot;)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: TestRepositoryDemo/TestRepositoryDemo.xcodeproj/project.xcworkspace/xcuserdata/t3.xcuserdatad/UserInterfaceState.xcuserstate both modified: TestRepositoryDemo/TestRepositoryDemo/ViewController.swiftno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 我们可以直接查看项目文件中的内容： 123456789101112131415override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. print("我是版本一") print("我是版本二") print("我是版本三") print("我是版本四") print("我是版本五") print("我是分支dev提交的")&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD print("我是分支master提交的23")======= print("我是分支feature提交的23")&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 &#125; 从上面可以看出，Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存： 123456789101112override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. print("我是版本一") print("我是版本二") print("我是版本三") print("我是版本四") print("我是版本五") print("我是分支dev提交的") print("我是分支master提交的23") print("我是分支feature提交的23") &#125; 再提交： 123$ git add .$ git commit -m &quot;conflict fixed&quot;[master 275259a] conflict fixed 现在，master分支和feature1分支变成了下图所示： 用带参数的git log也可以看到分支的合并情况： 1234567891011121314151617181920212223242526$ git log --graph --pretty=oneline --abbrev-commit* 275259a conflict fixed|\ | * d9f022a feature1提交* | 36b5df2 master提交1* | ae55a69 master提交|/ * 38db422 ad|\ | * 651f881 dev2| * 4b2458d dev2* | ce6bc2c master merge dev* | cb7d0d6 devswitch|\ \ | |/ | * c6cd257 dev提交| * af808ab dev分支提交* | bcbe8de af* | 0a69183 master提胶|/ * 6b1c1be s* 5aa8e9c checkout* dc9ebfc 暂存区的介绍* a04e162 版本第三次提交: 最后，删除feature1分支： 12$ git branch -d feature1Deleted branch feature1 (was d9f022a). git log –graph命令可以看到分支合并图 分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 下面我们实战一下--no-ff方式的git merge： 创建并合并分支dev; 修改项目并提交一个新的commit; 切回master; 准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward： 1$ git merge --no-ff -m &quot;merge with no-ff&quot; dev 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史： 12345678910111213141516171819202122232425$ git log --graph* commit 5ed58de2217172a9a21f8b510e42783905a80c54| Author: Feyddy &lt;Feyddyxu@163.com&gt;| Date: Sat Feb 25 16:33:42 2017 +0800| | d| * commit 275259af9b9f3da4bb44dabf656bd3fc1c25c6ef|\ Merge: 36b5df2 d9f022a| | Author: Feyddy &lt;Feyddyxu@163.com&gt;| | Date: Sat Feb 25 16:23:24 2017 +0800| | | | conflict fixed| | | * commit d9f022a92b9f96632fcde3a2f64ee9636461448a| | Author: Feyddy &lt;Feyddyxu@163.com&gt;| | Date: Sat Feb 25 16:07:38 2017 +0800| | | | feature1提交| | * | commit 36b5df20a440121690a0a34b770c1f730e8d6787| | Author: Feyddy &lt;Feyddyxu@163.com&gt;| | Date: Sat Feb 25 16:12:54 2017 +0800| | : 可以看到，不使用Fast forward模式，merge后就像这样： 分支策略在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： Bug分支在开发中我们经常会遇到这样的一个问题：临时突然需要你立刻修改完一个Bug，但是当前正在分支上的工作进行了一半还没有完成，而且没法提交代码。这样的状况，可以用Git的stash功能，可以把当前工作现场“储藏”起来，等恢复现场后继续工作： 123$ git stashSaved working directory and index state WIP on dev: c846f02 我是分支管理提交的HEAD is now at c846f02 我是分支管理提交的 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。 123$ git statusOn branch devChanges not staged for commit: 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支： 12345$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;repositoryName/master&apos; by 7 commits.$ git checkout -b &quot;issue-101&quot;Switched to a new branch &apos;issue-101&apos; 现在修复bug，然后提交;提交完后，切换到master分支，并完成合并，最后删除issue-101分支。 1234567$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;repositoryName/master&apos; by 7 commits. (use &quot;git push&quot; to publish your local commits)$ git merge --no-ff -m &quot;merged bug fix&quot; issue-101$ git branch -d issue-101Deleted branch issue-101 (was cc17032). Bug修改完成后，是时候接着回到dev分支干活了！ 1234567891011git checkout devSwitched to branch &apos;dev&apos;$ git statusOn branch devChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: TestRepositoryDemo/TestRepositoryDemo.xcodeproj/project.xcworkspace/xcuserdata/t3.xcuserdatad/UserInterfaceState.xcuserstateno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看： 12$ git stash liststash@&#123;0&#125;: WIP on dev: c846f02 我是分支管理提交的 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： 1234$ git stash popwarning: Cannot merge binary files: TestRepositoryDemo/TestRepositoryDemo.xcodeproj/project.xcworkspace/xcuserdata/t3.xcuserdatad/UserInterfaceState.xcuserstate (Updated upstream vs. Stashed changes)Auto-merging TestRepositoryDemo/TestRepositoryDemo.xcodeproj/project.xcworkspace/xcuserdata/t3.xcuserdatad/UserInterfaceState.xcuserstateCONFLICT (content): Merge conflict in TestRepositoryDemo/TestRepositoryDemo.xcodeproj/project.xcworkspace/xcuserdata/t3.xcuserdatad/UserInterfaceState.xcuserstate 再用git stash list查看，就看不到任何stash内容了。 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令： 1$ git stash apply stash@&#123;0&#125; Feature分支在软件开发中添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 现在已开发新功能”Feyddy”为例。 现在dev分之下创建一个分支Feyddy; 在项目中添加代码，完成新功能开发，然后提交； 切回dev，准备合并。一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。 但是此时，新功能不需要了，但是这个分支还是需要删除的： 123$ git branch -d Feyddyerror: The branch &apos;Feyddy&apos; is not fully merged.If you are sure you want to delete it, run &apos;git branch -D Feyddy&apos;. 销毁失败。Git友情提醒，Feyddy分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D Feyddy。 下面只要我们继续强行删除就可以了。 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote： 123$ git remoteoriginrepositoryName 或者使用git remote -v显示更详细的信息： 12345$ git remote -vorigin git@github.com:Feyddy/TestRepository.git (fetch)origin git@github.com:Feyddy/TestRepository.git (push)repositoryName https://github.com/Feyddy/TestRepository.git (fetch)repositoryName https://github.com/Feyddy/TestRepository.git (push) 上面显示了可以抓取和推送的repositoryName的地址。如果没有推送权限，就看不到push的地址。因为之前创建仓库的时候自己取了个名字. 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 123456789$ git push repositoryName masterCounting objects: 98, done.Delta compression using up to 4 threads.Compressing objects: 100% (87/87), done.Writing objects: 100% (98/98), 18.28 KiB | 0 bytes/s, done.Total 98 (delta 34), reused 0 (delta 0)remote: Resolving deltas: 100% (34/34), completed with 3 local objects.To https://github.com/Feyddy/TestRepository.git 38db422..086c49c master -&gt; master 如果要推送其他分支，比如dev，就改成： 123456789$ git push repositoryName devCounting objects: 98, done.Delta compression using up to 4 threads.Compressing objects: 100% (87/87), done.Writing objects: 100% (98/98), 18.28 KiB | 0 bytes/s, done.Total 98 (delta 34), reused 0 (delta 0)remote: Resolving deltas: 100% (34/34), completed with 3 local objects.To https://github.com/Feyddy/TestRepository.git 38db422..086c49c master -&gt; master 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆。 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。现在小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： 1234567$ git checkout -b dev$ git reset --hard respositoryName/dev$ git push -u origin devTotal 0 (delta 0), reused 0 (delta 0)To https://github.com/Feyddy/TestRepository.git * [new branch] dev -&gt; devBranch dev set up to track remote branch dev from origin. 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程： 12345$ git add .$ git commit -m &quot;dev&quot;[dev 2876867] dev 2 files changed, 1 insertion(+)$ git push origin dev 此时如果你也对同样的文件作了修改，并试图提交的时候，将会失败。因为有冲突，解决方法就是，git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。 git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： 1$ git branch --set-upstream dev origin/dev 这样在pull。这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push。 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS与WebSocket的使用]]></title>
      <url>%2F2017%2F02%2F24%2FiOS%E4%B8%8EWeb-Socket%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[WebSocketWebSocket是HTML5规格中的一个非常重要的新特性，它的存在可以允许用户在浏览器中实现双向通信，实现数据的及时推送，这个技术的意义在于我们可以通过网页实现很多以前无法实现的应用。例如目前的在线聊天室，如果用户想要发送一句话，在他按下“发送”按钮的同时，浏览器会递送给目标服务器一个请求，然后服务器端会将这句话显示在网页上。而用户如果想要看到这句话，他需要刷新自己的浏览器以获得最新页面才可以。但是WebSocket的双向通信就神奇与此，通过WebSocket技术构建的HTML5应用，用户不再需要频繁的刷新页面以获取新数据，而新数据会自动由服务器端推送至用户的电脑屏幕上。 WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。 浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。 当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。 WebSocket协议本质上是一个基于 TCP 的协议。 为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。 HTTP的三个问题： （1）为一个WEB客户端潜在的建产多个TCP连接。 （2）有一个大的HTTP头，以满足HTTP协议。 （3）客户端的脚本必须为输入连接和输出连接建立一个映射，以确定回复。 （4）基于请求-响应模式，HTTP服务端不能主动推送(push)数据到客户端。 Websocket的三个好处： （1）一个WEB客户端只有一个TCP连接。 （2）Websocket服务端可以推送数据到web客户端. （3）轻量级的头，减少数据传送量 （4）服务端可以主动推送数据到客户端 （5）已成功应用于游戏、股票交易等用多用户实时系统中。 （6）支持多客户端，Web客戶 （7）客户端开发接口简单 关于WebSocket做个总结： Websocket就是借着 HTML5在浏览器中加了一个socket通信程序的客户端。你在安装浏览器的时候，默认装了一个客户端，可以向服务端请求，并建产链接。然后再像原先的socket应用程序一样来回互相发送消息。 Websocket不是一个新技术，只是HTML5中用javascript提供了一些接口，让你调用。服务端还是任何一门支持Socket通信的语言就行。 Websocket的应用。可以应用在很的领域，游戏，股票。简单说主要是一些多用户的实时应用。也可实现类似和webqq一样的网页聊工具。 Websocket把http协议轻量化了，在web交互中，我们再也不用让http包了一层又一层，而了去满足我们不需要的功能了。我们只要简单传我们想要的数据，协议我们可以在Websocket这种轻量级协议下，制定我们自己的子协议，可以减少不少的交互和网络流量哦。 WebSocket 在ios开发中的用法一般APP里面有个聊天功能，需要服务器主动推数据到APP。HTTP 通信方式只能由客户端主动拉取，服务器不能主动推给客户端，如果有实时的消息，要立刻通知客户端就麻烦了，要么客户端每隔几秒钟发一次请求，看看有没有新数据，这种方式想想都知道耗流量电量。还一种方式就是走TCP/UDP协议服务器主动推给你，这种方式省流量。还有就是用websocket，websocket是h5里面的东西，但是它比原生socket用法简单。 WebSocket通信协议实现的是基于浏览器的原生socket，维基百科上解释：“WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，WebSocketAPI被W3C定为标准。在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。” 客户端在握手成功后，会触发WebSocket对象的onopen事件，告诉客户端连接已经成功建立了。客户端的WebSocket对象一共绑定了四个事件： 1、onopen：连接建立时触发； 2、onmessage：收到服务端消息时触发； 3、onerror：连接出错时触发； 4、onclose：连接关闭时触发； SocketRocket：它是采用OC编写的一个WebSocket客户端，来实现客户端与服务器的双向通信。SocketRocket 是个标准的 Objective-C WebSocket (RFC 6455) 客户端库。 主要特性： TLS (wss) 支持 使用 NSStream/CFNetworking 使用 ARC 并行架构 基于委托 框架依赖： libicucore.dylib CFNetwork.framework Security.framework Foundation.framework SocketRocket Demo下载地址：https://github.com/square/SocketRocket 1.创建和设置代理对象 123456SRWebSocket *socket = [[SRWebSocket alloc] initWithURLRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://ip地址:端口&quot;]]; socket.delegate = self; // 实现这个 SRWebSocketDelegate 协议啊 [socket open]; // open 就是直接连接了 2.连接成功会调用这个代理方法 123- (void)webSocketDidOpen:(SRWebSocket *)webSocket &#123; NSLog(@&quot;连接成功，可以立刻登录你公司后台的服务器了，还有开启心跳&quot;);&#125; 3.连接失败会调用这个方法，看 NSLog 里面的东西 1234567- (void)webSocket:(SRWebSocket *)webSocket didFailWithError:(NSError *)error &#123; NSLog(@&quot;连接失败，这里可以实现掉线自动重连，要注意以下几点&quot;); NSLog(@&quot;1.判断当前网络环境，如果断网了就不要连了，等待网络到来，在发起重连&quot;); NSLog(@&quot;2.判断调用层是否需要连接，例如用户都没在聊天界面，连接上去浪费流量&quot;); NSLog(@&quot;3.连接次数限制，如果连接失败了，重试10次左右就可以了，不然就死循环了。 或者每隔1，2，4，8，10，10秒重连...f(x) = f(x-1) * 2, (x=5)&quot;);&#125; 4.连接关闭调用这个方法，注意连接关闭不是连接断开，关闭是 [socket close]客户端主动关闭，断开可能是断网了，被动断开的。 123- (void)webSocket:(SRWebSocket *)webSocket didCloseWithCode:(NSInteger)code reason:(NSString *)reason wasClean:(BOOL)wasClean &#123; NSLog(@&quot;连接断开，清空socket对象，清空该清空的东西，还有关闭心跳！&quot;);&#125; 5.收到服务器发来的数据会调用这个方法 123456- (void)webSocket:(SRWebSocket *)webSocket didReceiveMessage:(id)message &#123; NSLog(@&quot;收到数据了，注意 message 是 id 类型的，学过C语言的都知道，id 是 (void *) void* 就厉害了，二进制数据都可以指着，不详细解释 void* 了&quot;); NSLog(@&quot;我这后台约定的 message 是 json 格式数据 收到数据，就按格式解析吧，然后把数据发给调用层&quot;);&#125; 6.向服务器发送数据发送的时候可能断网，可能socket还在连接，要判断一些情况，写在下面了 发送逻辑是，我有一个 socketQueue 的串行队列，发送请求会加到这个队列里，然后一个一个发出去，如果掉线了，重连连上后继续发送，对调用层透明，调用层不需要知道网络断开了。12345678910111213141516171819202122232425262728- (void)sendData:(id)data &#123; WEAKSELF(ws); dispatch_async(self.socketQueue, ^&#123; if (ws.socket != nil) &#123; // 只有 SR_OPEN 开启状态才能调 send 方法啊，不然要崩 if (ws.socket.readyState == SR_OPEN) &#123; [ws.socket send:data]; // 发送数据 &#125; else if (ws.socket.readyState == SR_CONNECTING) &#123; NSLog(@&quot;正在连接中，重连后其他方法会去自动同步数据&quot;); // 每隔2秒检测一次 socket.readyState 状态，检测 10 次左右 // 只要有一次状态是 SR_OPEN 的就调用 [ws.socket send:data] 发送数据 // 如果 10 次都还是没连上的，那这个发送请求就丢失了，这种情况是服务器的问题了，小概率的 // 代码有点长，我就写个逻辑在这里好了 &#125; else if (ws.socket.readyState == SR_CLOSING || ws.socket.readyState == SR_CLOSED) &#123; // websocket 断开了，调用 reConnect 方法重连 [ws reConnect:^&#123; NSLog(@&quot;重连成功，继续发送刚刚的数据&quot;); [ws.socket send:data]; &#125;]; &#125; &#125; else &#123; NSLog(@&quot;没网络，发送失败，一旦断网 socket 会被我设置 nil 的&quot;); NSLog(@&quot;其实最好是发送前判断一下网络状态比较好，我写的有点晦涩，socket==nil来表示断网&quot;); &#125; &#125;);&#125; 7.心跳机制 12345//该函数是接收服务器发送的pong消息- (void)webSocket:(SRWebSocket *)webSocket didReceivePong:(NSData *)pongPayload &#123; NSString *reply = [[NSString alloc] initWithData:pongPayload encoding:NSUTF8StringEncoding]; NSLog(@&quot;%@&quot;,reply);&#125; 心跳机制就不难了，开个定时器，问下后台要每隔多少秒发送一次心跳请求就好了。然后注意，断网了或者socket断开的时候把心跳关一下，省资源，不然都断网了，还在循环发心跳，浪费CPU和电量。 这里详细讲解下心跳机制这个函数： 123-(void)webSocket:(SRWebSocket *)webSocket didReceivePong:(NSData *)pongPayload&#123; socketPong = socketPong + 1;&#125; 其中最后一个是接受pong消息的，在这里就要提一下心跳包，一般情况下建立长连接都会建立一个心跳包，用于每隔一段时间通知一次服务端，客户端还是在线，这个心跳包其实就是一个ping消息，我的理解就是建立一个定时器，每隔十秒或者十五秒向服务端发送一个ping消息，这个消息可是是空的，例如 12 NSData * data = [[NSData alloc]init];[_webSocket sendPing:data]; 发送过去消息以后，服务器会返回一个pong消息，这个消息是解读不了的，但是每次返回时就会调用 1-(void)webSocket:(SRWebSocket *)webSocket didReceivePong:(NSData *)pongPayload 这个函数，如果要用到话，可以像我做的那样，直接在该函数里面统计一下收到的次数，跟发送的次数比较，如果每次发送之前，自己发送的ping消息的个数，跟收到pong消息的个数相同，那就代表一直在连接状态，但是服务器发送pong消息时候是自动发送的，服务器是看不到客户端发送的ping消息的，同理，服务端也一样，只要服务端建立有心跳连接，那么服务端也是一直在发送ping消息，客户端一直在回复pong消息，这两个消息是处理不了的，没办法解读这个歌消息体里面的内容。还有一点就是在发送ping消息的时候，如果非要想在里面加入一些参数，这个参数不能太大，太大的话，会提示发送失败。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML语义标签简介]]></title>
      <url>%2F2017%2F02%2F23%2FHTML%E8%AF%AD%E4%B9%89%E6%A0%87%E7%AD%BE%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[h标签和p标签h标签：h1~h6字体越来越小，没有h7以上的标签。 p标签：段落 img图片标签1&lt;img src="./icon.png" alt="如果图片加载不出来，显示本文字" title="鼠标移动到图片上，弹出本文字"/&gt; 替换标签（replaced element）首先我们拿&lt;img&gt;标签来举例： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;img到底是内联还是块级？&lt;/title&gt; &lt;style&gt; img &#123; border: 1px solid red; width: 100px; height: 100px; margin: 0; &#125; div &#123; width: 400px; height: 400px; border: 1px solid orange; margin: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!--如果是内联元素，但是完全可以设置宽高而且还有几像素的margin值--&gt;&lt;img src="./icon.png" alt="图片"/&gt;&lt;img src="./icon.png" alt="图片"/&gt;&lt;!--但如果是块级元素，上下两个块状之间不会有margin值，而且设置margin值又不管用--&gt;&lt;div class="test"&gt;asdasdasd&lt;/div&gt;&lt;!--所以img是一个特殊的内联元素，同时是内联替换元素，替换元素是能设置宽和高的。因此在css初始化的时候，一般先将img标签转换成块级元素，然后设置border为0--&gt;&lt;/body&gt;&lt;/html&gt; 所谓替换元素（replaced element），就是元素本身没有实际内容，最终显示内容需要浏览器根据元素某些属性去判断的元素。 如&lt;img&gt;元素，其最终的显示内容是由属性src决定的，如&lt;input&gt;元素，其最终显示的效果是由属性type决定的。 常见的替换元素还包括：&lt;textarea&gt;、&lt;select&gt;、&lt;object&gt;。 替换元素经常具备固有的尺寸：固有的width，固有的height，以及固有的比例ratio。 这个理解起来不难，类比&lt;img&gt;元素，它的固有尺寸就是原始图片大小；类比&lt;input&gt;元素，不管其type属于哪一种类型，显示出来的input元素都有原始尺寸。 但是像&lt;div&gt;&lt;/div&gt;这样的非替换元素，其没有固有尺寸。 HTML中大多数是非替换元素(non-replaced element)。 所谓非替换元素和替换元素相反，元素本身是有实际内容的，浏览器会直接将其内容显示出来，而不需要根据元素属性来判断到底显示什么内容。如&lt;span&gt;this is the content&lt;/span&gt;，元素内容就是“this is the content”。 有序列表和无序列表123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;有序列表和无序列表&lt;/title&gt; &lt;!--但是开发的时候一把都去掉样式：none--&gt; &lt;style type="text/css"&gt; *&#123; margin: 0px; padding: 0px; &#125; li&#123; list-style-type:none; &#125; .icon1 li&#123; padding-left: 15px; background-size: 5px 5px; background-image:url(../cssimage/sinaicon.png); background-repeat:no-repeat; background-position:5px 8px; list-style-type:none; line-height: 20px; &#125; /*当标题前的图标时单独的一个点儿或者方块或者其他类似图标时，定义背景图background要放在&lt;li&gt;里。 在&lt;li&gt;中设置背景图片的尺寸，地址，不重复，位置；以及文字相关的padding，无序列图标，行高等*/ &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="test1"&gt;初始化CSS后，写li，并利用背景图片，来完成li小图标的效果，且达到个浏览器兼容&lt;/div&gt;&lt;ul class="icon1"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;有序列表和无序列表&lt;/title&gt; &lt;!--但是开发的时候一把都去掉样式：none--&gt; &lt;style type="text/css"&gt; *&#123; margin: 0px; padding: 0px; &#125; li&#123; list-style-type:none; &#125; .icon1&#123; width: 1024px; height: 978px; background-image: url(image/smallicon2.jpg); background-repeat: no-repeat; background-position: 0 -30px; &#125; .icon1 li&#123; padding-top: 40px; padding-left: 200px; line-height: 115px; list-style-type: none; font-size: 50px; &#125; /*当标题前的图标是很长的一列并标有连续的1、2、3、4……的图片而不是单独的一个点或者类似图标时，在定义背景图background要定义在&lt;ul&gt;里。 记住要定义属性宽高，背景图片的地址和位置，图片不重复等。 然后在&lt;li&gt;中定义文字的相关部分，如内边距padding,行高line-height,无序列号样式list-style-type,字体大小等*/ &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="test1"&gt;初始化CSS后，写li，并利用背景图片，来完成li小图标的效果，且达到个浏览器兼容&lt;/div&gt;&lt;ul class="icon1"&gt; &lt;li&gt;1、春&lt;/li&gt; &lt;li&gt;2、夏&lt;/li&gt; &lt;li&gt;3、秋&lt;/li&gt; &lt;li&gt;4、冬&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 表格123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;整齐的表格&lt;/title&gt; &lt;style&gt; td &#123; border: 1px solid red; &#125; .tables &#123; /*设置table里面的单元格之间没有间距。注意不能设置在td里面*/ border-collapse: collapse; /*设置表格里面哥哥单元格之间的间距*/ /*border-spacing: 20px;*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!--三行四列--&gt;&lt;table class="tables"&gt; &lt;tr&gt; &lt;!--跨3列--&gt; &lt;td colspan="4"&gt;11&lt;/td&gt; &lt;!--&lt;td&gt;12&lt;/td&gt;--&gt; &lt;!--&lt;td&gt;13&lt;/td&gt;--&gt; &lt;!--&lt;td&gt;14&lt;/td&gt;--&gt; &lt;/tr&gt; &lt;tr&gt; &lt;!--跨2行--&gt; &lt;td rowspan="2"&gt;21&lt;/td&gt; &lt;td&gt;22&lt;/td&gt; &lt;td rowspan="2"&gt;23&lt;/td&gt; &lt;td&gt;24&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;!--&lt;td&gt;31&lt;/td&gt;--&gt; &lt;td&gt;32&lt;/td&gt; &lt;!--&lt;td&gt;33&lt;/td&gt;--&gt; &lt;td&gt;34&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 超链接1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;超链接标签(内联元素)&lt;/title&gt; &lt;style&gt; a &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!--这里一定要加上https://--&gt;&lt;a href="https://www.baidu.com" title="baidudizhi" target="_blank"&gt;百度&lt;/a&gt;&lt;!--target默认是自身窗口改变。如果需要新打开一个窗口的话target="_blank"--&gt;&lt;a href="CSS选择器.html" title="baidudizhi" target="_blank"&gt;自己的项目页面&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 锚点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;锚点&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="#p1"&gt;p1&lt;/a&gt;&lt;a href="#p2"&gt;p2&lt;/a&gt;&lt;a href="#p3"&gt;p3&lt;/a&gt;&lt;a name="p1"&gt;&lt;/a&gt;&lt;p&gt;p1&lt;/p&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;a name="p2"&gt;&lt;/a&gt;&lt;p&gt;p2&lt;/p&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;a name="p3"&gt;&lt;/a&gt;&lt;p&gt;p3&lt;/p&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 伪类CSS允许我们针对a标签的4种状态设置各自的CSS特性，叫做CSS的伪类。下面列举几个注意点： active一般不必写； 一定注意，顺序是LVHA a:link可以简写为a 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;a标签的伪类&lt;/title&gt; &lt;style&gt; /*普通的一个标签显示 a:link或者直接a*/ a &#123; display: block; color: blue; &#125; /*点击放开鼠标*/ a:visited &#123; color: grey; &#125; /*鼠标放上去*/ a:hover &#123; color: blueviolet; &#125; /*点击不放*/ a:active &#123; color: darkred; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="锚点.html/#p2"&gt;锚点的解释asd&lt;/a&gt; &lt;a href="超链接.html"&gt;超链接&lt;/a&gt; &lt;a href="#"&gt;空链接&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 字符实体在html开发中，有一些字符，不适合直接写出，如&gt;,&lt;一般的格式：&amp; + 实体名 + ;实体有很多，记住常用的就行如： &amp;gt &gt; &amp;lt &lt; &amp;quot “ &amp;amp &amp; &amp;copy 版权 &amp;nbsp 空格 其他的可以去查手册]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS证书配置流程详解]]></title>
      <url>%2F2017%2F02%2F22%2FiOS%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[证书的配置流程首先，你的Apple Id必须是付过费的，这样你才可以使用相关的证书功能。如果你的账号没有付过费，那么你登录Apple developer之后是下面的样子： 如果你的账号付过费，那么你登录之后将会是下面的样子： 点击上图中的Certificates, Identifiers &amp; Profiles。跳转到下面的界面： 在配置证书之前需要将我们的Apple ID和我们的项目进行绑定。 首先应该配置自己的App IDs: 点击上图中的+跳转到下面的界面，在此界面我们可以设置自己的App ID 上图中的Name可以随便取一个名字 下图中的Bundle ID必须和自己的项目中的Bundle ID一样的，具体的取名格式图片上已经有了提示： 还有就是该页面的最下面有一个App Services。里面的可以先不勾选，等到以后有需求在勾选也不迟。 最后点击continue继续，跳转界面后，在点击Register后就可以了。到此你的项目就和你的Apple ID绑定了。 另外，我们需要在指定的设备上进行相关的证书的测试，这个时候我们就需要添加设备了。详细步骤见下图： UUID需要连接手机后在itunes里查看： 最后点击注册就行了。 接下来才可以配置证书。 证书的配置过程 开发证书(Development)（线下真机测试） 开发环境下app签证证书 开发环境下推送证书 - 选择上面的证书后，点击继续，会跳转到下面的界面： ![](https://ww2.sinaimg.cn/large/006tNc79gy1fczlwnk7z4j30j00ct0t1.jpg) **在这里你需要选择上面自己创建的App ID。** - 接下来一直continue直到出现下面的界面： ![](https://ww4.sinaimg.cn/large/006tNc79gy1fczm0xoch4j30kh0ej0t0.jpg) 这个时候你必须要去你电脑里面的钥匙串里面导出CertificateSigningRequest文件。具体的步骤见下图： ![](https://ww2.sinaimg.cn/large/006tNc79gy1fczm6c33x0j30qi0cmabm.jpg) ![](https://ww3.sinaimg.cn/large/006tNc79gy1fczm7rq4cfj30h40c40sx.jpg) **注意上面的email填写必须为你的APPLE ID账号** 获得文件后，回到配置证书界面：点击choose File，将刚刚导出的文件上传后跳转到下面： ![](https://ww2.sinaimg.cn/large/006tNc79gy1fczn9v0ve1j30jf0gtjs3.jpg) 点击下载文件，然后双击这个文件，在钥匙串里面导出p12文件。 ![](https://ww1.sinaimg.cn/large/006tNc79gy1fczmjm1zdej30o80eiq3s.jpg) 双击p12文件，就会自动导入你的项目中，这个就是开发证书。 **推送证书的步骤类似** profile文件 下面就是选择一开始设置的那个APP ID 下面就是你之前配置的开发证书选择： 因为是开发证书，所以接下来需要选择真机测试的UUID设备： 最后为你的profile文件取个名字 下载profile文件后双击打开就会自动导入项目。 生产证书(Distribution)（线上） App Store Adhoc (打包.ipa文件为了测试线上的证书配置效果)，UUID的配置，为了在特定的手机上进行线上环境测试。 推送证书]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS常用的选择器以及四种引入方式]]></title>
      <url>%2F2017%2F02%2F22%2FCSS%E5%B8%B8%E7%94%A8%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8%E4%BB%A5%E5%8F%8A%E5%9B%9B%E7%A7%8D%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[CSS常用的选择器 id选择器给每个标签定义一个唯一标识id。这个id整个页面只有一个。 class类选择器给每个标签定义一个类名，这个类名可以分配到多个标签，使得多个标签拥有一个类的CSS样式。 标签选择器直接改变整个页面中的所有的一种标签的样式。 派生选择器利用元素之间的所属级关系，改变某个标签的子标签的样式。 具体代码见下面： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #test1 &#123; width: 200px; height: 200px; border: 1px solid purple; &#125; .test2 &#123; width: 300px; height: 300px; border: 1px solid blue; &#125; div &#123; width: 200px; height: 200px; background-color: orange; &#125; div p &#123; background-color: purple; width: 100px; height: 50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="test1"&gt;&lt;/div&gt;&lt;div class="test2"&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;我是div里面的p标签&lt;/p&gt;&lt;/div&gt;&lt;p&gt;我是div 外面独立的p标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 当我们对同一个标签进行多种选择器CSS样式设置的时候，这就涉及到CSS优先级的问题了。记住一个准则：越精细的优先级越高。 可见：id &gt; class &gt; 标签但是对于派生选择器需要看不同情况进行不同的判断。例如： div .text1 &gt; div #text1 &gt; div p 组合选择器 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #test1 &#123; width: 200px; height: 200px; border: 1px solid purple; &#125; .test2 &#123; width: 300px; height: 300px; border: 1px solid blue; &#125; div &#123; width: 200px; height: 200px; background-color: orange; &#125; div p &#123; background-color: purple; width: 100px; height: 50px; &#125; p.test2 &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="test1"&gt;&lt;/div&gt;&lt;div class="test2"&gt;&lt;/div&gt;&lt;div&gt; &lt;p class="test3&gt;我是div里面的p标签&lt;/p&gt;&lt;/div&gt;&lt;p class="test2&gt;我是div 外面独立的p标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 其中的p.test2组合就是只改变p标签里类是test2的颜色，而不改变div里类是test2的颜色。 一个标签还可以有多个类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #test1 &#123; width: 200px; height: 200px; border: 1px solid purple; &#125; .test2 &#123; width: 300px; height: 300px; border: 1px solid blue; &#125; div &#123; width: 200px; height: 200px; background-color: orange; &#125; div p &#123; background-color: purple; width: 100px; height: 50px; &#125; p.test2 &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="test1"&gt;&lt;/div&gt;&lt;div class="test2 test3"&gt;&lt;/div&gt;&lt;div&gt; &lt;p class="test3&gt;我是div里面的p标签&lt;/p&gt;&lt;/div&gt;&lt;p class="test2&gt;我是div 外面独立的p标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 其中的有一个div有test2、 test3两个类。 我们还可以同时对多个类进行相同属性的设置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #test1 &#123; width: 200px; height: 200px; border: 1px solid purple; &#125; .test2 &#123; width: 300px; height: 300px; border: 1px solid blue; &#125; div,.test2,.test3 &#123; width: 200px; height: 200px; background-color: orange; &#125; div p &#123; background-color: purple; width: 100px; height: 50px; &#125; p.test2 &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="test1"&gt;&lt;/div&gt;&lt;div class="test2 test3"&gt;&lt;/div&gt;&lt;div&gt; &lt;p class="test3&gt;我是div里面的p标签&lt;/p&gt;&lt;/div&gt;&lt;p class="test2&gt;我是div 外面独立的p标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 伪元素选择器 12345678910111213141516/*链接正常状态*/a: link &#123;&#125;/*链接点击过状态*/a: visited &#123;&#125;/*链接鼠标放上去状态*/a: hover &#123;&#125;/*链接点击时状态*/a: active &#123;&#125; 注意：a: hover必须放在a: link和a: visited之后才有效果；a: active必须放在a: hover之后才有效。 还有P元素也是: 12345678910111213/*p标签里面的第一个子标签*/p:first-child&#123; &#125;/*p标签里面的第一个字符*/p:first-letter &#123; &#125;/*p标签里的第一行*/ p:first-line &#123; &#125; 其他的选择器可以自行搜索手册进行学习。 CSS四种引入方式 写在head里面直接用进行包含。 写在一个CSS文件中，然后在head中引入： 1&lt;link rel="stylesheet" href="./ZICSS.css"/&gt; 其中的./是代表当前文件夹的意思；../上一个文件夹路径。 直接在body里面的某个标签中设置： 1&lt;div class="test2" style="color: red"&gt;nisha&lt;/div&gt; 在一个.css文件中用@import url()导入另一个css文件 CSS的初始化相同的元素，如li，在不同的浏览器中，显示的效果稍有不同。是因为，浏览器对各种元素的margin,border,font,size等略有不同，如果杜绝这种情况，我们通过css强制让所有元素的属性值都一样，这样，浏览器显示就一致了，减少了不兼容性的发生。这个过程叫做css初始化。 这个需要查看源代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS对背景图片的相关设置]]></title>
      <url>%2F2017%2F02%2F21%2FCSS%E5%AF%B9%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[css设置背景图片1234567891011121314background: purple;background-image: url(images/身份证.jpg);/*水平重复*//*background-repeat: repeat-x;*//*整个页面重复*//*background-repeat: repeat;*/background-repeat: no-repeat;/*页面即使滑动，图片也一直浮现在视野上面*/background-attachment: fixed; 注意：如果网页既设置了背景色又设置背景图，优先显示背景图 css精确设置背景图片的位置 我们可以使用background-position属性 background-position: center（水平方向居中） bottom（竖直方向在底部）; 我们还可以设置某个大图片的一部分进行显示 12/*这边的position需要根据具体的大图片来计算了*/ background-position: -150px -530px; 当然，我们也可以像设置font一样，用一行来设置背景的相关属性 background:背景色 背景图片 是否重复显示图片 position属性 12/*设置背景，我们可以直接用下面的一串直接设置*/background: purple url(images/bg.png) no-repeat -150px -530px;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS控制段落和文字的一些常用属性]]></title>
      <url>%2F2017%2F02%2F20%2FCSS%E6%8E%A7%E5%88%B6%E6%AE%B5%E8%90%BD%E5%92%8C%E6%96%87%E5%AD%97%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[CSS控制段落的属性下面只是常用的几个属性： 12345678/*段落缩进*/text-indent: 20px;/*文字居中*/text-align: center;/*文本装饰-下划线*/text-decoration: underline;/*文字之间的距离*/letter-spacing: 20px; 其他的一些常用的段落控制属性可参考：段落控制的一些css属性 css控制文字的一些属性1234567891011121314151617/*字体的颜色*/color: purple;/*字体的形式：斜体*/font-style: italic;/*加粗*/font-weight: bold;/*字体的大小*/font-size: 20px;/*行高*/line-height: 46px;/*字体*/font-family: "SimHei"; 也可以一次性设置所有的属性，但是必须按照一定的顺序才行font: 字体形式 加粗 字体大小/行高 字体font: italic bold 12px/30px “SimHei”; 注意：在设置字体的时候，我们最好考虑到如果用户没有改字体的情况，于是可以多字体设置，以供用户的电脑自己匹配字体。下面有两种类型的字体大类：sans-serif和serif font-family: ‘微软雅不黑’,’微软雅黑’,’黑体’,sans-serif; font-family: ‘New Times’,’新宋’,’宋体’,serif; 优先选择靠前的字体。 其他的文字属性可以去查看手册。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[内联与块级的转换]]></title>
      <url>%2F2017%2F02%2F20%2F%E5%86%85%E8%81%94%E4%B8%8E%E5%9D%97%E7%BA%A7%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[内联与块级的转换display改变属性block—转变成块级元素inline—转换成行内元素inline-block—-转换成将对象呈递为内联对象，但是对象的内容作为块对象呈递。具有宽度高度特性，又具有同行特性，这个时候我们可以使用inline-block比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。 更多的display属性详细看：display属性值大全]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见的行内元素和块级元素]]></title>
      <url>%2F2017%2F02%2F19%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[内联元素（行内元素）inline设置宽高，竖直方向上的margin和padding没有任何意义。但是可以设置水平方向上的margin和padding。完全是按照文字的大小适应的 块元素(block element) address - 地址 blockquote - 块引用 center - 举中对齐块 dir - 目录列表 div - 常用块级容易，也是css layout的主要标签 dl - 定义列表 fieldset - form控制组 form - 交互表单 h1 - 大标题 h2 - 副标题 h3 - 3级标题 h4 - 4级标题 h5 - 5级标题 h6 - 6级标题 hr - 水平分隔线 isindex - input prompt menu - 菜单列表 noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容 noscript - ）可选脚本内容（对于不支持script的浏览器显示此内容） ol - 排序表单 p - 段落 pre - 格式化文本 table - 表格 ul - 非排序列表 内联元素（行内元素）内联元素(inline element) a - 锚点 abbr - 缩写 acronym - 首字 b - 粗体(不推荐) bdo - bidi override big - 大字体 br - 换行 cite - 引用 code - 计算机代码(在引用源码的时候需要) dfn - 定义字段 em - 强调 font - 字体设定(不推荐) i - 斜体 img - 图片 input - 输入框 kbd - 定义键盘文本 label - 表格标签 q - 短引用 s - 中划线(不推荐) samp - 定义范例计算机代码 select - 项目选择 small - 小字体文本 span - 常用内联容器，定义文本内区块 strike - 中划线 strong - 粗体强调 sub - 下标 sup - 上标 textarea - 多行文本输入框 tt - 电传文本 u - 下划线 var - 定义变量 可变元素可变元素为根据上下文语境决定该元素为块元素或者内联元素。 applet - java applet button - 按钮 del - 删除文本 iframe - inline frame ins - 插入的文本 map - 图片区块(map) object - object对象 script - 客户端脚本 新手常犯的错误 不加doctype,—-导致低版本IE，解析效果不一样。 id为数字，这是不可饶恕的。 文件编码与charset申明不一致，这个主要出现在文件另存的时候选择的编码不同。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[盒子模型的相关知识]]></title>
      <url>%2F2017%2F02%2F18%2F%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
      <content type="text"><![CDATA[盒子模型盒子与盒子之间：margin 盒子边框：border 盒子内部与内容的距离：padding margin margin的几个快捷写法： margin: 10px(上) 0px（右） 10px（下） 40px（左）; margin: 10px(上) 0px（右，左） 10px（下）; margin: 10px(上，下) 0px（右，左）; margin: 10px(上，左，下，右); 也可以单独设置一边 margin-top: 如果想设置div水平居中的话 margin: 0 auto; margin重叠现象： 上下相邻的普通元素（比如不能是浮动的），上下外边距，并非简单的相加，而是取其中比较大的边距值，这种现象叫做margin重叠。 父子div也会出现margin重叠现象，父div的margin和子div的margin也是同方向取比较大的边距值，是共同作用于父div同级的外边距。 123456789101112131415161718192021222324252627282930313233343536373839404142434445 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;margin重叠现象&lt;/title&gt; &lt;style&gt; .test1 &#123; background-color: red; height: 100px; margin-bottom: 30px; &#125; .test2 &#123; background-color: orange; height: 100px; margin-top: 30px; &#125; .super &#123; background-color: blue; margin-top: 100px; height: 300px; &#125; .sub &#123; background-color: purple; /*这个时候super距离外边距为200像素*/ margin-top: 200px; height: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="test1"&gt;这里的两个div的margin其实只有30px而已&lt;/div&gt;&lt;div class="test2"&gt;&lt;/div&gt;&lt;div class="super"&gt; &lt;div class="sub"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; border三要素：宽，形状(solid实线，dashed虚线等见手册)，颜色 这个和盒子本身设置的宽高没有什么关系，这个border是在盒子的外围继续增加本盒子占位的宽高。 单独设置一个属性 12345border-width: 1px;border-style: dotted;border-color: aqua; 下面做个小例子：画出一个三角形和圣诞树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;css控制border画出三角形和圣诞树&lt;/title&gt; &lt;style&gt; .header &#123; background-color: gray; &#125; .triangle &#123; width: 0px; height: 0px; border-top: 50px solid rgba(0,0,0,0); border-right: 50px solid rgba(0,0,0,0); border-bottom: 50px solid orange; border-left: 50px solid rgba(0,0,0,0); &#125; .firstLeaves &#123; width: 0px; height: 0px; border-top: 100px solid rgba(0,255,0,0); border-right: 100px solid rgba(0,255,0,0); border-bottom: 100px solid green; border-left: 100px solid rgba(0,0,0,0); margin-left: 350px; &#125; .secondLeaves &#123; width: 0px; height: 0px; border-right: 200px solid rgba(0,255,0,0); border-bottom: 200px solid green; border-left: 200px solid rgba(0,0,0,0); margin-left: 250px; margin-top: 0; &#125; .root &#123; width: 100px; height: 500px; background-color: brown; margin-left: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="header"&gt; &lt;div class="triangle"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="main"&gt; &lt;div class="firstLeaves"&gt;&lt;/div&gt; &lt;div class="secondLeaves"&gt;&lt;/div&gt; &lt;div class="root"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ###padding padding属性增加后；盒子会变大，也就是说。盒子的内容才是盒子的本身的宽高，但是如果加上padding，那么盒子就会向外扩大padding的大小。和border是一样的效果。 ####盒子模型的总结一个div到底占有多大的空间? 因为有margin,border,padding,实占多大? 假如设置了一个div的宽度为300x300像素，但这个只是在div里面的实际的文字内容的大小，这个时候如果加上border为50px，那么这个div的实际占有（300+2x50）x(300+2x50)像素，也就是400x400。如果再加上padding为50像素,这个时候div内容的占有量没有变大还是300x300像素，但是整个div占有量有扩大了,此时变成(400+2x50)x(400+2x50)像素，也就是500x500。这个时候如果加上margin为50的话，那么这个又会扩大了(500+2x50)x(500+2x50)像素，也就是600x600了。但是实际显示内容的也就只有300x300，其他的都是修饰。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[div的浮动详解]]></title>
      <url>%2F2017%2F02%2F17%2Fdiv%E7%9A%84%E6%B5%AE%E5%8A%A8%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[div的浮动原理我们可以理解为每一个div是一个纸片。 当一个divA的float：left的时候，纸片飘起来，这样的话，后面的divB就在下面滑到飘起来的divA的下面。但是如果这个时候divB也飘起来的话，就和飘起来的divA一起在上面了，这个时候如果divB的float：left，就和divA并排了。于是就紧靠在一起了。 当然，如果divA没有float:left,那么后面的divB即使float：left，也是没用的。 清除浮动clear的解释clear:left 只对同一级的前面以后所有的浮动，也就是本div直接不在后面挨着，另起一行紧贴着浮动的div下面。 clear:right 只针对右边的div起作用，也就是，本div直接进入下一行，紧贴在右边浮动的div下面。 clear:both 按照左右两边浮动的最高的那个为主，进行换行紧贴。12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;clear清除浮动&lt;/title&gt; &lt;style&gt; .left &#123; width: 100px; height: 200px; background-color: red; float: left; &#125; .right &#123; width: 100px; height: 300px; background-color: green; float: right; &#125; .main &#123; height: 600px; background: orange; clear: right; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="left"&gt;我是左边&lt;/div&gt; &lt;div class="right"&gt;我是右边&lt;/div&gt; &lt;div class="main"&gt;我是不浮动的&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 下面是运用clear属性制作田字格的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;作业田字格布局&lt;/title&gt; &lt;style type="text/css"&gt; .topLeft &#123; height: 300px; width: 200px; background-color: black; margin: 100px 30px; float: left; /*clear: left;*/ &#125; .topRight &#123; height: 300px; width: 200px; background-color: purple; margin: 100px 30px; float: left; &#125; .bottomLeft &#123; height: 300px; width: 200px; background-color: orange; margin: 100px 30px; float: left; clear: left; &#125; .bottomRight &#123; height: 300px; width: 200px; background-color: blue; margin: 100px 30px; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="topLeft"&gt;&lt;/div&gt; &lt;div class="topRight"&gt;&lt;/div&gt; &lt;div class="bottomLeft"&gt;&lt;/div&gt; &lt;div class="bottomRight"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注意：如果父div中有两个div是浮动的，父div的高度，不会被两个div撑起来，父div还是原来的高度；这里如果两个子div不设置宽度的话就不会显示出来。宽度就为0，而不是屏幕的宽度。这里的原因是，float之后就变成了inline-block,这就必须要主动设置宽高，否则不显示，但是如果你设置了边框，边框的像素始终都会有的。 如果父div不浮动，但是子div浮动，那么是不会撑起父div的高度的； 如果父div不浮动，但是子div不浮动，那么是会撑起父div的高度的（前提是父div不设置高度）； 如果父div浮动，但是子div不浮动，那么如果父div不设置宽度的话，就和子div的宽度一样;如果设置就是设置的宽度； 如果设置的宽度小于子div的宽度的话，那么子div自动换行（前提是父div没有限制死高度） 父div与子div的关系例子如下： 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; height: 100px; width: 190px; background-color: yellow; float: left; &#125; .first &#123; background-color: red; height: 100px; width: 100px; /*float: left;*/ &#125; .second &#123; background-color: orange; height: 200px; width: 100px; /*float: right;*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;div class="first"&gt;&lt;/div&gt; &lt;div class="second"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 行内标签的浮动如果是行内标签的话，如果挂上float属性，直接变成了块级标签。如果是行内标签，是没有宽高的，直接根据内部的文字内容自动设置宽高，所以直接设置宽高是没用的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift开发技巧（一）]]></title>
      <url>%2F2017%2F01%2F23%2FSwift%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[使用arc4random()、arc4random_uniform()取得随机数arc4random() 这个全局函数会生成10位数的随机整数（UInt32）。其生成的最大值是4294967295（2^32 - 1），最小值为0。 1234567891011//下面是使用 arc4random 函数求一个 1~100 的随机数（包括1和100） for _ in 0...10 &#123; let temp = Int(arc4random()%100)+1 print(temp) &#125; //下面是使用 arc4random_uniform 函数求一个 1~100 的随机数（包括1和100） for _ in 0..&lt;10 &#123; let temp = Int(arc4random_uniform(100))+1 print(temp) &#125; 字符串范围也可以使用区间运算符123456789101112//不使用区间运算符 let index = str.index(str.startIndex, offsetBy: 4) let index2 = str.index(str.startIndex, offsetBy: 6) let range1 = Range(uncheckedBounds: (lower: index, upper: index2)) let rangeStr1 = str.substring(with: range1) print(rangeStr1)//结果为am //使用区间运算符 let range2 = str.index(str.startIndex, offsetBy: 4)..&lt;str.index(str.startIndex, offsetBy: 8) let rangeStr2 = str.substring(with: range2) print(rangeStr2)//结果为ame 区间运算符除了返回一个Range外，还可以接受Comparable的输入，返回ClosedInterval或HalfOpenInterval用这个特性检查字符串里的字符是不是都是合法字符（比如是不是都是小写） 123456let str = "My name is Feyddy"//设置一个范围let interval = "a"..."z"for c in str.characters &#123; interval.contains(String(c)) == true ? print("\(c)是小写字母") : print("\(c)不是小写字母")&#125; 结构体 - struct12345678910//创建一个结构体struct BookInfo&#123; var ID:Int = 0 var Name:String = "Defaut" var Author:String = "Defaut"&#125;var book1:BookInfo //默认构造器创建结构体实例var book2 = BookInfo(ID:0021,Name:"航歌",Author:"hangge") //调用逐一构造器创建实例book2.ID = 1234 //修改内部值 枚举-enum12345678910111213141516171819202122232425262728293031323334//普通的写法enum CompassPoint &#123; case North case South case East case West&#125;//调用var directionToHead = CompassPoint.West //带有原始值的写法enum Planet: Int &#123; case Mercury = 1 case Venus = 2 case Earth = 3&#125;let earthsOrder = Planet.Earth.rawValue //rawValue来获取他的原始值:3let possiblePlanet = Planet(rawValue: 2) //通过原始值来寻找所对应的枚举成员:Venus //里面定义函数的写法enum Direction &#123; case Up case Down func description() -&gt; String&#123; switch(self)&#123; case .Up: return "向上" case .Down: return "向下" &#125; &#125;&#125;print(Direction.Up.description()) while循环语句12345678while i&lt;100 &#123; i+=1&#125; //类似于do-whilerepeat&#123; i+=1&#125;while i&lt;100 可变形参：可以接受0个或者任意数量的输入参数1234567func test(numbers:Int...) -&gt; Int&#123; var count:Int = 0 for number in numbers&#123; count += number &#125; return count&#125; 如果想要同时改变函数内外的参数值，可以利用inout关键字，同时调用函数的时候给参数加上前缀“&amp;”1234567func add(age:inout Int)&#123; age += 1&#125; var age = 22add(age: &amp;age)print(age) //23 可以使用函数类型的参数12345678910func additive(a:Int, b:Int) -&gt; Int&#123; return a + b&#125; //函数类型的参数func printAdditiveResult(addFun: (Int, Int) -&gt; Int, a:Int, b:Int)&#123; print("Result:\(addFun(a,b))")&#125; printAdditiveResult(addFun: additive, a: 5 ,b: 7) 也可以使用函数类型的返回值123456789101112131415161718//定义个自增函数func increase(input:Int) -&gt; Int&#123; return input + 1&#125; //定义个自减函数func reduce(input:Int) -&gt; Int&#123; return input - 1&#125; //定义一个返回函数类型的函数func chooseFunction(backwards:Bool) -&gt; (Int) -&gt; Int&#123; return backwards ? reduce : increase&#125; //测试let aFun = chooseFunction(backwards: 3&gt;2)print(aFun(3)) //2 Swift - 属性观察者（willSet与didSet）属性观察者，类似于触发器。用来监视属性的除初始化之外的属性值变化，当属性值发生改变时可以对此作出响应。有如下特点： 1，不仅可以在属性值改变后触发didSet，也可以在属性值改变前触发willSet。 2，给属性添加观察者必须要声明清楚属性类型，否则编译器报错。 3，willSet可以带一个newName的参数，没有的话，该参数默认命名为newValue。 4，didSet可以带一个oldName的参数，表示旧的属性，不带的话默认命名为oldValue。 5，属性初始化时，willSet和didSet不会调用。只有在初始化上下文之外，当设置属性值时才会调用。 6，即使是设置的值和原来值相同，willSet和didSet也会被调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class People&#123; //普通属性 var firstName:String = "" var lastName:String = "" var nickName:String = "" //计算属性 var fullName:String &#123; get &#123; return nickName + " " + firstName + " " + lastName &#125; &#125; //带属性监视器的普通属性 var age:Int = 0 &#123; //我们需要在age属性变化前做点什么 willSet &#123; print("Will set an new value \(newValue) to age") &#125; //我们需要在age属性发生变化后，更新一下nickName这个属性 didSet &#123; print("age filed changed form \(oldValue) to \(age)") if age&lt;10 &#123; nickName = "Little" &#125;else &#123; nickName = "Big" &#125; &#125; &#125; func toString() -&gt; String &#123; return "Full Name: \(fullName) " + ", Age: \(age) " &#125; &#125; let me = People()me.firstName = "Li"me.lastName = "Lei"me.age = 30 print(me.toString()) /*程序输出Will set an new value 30 to ageage filed changed form 0 to 30Full Name: Big Li Lei , Age: 30*/ 类的计算属性（使用get和set来间接获取/改变其他属性的值） Swift中类可以使用计算属性，即使用get和set来间接获取/改变其他属性的值 1234567891011121314151617class Calcuator&#123; var a:Int = 1; var b:Int = 1; var sum:Int&#123; get&#123; return a + b &#125; set(val)&#123; b = val - a &#125; &#125;&#125;let cal = Calcuator();print(cal.sum) //2cal.sum = 5print(cal.b) //4 对于set有简写方法，简写时，新赋的值默认为newValue 12345678910111213class Calcuator&#123; var a:Int = 1; var b:Int = 1; var sum:Int&#123; get&#123; return a + b &#125; set&#123; b = newValue - a &#125; &#125;&#125; 如果只要get，不要set方法 12345678class Calcuator&#123; var a:Int = 1; var b:Int = 1; var sum:Int&#123; return a + b &#125;&#125; 遍历一个目录下的所有文件123456789101112131415161718192021222324252627//1.首先我们获取用户文档目录路径let manager = FileManager.defaultlet urlForDocument = manager.urls(for: .documentDirectory, in:.userDomainMask)let url = urlForDocument[0] as URLprint(url)//2.对指定路径执行浅搜索，返回指定目录路径下的文件、子目录及符号链接的列表let contentsOfPath = try? manager.contentsOfDirectory(atPath: url.path)print("contentsOfPath: \(contentsOfPath)")//3.类似上面的，对指定路径执行浅搜索，返回指定目录路径下的文件、子目录及符号链接的列表let contentsOfURL = try? manager.contentsOfDirectory(at: url, includingPropertiesForKeys: nil, options: .skipsHiddenFiles)print("contentsOfURL: \(contentsOfURL)")//4.深度遍历，会递归遍历子文件夹（但不会递归符号链接）let enumeratorAtPath = manager.enumerator(atPath: url.path)print("enumeratorAtPath: \(enumeratorAtPath?.allObjects)")//5.类似上面的，深度遍历，会递归遍历子文件夹（但不会递归符号链接）let enumeratorAtURL = manager.enumerator(at: url, includingPropertiesForKeys: nil, options: .skipsHiddenFiles, errorHandler:nil)print("enumeratorAtURL: \(enumeratorAtURL?.allObjects)")//6.深度遍历，会递归遍历子文件夹（包括符号链接，所以要求性能的话用enumeratorAtPath）let subPaths = manager.subpaths(atPath: url.path)print("subPaths: \(subPaths)") 判断文件或文件夹是否存在 法一： 123456let myDirectory:String = NSHomeDirectory() + "/Documents/myFolder/Files"let fileManager = FileManager.default //withIntermediateDirectories为ture表示路径中间如果有不存在的文件夹都会创建try! fileManager.createDirectory(atPath: myDirectory, withIntermediateDirectories: true, attributes: nil) 法二 12345678910111213141516func createFolder(name:String,baseUrl:NSURL)&#123; let manager = FileManager.default let folder = baseUrl.appendingPathComponent(name, isDirectory: true) print("文件夹: \(folder)") let exist = manager.fileExists(atPath: folder!.path) if !exist &#123; try! manager.createDirectory(at: folder!, withIntermediateDirectories: true, attributes: nil) &#125;&#125; //在文档目录下新建folder目录let manager = FileManager.defaultlet urlForDocument = manager.urls(for: .documentDirectory, in: .userDomainMask)let url = urlForDocument[0] as NSURLcreateFolder(name: "folder", baseUrl: url) 将对象写入文件可以通过write(to:)方法，可以创建文件并将对象写入，对象包括String，NSString，UIImage，NSArray，NSDictionary等。 1234567891011121314151617181920212223//把String保存到文件let filePath:String = NSHomeDirectory() + "/Documents/hangge.txt"let info = "欢迎来到hange.com"try! info.write(toFile: filePath, atomically: true, encoding: String.Encoding.utf8)//把图片保存到文件路径下let filePath = NSHomeDirectory() + "/Documents/hangge.png"let image = UIImage(named: "apple.png")let data:Data = UIImagePNGRepresentation(image!)!try? data.write(to: URL(fileURLWithPath: filePath))//把NSArray保存到文件路径下let array = NSArray(objects: "aaa","bbb","ccc")let filePath:String = NSHomeDirectory() + "/Documents/array.plist"array.write(toFile: filePath, atomically: true)//把NSDictionary保存到文件路径下let dictionary:NSDictionary = ["Gold": "1st Place", "Silver": "2nd Place"]let filePath:String = NSHomeDirectory() + "/Documents/dictionary.plist"dictionary.write(toFile: filePath, atomically: true) 创建文件1234567891011121314151617181920func createFile(name:String, fileBaseUrl:URL)&#123; let manager = FileManager.default let file = fileBaseUrl.appendingPathComponent(name) print("文件: \(file)") let exist = manager.fileExists(atPath: file.path) if !exist &#123; let data = Data(base64Encoded:"aGVsbG8gd29ybGQ=" ,options:.ignoreUnknownCharacters) let createSuccess = manager.createFile(atPath: file.path,contents:data,attributes:nil) print("文件创建结果: \(createSuccess)") &#125;&#125; //在文档目录下新建test.txt文件let manager = FileManager.defaultlet urlForDocument = manager.urls( for: .documentDirectory, in:.userDomainMask)let url = urlForDocument[0]createFile(name:"test.txt", fileBaseUrl: url)//createFile(name: "folder/new.txt", fileBaseUrl: url) 复制文件 法一: 12345let fileManager = FileManager.defaultlet homeDirectory = NSHomeDirectory()let srcUrl = homeDirectory + "/Documents/hangge.txt"let toUrl = homeDirectory + "/Documents/copyed.txt"try! fileManager.copyItem(atPath: srcUrl, toPath: toUrl) 法二： 12345678910// 定位到用户文档目录let manager = FileManager.defaultlet urlForDocument = manager.urls( for:.documentDirectory, in:.userDomainMask)let url = urlForDocument[0] // 将test.txt文件拷贝到文档目录根目录下的copyed.txt文件let srcUrl = url.appendingPathComponent("test.txt")let toUrl = url.appendingPathComponent("copyed.txt") try! manager.copyItem(at: srcUrl, to: toUrl) 移动文件 法一： 12345let fileManager = FileManager.defaultlet homeDirectory = NSHomeDirectory()let srcUrl = homeDirectory + "/Documents/hangge.txt"let toUrl = homeDirectory + "/Documents/moved/hangge.txt"try! fileManager.moveItem(atPath: srcUrl, toPath: toUrl) 法二： 123456789// 定位到用户文档目录let manager = FileManager.defaultlet urlForDocument = manager.urls( for: .documentDirectory, in:.userDomainMask)let url = urlForDocument[0] let srcUrl = url.appendingPathComponent("test.txt")let toUrl = url.appendingPathComponent("copyed.txt")// 移动srcUrl中的文件（test.txt）到toUrl中（copyed.txt）try! manager.moveItem(at: srcUrl, to: toUrl) 删除文件 法一： 1234let fileManager = FileManager.defaultlet homeDirectory = NSHomeDirectory()let srcUrl = homeDirectory + "/Documents/hangge.txt"try! fileManager.removeItem(atPath: srcUrl) 法二： 12345678// 定位到用户文档目录let manager = FileManager.defaultlet urlForDocument = manager.urls(for: .documentDirectory, in:.userDomainMask)let url = urlForDocument[0] let toUrl = url.appendingPathComponent("copyed.txt")// 删除文档根目录下的toUrl路径的文件（copyed.txt文件）try! manager.removeItem(at: toUrl) 删除目录下所有的文件 法一：获取所有文件，然后遍历删除 123456let fileManager = FileManager.defaultlet myDirectory = NSHomeDirectory() + "/Documents/Files"let fileArray = fileManager.subpaths(atPath: myDirectory)for fn in fileArray!&#123; try! fileManager.removeItem(atPath: myDirectory + "/\(fn)")&#125; 法二：删除目录后重新创建该目录 12345let fileManager = FileManager.defaultlet myDirectory = NSHomeDirectory() + "/Documents/Files"try! fileManager.removeItem(atPath: myDirectory)try! fileManager.createDirectory(atPath: myDirectory, withIntermediateDirectories: true, attributes: nil) 读取文件123456789101112131415let manager = FileManager.defaultlet urlsForDocDirectory = manager.urls(for: .documentDirectory, in:.userDomainMask)let docPath = urlsForDocDirectory[0]let file = docPath.appendingPathComponent("test.txt") //方法1let readHandler = try! FileHandle(forReadingFrom:file)let data = readHandler.readDataToEndOfFile()let readString = String(data: data, encoding: String.Encoding.utf8)print("文件内容: \(readString)") //方法2let data2 = manager.contents(atPath: file.path)let readString2 = String(data: data2!, encoding: String.Encoding.utf8)print("文件内容: \(readString2)") 在任意位置写入数据12345678910let manager = FileManager.defaultlet urlsForDocDirectory = manager.urls(for:.documentDirectory, in:.userDomainMask)let docPath = urlsForDocDirectory[0]let file = docPath.appendingPathComponent("test.txt") let string = "添加一些文字到文件末尾"let appendedData = string.data(using: String.Encoding.utf8, allowLossyConversion: true)let writeHandler = try? FileHandle(forWritingTo:file)writeHandler!.seekToEndOfFile()writeHandler!.write(appendedData!) 文件权限判断12345678910111213let manager = FileManager.defaultlet urlForDocument = manager.urls(for: .documentDirectory, in:.userDomainMask)let docPath = urlForDocument[0]let file = docPath.appendingPathComponent("test.txt") let readable = manager.isReadableFile(atPath: file.path)print("可读: \(readable)")let writeable = manager.isWritableFile(atPath: file.path)print("可写: \(writeable)")let executable = manager.isExecutableFile(atPath: file.path)print("可执行: \(executable)")let deleteable = manager.isDeletableFile(atPath: file.path)print("可删除: \(deleteable)") 获取文件属性（创建时间，修改时间，文件大小，文件类型等信息）1234567let manager = FileManager.defaultlet urlForDocument = manager.urls(for: .documentDirectory, in:.userDomainMask)let docPath = urlForDocument[0]let file = docPath.appendingPathComponent("test.txt") let attributes = try? manager.attributesOfItem(atPath: file.path) //结果为Dictionary类型print("attributes: \(attributes!)") 文件/文件夹比较123456789101112131415let manager = FileManager.defaultlet urlForDocument = manager.urls(for: .documentDirectory, in:.userDomainMask)let docPath = urlForDocument[0]let contents = try! manager.contentsOfDirectory(atPath: docPath.path) //下面比较用户文档中前面两个文件是否内容相同（该方法也可以用来比较目录）let count = contents.countif count &gt; 1 &#123; let path1 = docPath.path + "/" + (contents[0] as String) let path2 = docPath.path + "/" + (contents[1] as String) let equal = manager.contentsEqual(atPath: path1,andPath:path2) print("path1：\(path1)") print("path2：\(path2)") print("比较结果： \(equal)")&#125; UILabel的富文本设置12345678910111213//富文本设置let attributeString = NSMutableAttributedString(string:"welcome to hangge.com")//从文本0开始6个字符字体HelveticaNeue-Bold,16号attributeString.addAttribute(NSFontAttributeName, value: UIFont(name: "HelveticaNeue-Bold", size: 16)!, range: NSMakeRange(0,6))//设置字体颜色attributeString.addAttribute(NSForegroundColorAttributeName, value: UIColor.blue, range: NSMakeRange(0, 3))//设置文字背景颜色attributeString.addAttribute(NSBackgroundColorAttributeName, value: UIColor.green, range: NSMakeRange(3,3))label.attributedText = attributeString UITextView 给文字中的电话号码和网址自动加链接 1234textview.dataDetectorTypes = [] //都不加链接textview.dataDetectorTypes = UIDataDetectorTypes.phoneNumber //只有电话加链接textview.dataDetectorTypes = UIDataDetectorTypes.link //只有网址加链接textview.dataDetectorTypes = UIDataDetectorTypes.all //电话和网址都加 自定义选择内容后的菜单 123456789let textview = UITextView(frame:CGRect(x:10, y:100, width:200, height:100))textview.layer.borderWidth = 1 //边框粗细textview.layer.borderColor = UIColor.gray.cgColor //边框颜色self.view.addSubview(textview)let mail = UIMenuItem(title: "邮件", action: #selector(ViewController.onMail))let weixin = UIMenuItem(title: "微信", action: #selector(ViewController.onWeiXin))let menu = UIMenuController()menu.menuItems = [mail,weixin] 滑块（UISlider）自定义滑块组件图片123456//设置滑块右边部分的图片slider.setMaximumTrackImage(UIImage(named:"slider_max"),forState:UIControlState.Normal)//设置滑块左边部分的图片slider.setMinimumTrackImage(UIImage(named:"slider_min"),forState:UIControlState.Normal)//设置滑块的图片slider.setThumbImage(UIImage(named:"slider_thumb"),forState:UIControlState.Normal) 1234//设置滑块右边部分的图片-使用三宫格缩放（左右14像素不变，中间缩放）let imgTrackRight = UIImage(named:"slider_max")let imgRight = imgTrackRight!.stretchableImageWithLeftCapWidth(14, topCapHeight:0)slider.setMaximumTrackImage(imgRight, forState:UIControlState.Normal)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift3学习笔记（七）]]></title>
      <url>%2F2017%2F01%2F23%2FSwift3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
      <content type="text"><![CDATA[用 Swift 运行时获取对象属性列表1234567891011121314151617181920212223242526272829303132333435363738394041424344import UIKitclass Person: NSObject &#123; var name: String? var age: Int = 0 var title: String? //类方法 ///目标：[使用运行时]获取当前类所有属性的数组 class func propertyList() -&gt; [String] &#123; var count: UInt32 = 0 //1.获取“类”的属性列表，返回属性列表的数组。可选项 //其中的UnsafeMutablePointer是可变的UInt32类型的指针 let list = class_copyPropertyList(self, &amp;count) print("属性的数量\(count)"); //2.遍历数组 for i in 0..&lt;Int(count) &#123; //3.根据下标获取属性 let pty = list?[i] //4.获取属性的名称 C 语言字符串 //Int8 -&gt; byte -&gt; char -&gt; C语言的字符串 let cName = property_getName(pty!) //5.转成OC（String）的字符串 let name = String(utf8String: cName!) print(name) &#125; //释放C语言对象 free(list) //返回一个空数组，而不是nil return [] &#125;&#125; 运行时观察属性的情况&amp;guard语法守护1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import UIKitclass Person: NSObject &#123; var name: String? //基础数据类型 ，在OC中没有可选，如果定义成可选，运行时同样获取不到，使用kvc就会奔溃！ //var age:Int? var age: Int = 0 //private的属性使用运行时，同样获取不到属性（可以获取到ivar），同样谁让KVC崩溃 private var title: String? //类方法 ///目标：[使用运行时]获取当前类所有属性的数组 ///获取ivar列表是所有第三方框架字典转模型的基础 class func propertyList() -&gt; [String] &#123; var count: UInt32 = 0 //1.获取“类”的属性列表，返回属性列表的数组。可选项 //其中的UnsafeMutablePointer是可变的UInt32类型的指针 let list = class_copyPropertyList(self, &amp;count) print("属性的数量\(count)"); //2.遍历数组 for i in 0..&lt;Int(count) &#123; //3.根据下标获取属性 //使用guard语法一次判断每一项是否有值，只要有一项为nil，就不再执行后面的代码 guard let pty = list?[i],let cName = property_getName(pty),let name = String(utf8String: cName) else &#123; //继续遍历下一个 continue &#125; //name是一定有值的 print(name) &#125; //释放C语言对象 free(list) //返回一个空数组，而不是nil return [] &#125;&#125; 使用 session 加载百度数据123456789101112131415161718192021222324252627282930override func viewDidLoad() &#123; super.viewDidLoad() //URL的构造函数可以返回nil //构造函数就是实例化对象的 let url = URL(string: "http://www.baidu.com") //发起网络请求 //- 和OC的区别就是，闭包里面所有的参数需要自己写，OC直接带出 //- 如果不关心的值可以直接”_“忽略 URLSession.shared.dataTask(with: url!) &#123; (data, _, error) in// if (error != nil) &#123;// print("网络请求失败")// &#125; guard let data = data else&#123; print("网络请求失败\(error)") return &#125; //将data转换为String let html = String(data: data, encoding: .utf8) print(html) &#125;.resume()//session需要加上 &#125; 利用遍历构造函数判断对象创建条件1234567891011121314151617181920212223242526272829303132333435import UIKitclass Person: NSObject &#123; var name: String? var age: Int = 0 /** 1.遍历构造函数允许返回nil - 正常的构造函数一定会创建对象 - ** 判断构造函数是否符合条件，如果不符合条件，直接返回nil 2.**只有** 遍历构造函数中使用“self.init”构造当前对象 - 没有convenience关键字的构造函数是负责创建对象，反之，用来检查条件的，本身不负责对象的创建 3.如果在遍历构造函数中使用当前对象的属性，一定要在self.init方法之后 */ /// 'self' used before self.init call //解决方法，在里面加上self.init() convenience init?(name: String,age: Int) &#123; if age &gt; 200 &#123; return nil &#125; ///Use of 'self' in property access 'name' before self.init initializes self //使用self 访问name 之前，应该调用self.init //self.name = name self.init() //执行到此 self才允许被访问，才能够访问到对象的属性 self.name = name &#125;&#125; 便利构造函数抽取控件创建方法设置UITextFiled+Extension 1234567891011121314import UIKitextension UITextField &#123; convenience init(frame: CGRect,placeholder: String = "sdf",fontSize: CGFloat = 14) &#123; //实例化当前对象 self.init(frame:frame) //访问属性 self.borderStyle = .roundedRect self.placeholder = placeholder self.font = UIFont.systemFont(ofSize: fontSize) &#125;&#125; 创建UIButton+Extension 123456789101112import UIKitextension UIButton &#123; convenience init(frame: CGRect , title: String = "按钮" , color: UIColor = UIColor.darkGray) &#123; self.init(frame: frame) self.setTitle(title, for: .normal) self.setTitleColor(color, for: .normal) self.sizeToFit() &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift3学习笔记（六）]]></title>
      <url>%2F2017%2F01%2F21%2FSwift3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
      <content type="text"><![CDATA[必选属性的构造过程12345678910111213141516171819202122232425262728/** 1.给自己的属性分配空间并且设置初始值 2.调用父类的构造方法之前，先给本类的属性设置初始值 3.调用父类的“构造函数”，给父类的属性分配空间设置初始值 NSObject 没有属性，只有一个成员变量'isa' *///1. Class 'Person' has no initializers//Person类没有“初始化器”s，构造函数。可以有多个，默认的是initclass Person: NSObject &#123; var name: String //2.Overriding declaration requires an 'override' keyword //如果重写一个方法的话，如果父类有这个方法，子类需要重写的话就必须加上override //3.Property 'self.name' not initialized at implicitly generated super.init call //implicitly(隐式生成 super.init),调用父类的构造函数之前,属性self.name没有被初始化 override init() &#123; //必须加载super.init()之前 name = "" //4. Property 'self.name' not initialized at super.init call //这里的提示是给self.name初始化，分配内存空间，设置初始值 super.init() &#125; &#125; ViewController.swift 123456789101112131415161718192021import UIKit/** 在Swift中，默认同一个项目中（同一个命名空间下），所有的类都是共享的，可以直接访问到，不需要import 所有的对象属性 var，也可以直接访问到 */class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() //实例化Person类 //() -&gt; alloc/init //swift中对应一个函数 init构造函数 //给成员变量分配空间，初始化成员变量 let p = Person() print(p.name) p.name = "xu" print(p.name) &#125;&#125; 注：如果是子类的构造方法，他的是执行顺序是： 先执行子类的构造方法，再执行父类的构造方 重载构造方法12345678910111213141516171819202122232425262728293031import UIKit/** 如果重载了构造函数，并且没有实现父类 init方法，系统不再提供init() 构造方法（默认是会有的） - 因为默认的构造函数，不能给本类的属性分配空间!*/class Person: NSObject &#123; var name: String //重写：父类有这个方法 override init() &#123; //问题：name 确实有初始值，但是所有的初始值都是Feyddy name = "Feyddy" super.init() &#125; //重载，函数名相同，但是参数的个数不同 //重载可以给自己的属性从外部设置初始值 init(name: String) &#123; //使用参数的name设置成属性 self.name = name //调用父类的构造函数 super.init() &#125;&#125; 然后在ViewController里面创建对象的时候就会有两种方法 12let p = Person(name: "xuzongli")let p2 = Person() 但是如果除去“重写：父类有这个方法“那就只会剩下重载的那个方法 KVC函数调用的基本实现及KVC构造函数中基本数据类型和私有属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import UIKit/** 1.在定义模型的时候，如果是对象，通常都是可选的 -在需要的时候创建 -避免写构造函数，可以简化代码 2.如果是基本数据类型，不能设置成可选的，而且要设置初始值，否则KVC会奔溃 3.如果需要使用KVC设置数据，属性不能是private 4.在使用KVC方法之前应该调用super.init()，保证对象实例化完成 */class Person: NSObject &#123; //name 属性是可选的，在OC中很多的属性都是在需要的时候创建的 //例如。vc.view / tableViewCell.textLabel / detailLabel / imageView //因为手机在开发，内存很宝贵，有些属性并不是一定需要分配空间的 //延迟加载，在需要的时候在创建 var name: String? //给基本数据类型属性初始化 // - 使用KVC会提示无法找到age 的Key // - 原因：Int是一个基本数据类型的结构体，OC中没有，OC中只有基本数据类型 //var age: Int? var age: Int = 0 //如果是private属性，使用KVC设置的时候，同样无法设置 //如果是private属性，是禁止外部访问的 private var title: String? //重载构造函数，使用字典为本类设置初始值 init(dict: [String: AnyObject]) &#123; //保障对象完全初始化完成(一定) super.init() //Use of 'self' in method call 'setValuesForKeys' before super.init initializes self //使用self 的方法“setValueForKeys”之前，应该调用 super.init //KVC的方法是OC的方法，在运行时给对象发送消息，要求对象已经实例化完成 setValuesForKeys(dict) //super.init()如果放在这个时候调用，对象还没有初始化完成 &#125; //重写父类的方法 override func setValue(_ value: Any?, forUndefinedKey key: String) &#123; //没有调用 super，将父类的代码实现完全覆盖！不会奔溃！ &#125;&#125; 子类构造函数的继承我们继承上面的类 123456import UIKitclass Student: Person &#123; var no: String?&#125; 在主控制器中实现初始化 1234let s = Student(dict: ["name":"wang" as AnyObject,"age":10 as AnyObject,"no":"100" as AnyObject,"xxx":"feyddy" as AnyObject]) print(s.no)//可以看出我们可以直接通过父类的KVC方法在子类的使用//如果我们想在初始化的时候添加上一个不存在的属性"xxx",这个时候就要在KVC构造方法的时候重写setValue(_ value: Any?, forUndefinedKey key: String)看上面的代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift3学习笔记（五）]]></title>
      <url>%2F2017%2F01%2F21%2FSwift3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
      <content type="text"><![CDATA[使用Swift实现循环引用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import UIKitclass ViewController: UIViewController &#123; //定义属性 var completionCallBack: (()-&gt;())? override func viewDidLoad() &#123; super.viewDidLoad() // block 中如果出现self 要特别小心 //- 只是闭包对 self 进行了copy,闭包执行完成之后，会自动销毁，同时释放对self的引用 //- 同时需要self对闭包引用 loadData &#123; print(self.view) &#125; &#125; func loadData(completion: @escaping ()-&gt;()) -&gt; () &#123; //使用属性记录闭包-&gt;self对闭包引用.这个时候deinit不会运行，因为出现了循环引用 completionCallBack = completion //异步 DispatchQueue.global().async &#123; print("耗时操作") //尾随闭包 DispatchQueue.main.async &#123; //回调执行闭包 completion() &#125; &#125; &#125; //类似于OC中的dealloc //没有func -&gt; 不让调用 //没有() -&gt; 不让重载 //在对象被销毁前自动调用 deinit &#123; //1.跟踪对象的销毁 //2.必须释放 /** - 通知，不释放不会奔溃，但是会泄露 - KVO，不释放会奔溃 - NSTimer / CADisplayLink ,不销毁会出现循环应用 */ print("没有循环引用") &#125;&#125; 解除循环引用还是拿上面的代码进行解决 OC方式解决循环引用 123456789101112131415161718192021//***解除循环引用，需要打断链条 //细节1：var ：weak只能修饰var，不能修饰let //‘weak’ must be a mutable variable,because it may change at runtime //weak 可能会在运行时被修改-&gt;指向对象一旦被释放掉，会被自动设置为nil //ViewController? weak var weakSelf = self loadData &#123; //细节2： //解包的方式有两种 //？可选解包 - 如果 self 已经被释放，不会对对象发送 getter 消息，更加安全 //！强行解包 - 如果 self 已经被释放，强行解包会导致奔溃 /** weakSelf?.view - 只是单纯的发送消息，没有任的计算 强行解包，因为需要计算，可选项不能直接参与计算 */ print(weakSelf?.view) &#125; Swift解决循环引用 1234567891011121314//Swift推荐方法 //[weak self] 表示&#123;&#125;里面的self都是弱引用，需要注意解包 loadData &#123; [weak self] in print(self?.view) &#125; //Swift另外的用法，不推荐。不安全 //[unowned self]表示&#123;&#125;中的所有的self都是assgin的，不会强引用，但是，如果对象释放，指针地址不会变化 //如果对象被释放，继续调用，就会出现野指针的问题 loadData &#123; [unowned self] in print(self.view) &#125; OC代码中解决循环引用的两种方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#import &quot;FDViewController.h&quot;@interface FDViewController ()@end@implementation FDViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. /* //解除引用1：__weak __weak typeof(self) weakSelf = self; [self loadData:^&#123; NSLog(@&quot;%@&quot;,weakSelf.view); &#125;]; */ //解除引用2:__unsafe_unretained //如果需要自行管理内存，才使用 //EXC_BAD_ACCESS 坏内存访问，野指针访问 //__unsafe_unretained同样是 assign的引用（MRC中没有weak） //在MRC中如果要弱引用对象都是使用assign，不会增加引用计数，但是一旦对象被释放，地址不会改变，继续访问，出现野指针 //ARC weak ,本质上是一个官缠着模式，一旦发现对象被释放，会自动将地址设置为nil，更加安全 //效率：weak的效率会略微差一些 __unsafe_unretained typeof(self) weakSelf = self; [self loadData:^&#123; NSLog(@&quot;%@&quot;,weakSelf.view); &#125;];&#125;- (void)loadData:(void(^)()) completion &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;耗时操作 %@&quot;,[NSThread currentThread]); //睡眠 [NSThread sleepForTimeInterval:2.0]; dispatch_async(dispatch_get_main_queue(), ^&#123; //执行block completion(); &#125;); &#125;);&#125;@end ​ ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift3学习笔记（四）]]></title>
      <url>%2F2017%2F01%2F19%2FSwift3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
      <content type="text"><![CDATA[闭包的定义格式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import UIKitclass ViewController: UIViewController &#123; /** 闭包 1.提前准备好的代码 2.在需要的时候执行 3.可以当做参数 */ override func viewDidLoad() &#123; super.viewDidLoad() //1&gt;最简单的闭包 //() -&gt; ()没有参数，没有返回值的函数 //如果没有参数，没有返回值，可以省略，连in都一起省略 let b1 = &#123; print("hello") &#125; //执行闭包 b1(); //2&gt;带参数的闭包 //闭包中的参数，返回值，实现代码都是写在花括号里面 //需要使用一个关键字`in`用来分隔定义和实现 //&#123;形参列表 -&gt; 返回值类型 `in` //实现代码&#125; let b2 = &#123;(x: Int)-&gt;() in print(x) &#125; b2(100) //3&gt;带参数返回值的闭包 //(Int)-&gt;(Int) let b3 = &#123;(x: Int) -&gt; Int in return x + 10 &#125; print(b3(100)) &#125;&#125; GCD将任务添加到队列，指定执行任务的函数，即，队列调度任务（block/闭包），以同步或者异步的方式执行 1234567891011121314151617//在异步执行任务，获取结果，通过block/闭包回调//闭包的应用场景和block完全一致func loadData() &#123; //将任务添加到队列，指定执行任务的函数，即，队列调度任务（block/闭包），以同步或者异步的方式执行 DispatchQueue.global().async &#123; print("耗时操作\(Thread.current)") //休眠 Threa //主队列回调 DispatchQueue.main.async(execute: &#123; print("主线程更新 UI\(Thread.current)") &#125;) &#125; &#125; 通过闭包回调传递参数123456789101112131415161718192021222324252627282930313233343536373839import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() loadData &#123; (result) in print("获取数据\(result)") &#125; &#125; //@escaping逃逸闭包，即该闭包实在函数执行完成后才开始执行 func loadData(completion: @escaping (_ result: [String])-&gt;()) -&gt; () &#123; //将任务添加到队列，指定执行任务的函数，即，队列调度任务（block/闭包），以同步或者异步的方式执行 DispatchQueue.global().async &#123; print("耗时操作\(Thread.current)") //休眠 Thread.sleep(forTimeInterval: 1.0) //获取结果 let json = ["头条","八卦","娱乐"] //主队列回调 DispatchQueue.main.async(execute:&#123; print("主线程更新 UI\(Thread.current)") //回调 -&gt; 执行闭包（通过参数传递） //传递异步获取的结果 completion(json) &#125;) &#125; &#125;&#125; 尾随闭包1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() //尾随闭包 //如果函数的最后一个参数是闭包，函数参数可以提前结束，最后一个参数直接使用&#123;&#125;包装闭包的代码 //// loadData(completion: (result: [String]) -&gt; ())// loadData &#123; (result) in// print(result)// &#125; //按照函数本身编写的结果 loadData(completion: &#123;(result) -&gt; () in print(result) &#125;) &#125; func demo() -&gt; () &#123; //尾随闭包 DispatchQueue.global().async &#123; //嵌套的GCD Xcode不会改成尾随闭包 DispatchQueue.main.async(execute: &#123; &#125;) &#125; //尾随闭包 DispatchQueue.main.async &#123; &#125; &#125; //@escaping逃逸闭包，即该闭包实在函数执行完成后才开始执行 func loadData(completion: @escaping (_ result: [String])-&gt;()) -&gt; () &#123; //将任务添加到队列，指定执行任务的函数，即，队列调度任务（block/闭包），以同步或者异步的方式执行 DispatchQueue.global().async &#123; print("耗时操作\(Thread.current)") //休眠 Thread.sleep(forTimeInterval: 1.0) //获取结果 let json = ["头条","八卦","娱乐"] //主队列回调 DispatchQueue.main.async(execute:&#123; print("主线程更新 UI\(Thread.current)") //回调 -&gt; 执行闭包（通过参数传递） //传递异步获取的结果 completion(json) &#125;) &#125; &#125;&#125; OC{}的一个坑（作用于）下面是错误的例子： 12345678910let l = UILabel()//(1)参数结束&#123;尾随闭包&#125;view.addSubView(l)//Extra argument in call//调用了·额外·的参数&#123; let l = UILabel() view.addSubView(l)&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift3学习笔记（三）]]></title>
      <url>%2F2017%2F01%2F19%2FSwift3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
      <content type="text"><![CDATA[函数的基本使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() //调用方法 print(sum(x: 10, y: 40)) //外部参数的调用 print(sum1(num1: 10, num2: 100)) print(sum2(10, 20)) //测试默认值 print(defaultValue()) print(defaultValue(x: 10, y: 20)) print(defaultValue(y: 20)) print(defaultValue(x: 10)) //无返回值 noReturn1() noReturn2() noReturn3() &#125; // MARK: - 函数定义 /// 函数定义的格式：函数名(形参列表) -&gt; 返回值类型 /// /// - Parameters: /// - x: 形参1 /// - y: 形参2 /// - Returns: 返回值 func sum(x: Int , y: Int) -&gt; Int &#123; return x + y &#125; // MARK: - 外部参数 /// -外部参数就是在函数前面加上一个名字 /// -外部参数不会影响函数内部的细节 /// -外部参数会让外部调用方法的时候更加直观 /// -外部参数如果使用_，在外部调用函数时，会忽略形参的名字 func sum2(_ x: Int,_ y: Int) -&gt; Int &#123; //在Swift中 _ 就是可以忽略任意不感兴趣的内容 //从来没有被用到的数据可以用_来替代,如下面的i for i in 0..&lt;10 &#123; print("hello") &#125; return x+y &#125; func sum1(num1 x: Int, num2 y: Int) -&gt; Int &#123; return x+y &#125; // MARK: - 默认值 //通过给参数设置默认值，在调用的时候，可以任意组合参数，然后没有赋值的参数就是用默认的函数中定义的值 func defaultValue(x: Int = 1,y: Int = 11) -&gt; Int &#123; return x+y &#125; // MARK: - 无返回值 /* 主要用在闭包 - 直接省略 - （） - void */ func noReturn1() -&gt; Void &#123; print("Void") &#125; func noReturn2() -&gt; () &#123; print("()") &#125; func noReturn3() &#123; print("省略") &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift3.0学习笔记（二）]]></title>
      <url>%2F2017%2F01%2F19%2FSwift3-0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[数组123456789101112131415161718192021222324252627func arrayDemo() &#123; //[Int]-&gt;表示存放的都是Int类型的数据 //Swift中基本数据类型不需要包装 let array1 = [1,2,3,4,5,6] print(array1) //结构体:不需要包装 let p = CGPoint(x: 10, y: 20) //[CGPoint] let array2 = [p]; print(array2) //混合数组：开发中几乎不用，因为数组是靠下标索引 //如果数组中的类型不一致，自动推导的结果就是NSObject //Swfit 中还有一个[AnyObject] - &gt; 任意对象 //Swift中一个类可以没有任何“父类” //AnyObject范围大于NSObject /**在混合数组中CG结构体需要包装*/ //let array3 = ["Feyddy",1,p]//报错：需要包装 //现在必须要在后面加上 as [Any]（这个在Swift3.0的时候还不需要的） let array3 = ["Feyddy",1,NSValue(cgPoint: p)] as [Any] print(array3) &#125; 数组的遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//遍历数组 func arrayTraverse() &#123; let array = ["feyddy","crise","dirk"]; //1.按照下标遍历 print("--------按照下标遍历--------") for i in 0..&lt;array.count &#123; print(array[i]) &#125; //2.遍历元素 print("--------遍历元素--------") for s in array &#123; print(s) &#125; //3.enum block 遍历，同时遍历下标和内容1 print("--------同时遍历下标和内容1--------") for e in array.enumerated() &#123; //元组 print(e) print("\(e.offset),\(e.element)") &#125; //4.同时遍历下标和内容2 print("--------同时遍历下标和内容2--------") //n为下标，s为数组的元素，这两个可以随便写 for (n,s) in array.enumerated() &#123; print("\(n),\(s)") &#125; //5.反序遍历 print("--------反序遍历--------") for e in array.reversed() &#123; print(e) &#125; //6.反序遍历索引和内容 print("--------反序遍历索引和内容--------") print("--------错误的反序遍历索引和内容--------") for (n,s) in array.reversed().enumerated() &#123; print("\(n):\(s)") &#125; print("--------正确的的反序遍历索引和内容--------") for (n,s) in array.enumerated().reversed() &#123; print("\(n):\(s)") &#125; &#125; 数组的增删改和容量1234567891011121314151617181920212223242526272829//增删改 func arrayOperation() &#123; //可变数组用var var array = ["feyddy","crise","dirk"]; //追加元素 array.append("dog") print(array) //修改,通过下标定位 array[1] = "wang" print(array) //数组越界：Index out of range //array[4] = "xxx" //删除 array.remove(at: 3) print(array) //删除全部，并且保留空间 array.removeAll(keepingCapacity: true) print("\(array)\(array.capacity)") &#125; 123456789101112131415161718192021//数组的容量 func arrayCapacity() &#123; //定义一个数组，指定类型存放Int的数组 //var array: [Int] //给数组初始化 //array = [Int]() //以上两句代码可以合并成一句 var array = [Int]() print("初始容量\(array.capacity)") for i in 0..&lt;8 &#123; array.append(i)//插入时如果容量不够了，容量就*2 &#125; print("\(array)容量\(array.capacity)") &#125; 数组的合并注意：要合并数组的两个数组内的元素的类型必须一致 1234567891011121314//数组的合并 func arrayMerge() &#123; var array = ["feyddy","crise","dirk"]; let array2 = ["linlin","chenchen"]; //将array2的内容合并到array上 //注意：要合并数组的两个数组内的元素的类型必须一致 array += array2 print(array) //如果要合并一个元素不一样数组// var array3: [NSObject] = ["feyddy" as NSObject,"crise" as NSObject,"dirk" as NSObject]; &#125; 字典操作字典的定义12345678910111213141516171819202122232425//字典的定义 func dictionaryDefine() &#123; //KEY:VALUE -&gt; [String:Any] let dict = ["name":"Feyddy","age":25] as [String : Any]; print(dict) //定义字典数组-提示 这种格式在开发中使用的最多 let array = [ ["name":"Feyddy", "age":25, "sex":"M"], ["name":"dirk", "age":55, "sex":"M"], ["name":"Chen", "age":18, "sex":"F"], ] print(array) &#125; 字典的增删改123456789101112131415161718192021//字典的增删改 func dictionaryOperation() &#123; //可变 var / 不可变 let var dict = ["name":"Feyddy","age": 25] as [String : Any]; //新增 - 如果key不存在就是新增 dict["sex"] = "M" print(dict) //修改--字典中通过key取值的，key是唯一的 //key存在就是修改 dict["name"] = "linlin" print(dict) //删除 - 直接给定KEY //字典通过KEY来定位。KEY必须可以“hash 哈希” MD5一种 //hash 就是将字符串变成唯一的“整数”，便于查找，提高字典的遍历速度 dict.removeValue(forKey: "age") print(dict) &#125; 字典的遍历1234567891011121314151617181920//字典的遍历 func dictionaryTraverse() &#123; let dict = ["name":"Feyddy","age": 25,"sex":"M"] as [String : Any]; //元组形式 for e in dict &#123; //(key:value) print(e) print("\(e.key):\(e.value)") &#125; /* 前面是key 后面是value */ for (key,value) in dict &#123; print("\(key):\(value)") &#125; &#125; 字典的合并1234567891011121314151617//字典的合并 func dictionaryMerge() &#123; var dict = ["name":"Feyddy","age": 25,"sex":"M"] as [String : Any]; let dict1 = ["title":"info"] //字典不能直接相加 //遍历dict1 依次设置 //如果key存在，直接修改，若不存在，直接添加 //添加的地方时无序的 for e in dict1 &#123; dict[e.key] = dict1[e.key] &#125; print(dict) &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift3.0学习笔记（一）]]></title>
      <url>%2F2017%2F01%2F18%2FSwift3-0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[增加文档注释单行注释(///) 1///单行注释形式 多行注释(/**/)：能够自动识别匹配最近的*/ 12345/*多行注释外圈 /* 多行注释里圈 */*/ 文档内容解释注释(option+cmd+/) 12345678910/// &lt;#Description#&gt; /// /// - Parameters: /// - application: &lt;#application description#&gt; /// - launchOptions: &lt;#launchOptions description#&gt; /// - Returns: &lt;#return value description#&gt; func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; // Override point for customization after application launch. return true &#125; xcode8常用特性 颜色选择器的显示(color+回车) 图片选择插件 MARK标记 类似于OC中的警告 TODO: ​ FIXME: ​ Swift的常量与变量let定义常量，一旦定义为常量，将不能修改 var定义变量，可以直接修改 变量常量的类型会根据等号右侧的代码推到对应类型 在Swift中对于类型的要求是异常严格的，任何类型之间不允许直接运算，不会做默认的隐式转换，必须有程序员直接转换。 Swift中不存在基本数据类型，都是结构体。Int也是结构体 123456789let x = 10let y = 10.5print(x+y)//报错print(x + Int(y))//或者直接在定义的时候说明类型(极少使用，一般都是自动推导)let x1: Double = 10.1 可选项(Optional)我们在定义一个变量或者常量的时候，一定要记得先初始化 原始的可选项定义 1let x: Optional = 10 简单的定义 1let y: Int? = 40//定义y是一个可选的Int类型，可能为nil，也可能为一个整数 输出结果 1Optional(10)//提示这是一个可选值 不同数据类型之间不能直接运算，如果为nil，那就不是任何的数据类型了，不能参与计算的 强行解包:从可选值中强行获取对应的非空值，如果真的是nil，就会崩溃! 1print(x!+y!) 所以，每个程序猿必须对!负责。少用! 可选值对变量和常量的不同的影响12345678910111213141516///定义一个y,，没有初始化let y: Int?//给常量赋值，初始化的工作只能做一次y = 20//两次修改，会报错//y = 30print(y)//var 的可选值默认为nil//let 的可选值没有默认值var x: Int?x = 100x = 200print(x) 简单的分支Swift要求的就是: 条件不需要() 语句必须有{} 123456let x = 10if x &gt; 10 &#123; print("大了")&#125;else &#123; print("小了")&#125; 三目12345let x = 3x &gt; 5 ? print("大了") : print("小了")//下面的()表示空执行，也就是什么都不做x &gt; 5 ? print("大了") : () ??的使用 ??其实是一个简单的三目运算符,也是对可选值解包的一种操作方式 如果有值，使用值 如果没值，使用??后面的值替代 123let x: Int? = nillet y: Int? = 10print((x ?? 0) + y)//结果就是10 缺点就是优先级比较低，所以在使用的时候一定要加上() if let/var的连用语法（判断值）if let 连用，判断对象的值是否为 nil，{}内一定有值，但是不可以修改值，可以直接使用，不需要解包 if var连用， 判断对象的值是否为 nil，{}内一定有值，但是可以修改值，可以直接使用，不需要解包 1234567891011let name: String? = nillet age: Int? = 20if var myName = name, let myAge = age &#123;//进入分支后，myName可以修改，myAge不可以修改，但是两者都一定有值，不需要解包//myName和myAge的作用于都只在&#123;&#125; print(myName + String(myAge))&#125;else&#123; print("Feyddy" + "10")&#125; guard(守护)guard let 和 if let正好相反 1234567891011let name: String? = "Feyddy"let age: Int? = 20guard let myName = name, let myAge = age else &#123; print("姓名或年龄中必有一个为nil") return&#125; //代码执行至此，name和age一定有值//通常判断是否有值，会做具体的逻辑实现//如果用if let 凭空多了一层分支，guard let 正好减少分支 if let和guard let的命名技巧使用同名的变量接受值，在后续使用的都是非空值，不需要解包 这个变量不能使用var在定义一次，否则会出现重复定义的错误，所以只有在函数里面传参数的时候用 123456func demo(name: String? , age: Int?) &#123; guard let name = name ,let age = age else &#123; return &#125; print(name + String(age)) &#125; {}在OC中的常用写法 {}为了限制作用域。里面可以定义一个和上面一样的变量名而不冲突。 123456789UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(0, 100, 200, 50)];label.backgroundColor = [UIColor orangeColor];[self.view addSubview:label];&#123; UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(0, 200, 200, 50)]; label.backgroundColor = [UIColor redColor]; [self.view addSubview:label];&#125; ​ {}包装代码，()表示执行 1234567891011121314UILabel *myLabel = (&#123; UILabel *labels = [[UILabel alloc] initWithFrame:CGRectMake(0, 300, 200, 50)]; labels.text = @&quot;里面的&quot;; labels.backgroundColor = [UIColor blueColor]; labels.textAlignment = NSTextAlignmentCenter; //末尾的labels会给myLabel设置数值 labels; &#125;); [self.view addSubview:myLabel]; 工作中看到最多的就是UITableView 123456789UITableView *myTableView = (&#123; UITableView *tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 350, 300, 100) style:UITableViewStylePlain]; //... tableView; &#125;); [self.view addSubview:myTableView]; switch相比OC中的switch用法比较扩展，不再局限于整数 swift中的switch特点： 可以对任意类型的值进行分支，不在局限在整数 一般不需要 break 如果多值，使用, 所有的分支至少需要一条指令，如果什么都不干才使用break 12345678910func demoSwitch(num: String) &#123; switch num &#123; case "8","9","10": let score = "good" print(score) case "7": break//此时的“7”这种情况不执行任何操作，但是至少有一条命令，➕break default: break &#125;&#125; case后面加上语句 123456789101112131415func whereDemo() &#123; let point = CGPoint(x: -10, y: 10) switch point &#123; case let p where p.x == 0 &amp;&amp; p.y == 0: print("原点") case let p where p.x == 0 : print("Y轴") case let p where p.y == 0: print("X轴") case let p where abs(p.x) == abs(p.y)://abs()函数为取绝对值 print("对角线") default: print("其他") &#125;&#125; for循环Swift3.0取消了传统的for循环语法 传统的for 在swift3.0中被取消 i++/++i 在swift3.0中被取消 Swift3.0对空格的要求比较严格 123456789101112131415161718192021222324252627func forDemo() &#123; //变量i 在[0,5] 循环 for i in 0...5 &#123; print(i) &#125; print("-----------------") //变量i 在[0,5) 循环 for i in 0..&lt;5 &#123; print(i) &#125; print("-----------------") //提示：范围定义是一个固定的格式 //CountableRange let r1 = 0..&lt;10 print(r1) //CountableClosedRange let r2 = 0...10 print(r2)&#125; 反序遍历12345func reversedDemo() &#123; for i in (0..&lt;10).reversed() &#123; print(i) &#125;&#125; 字符串遍历和长度的三种方法123456789//字符串的遍历 func characterDemo() &#123; //NSString 不支持以下方式遍历 let str: String = "我叫Feyddy" for c in str.characters &#123; print(c) &#125; &#125; 1234567891011121314151617181920//字符串的长度 func characterLength() &#123; let str = "Hello world Feyddy 忠林" //1.返回指定编码的对应的字节数量 //UTF8 的编码(0~4个)，每个汉字3个字节 print(str.lengthOfBytes(using: .utf8)) //2.字符串长度 - 返回字符的个数(推荐使用) print(str.characters.count) //3.使用 NSString 中转 /** str as NSString OC中的写法就是(FeyddyTableViewCell *)[tableView ...] Swift中可以使用 '值' as ‘类型’ 转换 */ let ocStr = str as NSString print(ocStr.length) &#125; 字符串的拼接和格式化12345678910111213141516171819202122232425//字符串的拼接 func appendString() &#123; let name = "Feyddy" let age = 25 let title: String? = "Boss" let point = CGPoint(x: 100, y: 100) //\(变量/常量) //拼接字符串需要注意 可选项(Optional) //OC中拼接point的时候:NSStringFromCGPoint(&lt;#CGPoint point#&gt;) let str = "\(name)\(age)\(title ?? "")\(point)" print(str) &#125; //字符串的格式化 func formatString() &#123; let h = 10 let m = 11 let s = 35 //使用格式字符串格式化 let dataStr = String(format: "%02d:%02d:%02d", h,m,s) print(dataStr) &#125; 字符串的子串1234567891011121314151617181920212223242526272829303132333435363738//字符串的子串 func subString() &#123; //建议：一般使用NSString作为中转，因为Swift取子串的方法一直在改 //更加容易理解 let str = "我们一起进步" //1.NSString let ocString = str as NSString let s1 = ocString.substring(with: NSMakeRange(1, 3))//从索引为1的位置开始往后取3个数 print(s1) //2.String 的3.0 方法 //Index //str.startIndex position = 0 //str.endIndex position = str.length let r1 = str.substring(to: "一起".endIndex) //let r11 = str.substring(to: "asd".endIndex) print(r1)//取的是“一起”（不包括“一起”）前面的所有的值，这里的“一起”和str里面的没有任何关系 //let r2 = str.substring(from: "一起".startIndex) let r22 = str.substring(from: "abc".startIndex) print(r22)//取的是str的开始位置为(String).startIndex == 0之后的所有的值 //3.取范围 guard let range = str.range(of: "一起") else &#123; print("没有找到字符串") return &#125; //一定找到字符串 print("---------") print(range) print(str.substring(with: range)) &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网络编程-NSURLConnection基本用法介绍]]></title>
      <url>%2F2017%2F01%2F17%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-NSURLConnection%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[NSURLConnection的基本使用简介NSURLConnection 这个名字，实际上是指代的 Foundation 框架的 URL 加载系统中一系列有关联的组件：NSURLRequest、NSURLResponse、NSURLProtocol、 NSURLCache、 NSHTTPCookieStorage、NSURLCredentialStorage 以及同名类 NSURLConnection。 NSURLConnection常用的类1、NSURL：根据url生成的请求地址 2、NSURLRequest：封装的一个请求，携带发送给服务器的全部数据，里面包含一个NSURL对象，请求方法，请求头，请求体等等。。 3、NSMutableURLRequest：这个是NSURLRequest的子类，通过名字我们可以看出这是一个可变的对象，我们可以在这里自定义设置发送的服务器的全部数据（超市等待时间、请求方法、请求体、请求头） 4、NSURLResponse：服务的响应类，和NSURLRequest对象，包含服务返回的响应头部数据 5、NSURLConnection：负责发送请求，建立客户端和服务器的连接。发送NSURLRequest的数据给服务器，并收集来自服务器的响应头部数据NSURLResponse或者NSData NSURLConnection使用步骤1、根据url创建一个NSURL对象 2、根据创建的NSURL创建一个NSURLRequest对象，创建请求对象（此对象内容全部都是默认值，如：请求方法默认是GET），如果想要自定数据则创建NSMutableURLRequest对象 3、最后使用NSURLConnection发送创建好的NSURLRequest或者NSMutableURLRequest对象，与服务器建立链接 非代理模式非代理模式中有提供了两个方法同步请求和异步请求(block实现) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101 //1.设置访问的url地址 self.imageUrl = @&quot;http://7xt5rm.com2.z0.glb.clouddn.com/picjumbo.com_download.jpg&quot;; //根据url生成的NSURL请求地址 NSURL *URL = [NSURL URLWithString:self.imageUrl]; //2.创建请求对象(NSMutableURLRequest) self.request = [NSMutableURLRequest requestWithURL:URL]; //3.设置请求相关的信息 //设置请求方式，默认是GET请求 request.HTTPMethod = @&quot;GET&quot;; //设置请求超时时间 request.timeoutInterval = 60; //设置请求头 //request.allHTTPHeaderFields = @&#123; // &#125;; //如果之前的key被设置过，则此方法会用新值覆盖旧值。 [request setValue:@&quot;User_Agent&quot; forHTTPHeaderField:@&quot;safari&quot;]; //如果之前的key被设置过，则此方法会将新值附加在旧值后，并用合适的符号分隔 //[request addValue:&lt;#(NSString *)#&gt; forHTTPHeaderField:&lt;#(NSString *)#&gt;]; //设置请求体(get方法没有) //发送同步请求 同步请求在主线程中执行 会一直在等待服务器返回数据，会阻塞主线程的执行，如果服务器没有返回数据，那么在主线程UI会卡住不能继续执行操作 //不建议这么做 //4.构造NSURLConnection，发送请求 NSURLResponse *response = nil; NSError *error = nil; NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error]; //5.获取响应头信息 NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response; //获取状态码 NSInteger statusCode = httpResponse.statusCode; NSLog(@&quot;状态码:%li&quot;, statusCode); //响应头 NSLog(@&quot;响应头:%@&quot;, httpResponse.allHeaderFields); //6.获取响应数据信息 if (data != nil) &#123; NSString *jsonString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; _textView.text = jsonString; //JSON解析 NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil]; NSLog(@&quot;dic:%@&quot;, dic); &#125; NSLog(@&quot;data length = %lu&quot;,(unsigned long)data.length); ------------------------------------------------------------------ //发送异步请求 //3.设置请求体：POST请求的请求参数是放在请求体中的。 NSString *paraText = @&quot;cinema_id=1533&quot;; request.HTTPBody = [paraText dataUsingEncoding:NSUTF8StringEncoding]; //设置压缩策略 [request setValue:@&quot;gzip&quot; forHTTPHeaderField:@&quot;Accept-Encoding&quot;]; //缓存策略 request.cachePolicy = NSURLRequestReturnCacheDataElseLoad; //异步请求需要一个队列来负责回调代码块的执行，当获取到返回数据是，会在这个线程队列中执行代码块，这里我们使用主队列， NSOperationQueue *queue=[NSOperationQueue mainQueue]; //异步请求传入一个^(NSURLResponse *response,NSData *data, NSError *connectionError)block代码块，当请求数据返回时，执行此代码块，此代码块有三个参数，respons响应头 data返回数据 connectionError错误代码 [NSURLConnection sendAsynchronousRequest:self.request queue:queue completionHandler:^(NSURLResponse *response,NSData *data, NSError *connectionError)&#123; NSLog(@&quot;response = %@&quot;,response); NSLog(@&quot;data = %@&quot;,data); NSLog(@&quot;error = %@&quot;,connectionError); if (connectionError) &#123; return; &#125; NSString *jsonString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; //回到主线程更新UI. dispatch_sync(dispatch_get_main_queue(), ^&#123; _textView.text = jsonString; &#125;); &#125;];//5.如何监听网络传输的进度，使用另一种发送异步请求的方式 //构建一个connection对象 NSURLConnection *connection = [NSURLConnection connectionWithRequest:request delegate:self]; //利用代理对象的协议方法来监听网络传输进度,所有的协议方法是在主线程被回调的，但是网络请求的过程是在多线程中处理的。 代理模式使用代理模式需要实现NSURLConnectionDataDelegate协议，此协议提供了几个代理方法，涵盖了请求交互的几个步骤 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#pragma mark - NSURLConnection delegate//网络请求失败会调用的协议方法- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error &#123; NSLog(@&quot;网络请求失败：%@&quot;, error); &#125;//获取到响应头时会调用的协议方法- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &#123; NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response; //获取状态码 NSInteger statusCode = httpResponse.statusCode; NSLog(@&quot;状态码:%li&quot;, statusCode); //响应头 NSLog(@&quot;响应头:%@&quot;, httpResponse.allHeaderFields); //定义NSData用来接收数据包 _receivedData = [[NSMutableData alloc] init]; &#125;//接收数据时会调用的协议方法，此方法可能被调用多次- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123; //将每次接收到的数据包附加在_receivedData后 [_receivedData appendData:data]; &#125;//接收数据完毕时会被调用的协议方法- (void)connectionDidFinishLoading:(NSURLConnection *)connection &#123; //将接收到的所有数据转化为NSString NSString *jsonString = [[NSString alloc] initWithData:_receivedData encoding:NSUTF8StringEncoding]; _textView.text = jsonString; &#125;//上传文件时调用的协议方法- (void)connection:(NSURLConnection *)connection didSendBodyData:(NSInteger)bytesWritten totalBytesWritten:(NSInteger)totalBytesWritten totalBytesExpectedToWrite:(NSInteger)totalBytesExpectedToWrite &#123; // bytesWritten：本次上传数据字节数// totalBytesWritten:累加上传数据字节数// totalBytesExpectedToWrite :上传文件总字节数 &#125; 音频下载接收500KB的数据就写入文件，释放其所占内存，以达到节约内存的目的。 ViewController.h 1234567#import &lt;UIKit/UIKit.h&gt;@interface ViewController : UIViewController@property (weak, nonatomic) IBOutlet UILabel *progressLabel;@property (weak, nonatomic) IBOutlet UIProgressView *progressView;- (IBAction)startDownload:(UIButton *)sender;@end ViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#import &quot;ViewController.h&quot;@interface ViewController ()&lt;NSURLConnectionDelegate,NSURLConnectionDataDelegate&gt;&#123; double _totalLength;//文件大小 double _receivedLength;//累加接受的数据的大小 NSMutableData *_totalData;//保存下载数据 BOOL _isLoading;//文件是否正在下载 NSString *_path;//下载文件的路径&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; _isLoading = NO;&#125;- (IBAction)startLoad:(UIButton *)sender &#123; if (!_isLoading) &#123; //构造URL NSURL *url = [NSURL URLWithString:@&quot;http://ws.stream.qqmusic.qq.com/59077847.m4a?continfo=73820346915A0B48DECCA0B4538EBAE8D0A505A652637707&amp;vkey=6601BF6508BEFF1A0B01887E58B6B38F63DB66AB2F16AFC2BB3510F0D979BADCC4F156907B95311B963170DFDDE231C33AEC78F6447259D9&amp;guid=beebe00086eb6ea85ed23db8d2d97e12f0214a04&amp;fromtag=53&amp;uin=837223065&quot;]; //构造request NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; //发送异步网络请求 [NSURLConnection connectionWithRequest:request delegate:self]; _isLoading = YES; //创建空文件夹来保存下载下来的数据 //设置文件名 NSString *file = @&quot;白龙马.mp3&quot;; //设置文件路径 _path = [NSHomeDirectory() stringByAppendingFormat:@&quot;/Documents/%@&quot;,file]; NSLog(@&quot;%@&quot;,_path); //创建空文件夹 [[NSFileManager defaultManager]createFileAtPath:_path contents:nil attributes:nil]; &#125; &#125;//把数据写入文件并到文件的末尾-(void)addFile:(NSData *)data&#123; if (data.length ==0 || _path.length == 0) &#123; return; &#125; //创建文件句柄 NSFileHandle *fileHandle = [NSFileHandle fileHandleForWritingAtPath:_path]; //把文件位置放到文件最后 [fileHandle seekToEndOfFile]; //写入数据 [fileHandle writeData:data]; //关闭文件 [fileHandle closeFile];&#125;#pragma mark - NSURLConnectionDelegate-(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response&#123; NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response; NSDictionary *fields = httpResponse.allHeaderFields; //获取下载文件大小 NSNumber *length = fields[@&quot;content-Length&quot;]; _totalLength = [length doubleValue]; _receivedLength = 0;//清零 _totalData = [[NSMutableData alloc]init];&#125;-(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data&#123; [_totalData appendData:data]; //通过当前下载的文件的大小来刷新显示 _receivedLength += data.length; double progress = _receivedLength / _totalLength; //刷新UI self.loadLabel.text = [NSString stringWithFormat:@&quot;%.2f%%&quot;,progress*100]; self.progressView.progress = progress; //当缓冲的数据超过500KB时，写入数据 if (_totalData.length &gt; 500 * 1024) &#123; [self addFile:_totalData]; //释放内存 _totalData.data = nil; &#125;&#125;-(void)connectionDidFinishLoading:(NSURLConnection *)connection&#123; //下载完后将文件保存在本地文件夹中 [self addFile:_totalData]; //释放内存 _totalData.data = nil; self.loadLabel.text = @&quot;Succeese&quot;;&#125;@end 断点续传有时候数据文件比较大，我们一次不一定能够全部下载，如果之前下载了一部分，之后我们又要下载的话，在重头开始有点不太合适，这时候我们应该如何做呢。。 现在的下载一般是用http协议，http协议的头部有个字段Range，可以满足我们的需求。 Range用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式： Range:(unit=first byte pos)-[last byte pos] 当我们暂停下载的时候我们可以在代理方法- (void)connection:(NSURLConnection *)connection didReceiveData:(nonnull NSData *)data中记录已下载数据的大小 1234567- (void)connection:(NSURLConnection *)connection didReceiveData:(nonnull NSData *)data&#123; NSLog(@&quot;接受数据中。。。。。%lu&quot;,(unsigned long)data.length); //要把每一次接收到的数据拼接起来 [self.imageData appendData:data]; //记录已下载数据的大小 range = range + data.length; &#125; 然后在再次下载的时候设置HTTP的Range头部,注意此时request需要是NSMutableURLRequest对象 12345 //设置请求数据范围NSString *rangeValue = [NSString stringWithFormat:@&quot;bytes=%llu-&quot;, range];[self.request setValue:rangeValue forHTTPHeaderField:@&quot;Range&quot;];[self.request setCachePolicy:NSURLRequestReloadIgnoringLocalCacheData];self.connection = [NSURLConnection connectionWithRequest:self.request delegate:self]; 下面做个完整的小demo 需求如下： 内存优化 当下载数据量达到500KB时，就写入文件，释放内存。 (1)创建空文件保存下载数据。 (2)当下载数据量达到500K时，把数据附加到文件末尾 断点续传 （1）可以暂停下载，暂停下载时，客户端要记载下载的暂停位置，记录在本地的文件中。 （2）程序退出后，再次进入到此程序中，仍然能从上次下载的暂停位置开始下载。 （3）安全文件操作思想：一个目标目录，一个临时目录，当文件下载未完成时，保存临时文件在临时目录，直到文件下载完成，把此下载完成的临时文件剪切到目标目录。 目标目录：/Documents 临时目录：/Documents/tmp （4）客户端通过设置请求头来通知服务器继续下载的起始位置 Range:bytes=0-499 表示下载头500个字节 Range:bytes=500-999 表示下载第二个500个字节 Range:bytes=-500 表示下载最后一个500个字节 Range:bytes=500- 表示下载500字节以后内容 Range:bytes=0-0,-1 表示下载第一个字节和最后一个字节 ViewController.h 12345678910#import &lt;UIKit/UIKit.h&gt;@interface ViewController : UIViewController &lt;NSURLConnectionDelegate, NSURLConnectionDataDelegate&gt;@property (weak, nonatomic) IBOutlet UILabel *progressLabel;@property (weak, nonatomic) IBOutlet UIProgressView *progressView;- (IBAction)startDownload:(UIButton *)sender;- (IBAction)cancelDownload:(UIButton *)sender;@end ViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#import &quot;ViewController.h&quot;#define kReceivedTotal @&quot;receivedTotal&quot;#define kTotal @&quot;total&quot;@interface ViewController () &#123; BOOL _isDownLoading; //是否正在下载 double _totalLength; //文件大小 double _receivedLength; //累加接收的数据包大小 NSMutableData *_data; //保存下载数据 NSString *_filePath; //临时文件的路径 //全局连接对象，用它来取消下载 NSURLConnection *_connection;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //读取本地化的plist文件，获取已下载数据量和文件总大小 NSUserDefaults *userDefault = [NSUserDefaults standardUserDefaults]; // NSLog(@&quot;userDefault:%@&quot;,userDefault); _receivedLength = [[userDefault objectForKey:kReceivedTotal] doubleValue]; _totalLength = [[userDefault objectForKey:kTotal] doubleValue]; if (_totalLength &gt; 0) &#123; double progress = _receivedLength / _totalLength; _progressLabel.text = [NSString stringWithFormat:@&quot;%.2f%%&quot;, progress * 100]; _progressView.progress = progress; &#125;&#125;- (IBAction)startDownload:(UIButton *)sender &#123; if (!_isDownLoading) &#123; //构造URL NSURL *url = [NSURL URLWithString:@&quot;http://music.baidu.com/data/music/file?link=http://yinyueshiting.baidu.com/data2/music/134371896/12313247982800128.mp3?xcode=ffec71a6b8c89b0a0c0d8753917afb85&amp;song_id=123132479&quot;]; //构造reuqest NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; //通过http下载请求头来设置继续下载的位置 NSString *value = [NSString stringWithFormat:@&quot;bytes=%i-&quot;, (int)_receivedLength]; [request setValue:value forHTTPHeaderField:@&quot;Range&quot;]; NSLog(@&quot;继续下载:%@&quot;, request.allHTTPHeaderFields); //发送异步网络请求 _connection = [NSURLConnection connectionWithRequest:request delegate:self]; //此时正在下载 _isDownLoading = YES; //创建临时目录 _filePath = [NSHomeDirectory() stringByAppendingFormat:@&quot;/Documents/tmp/%@&quot;, @&quot;file.mp3&quot;]; NSLog(@&quot;%@&quot;, _filePath); //判断临时文件是否存在，如果不存在则创建 if (![[NSFileManager defaultManager] fileExistsAtPath:_filePath]) &#123; //先创建临时文件夹 NSString *dirPath = [NSHomeDirectory() stringByAppendingFormat:@&quot;/Documents/tmp&quot;]; [[NSFileManager defaultManager] createDirectoryAtPath:dirPath withIntermediateDirectories:YES attributes:nil error:nil]; //创建空的临时文件 [[NSFileManager defaultManager] createFileAtPath:_filePath contents:nil attributes:nil]; &#125; &#125;&#125;- (IBAction)cancelDownload:(UIButton *)sender &#123; //取消下载 [_connection cancel]; //把数据包存入文件 [self appendFileData:_data]; //释放内存 _data.data = nil; [_data setData:nil]; _isDownLoading = NO; //暂停时，保存已下载数据量和文件总数据量到本地，保证程序退出后下次进入仍能实现断点续传 NSUserDefaults *userDefault = [NSUserDefaults standardUserDefaults]; [userDefault setObject:@(_receivedLength) forKey:kReceivedTotal]; [userDefault setObject:@(_totalLength) forKey:kTotal]; //把数据同步写入到plist文件 [userDefault synchronize];&#125;//封装把数据写入文件，附加到文件的末尾的方法- (void)appendFileData:(NSData *)data &#123; if (data.length == 0 || _filePath.length == 0 ) &#123; return; &#125; //(1)创建文件句柄 NSFileHandle *fileHandle = [NSFileHandle fileHandleForWritingAtPath:_filePath]; //（2）把文件位置指针定位到末尾 [fileHandle seekToEndOfFile]; //（3）写入数据 [fileHandle writeData:data]; //(4)关闭文件 [fileHandle closeFile]; &#125;#pragma mark - NSURLConnection delegate- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &#123; //获取要下载的文件的大小 NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response; NSDictionary *fields = httpResponse.allHeaderFields; //总大小的获取仅计算一次，后面断点续传不需要计算 if (_totalLength == 0) &#123; NSNumber *length = fields[@&quot;Content-Length&quot;]; _totalLength = [length doubleValue]; &#125; //创建NSData来保存下载的数据 _data = [[NSMutableData alloc] init]; &#125;- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123; [_data appendData:data]; //根据当前下载的数据包大小来刷新进度条和Label的显示 //double progress = _data.length / _totalLength; _receivedLength += data.length; double progress = _receivedLength / _totalLength; _progressLabel.text = [NSString stringWithFormat:@&quot;%.2f%%&quot;, progress * 100]; _progressView.progress = progress; //当缓冲数据包超过500K时，则写入文件 if (_data.length &gt; 500 * 1024) &#123; [self appendFileData:_data]; //释放内存 [_data setData:nil]; &#125;&#125;- (void)connectionDidFinishLoading:(NSURLConnection *)connection &#123; //下载完成 _isDownLoading = NO; [self appendFileData:_data]; //释放内存 _data.data = nil; self.progressLabel.text = @&quot;下载完成&quot;; //将下载完成的文件从临时目录剪切到目录目录 NSFileManager *manager = [NSFileManager defaultManager]; //确定目录文件路径 NSString *targetFilePath = [NSHomeDirectory() stringByAppendingFormat:@&quot;/Documents/%@&quot;, @&quot;file.mp3&quot;]; //判断目标文件是否存在，如果存在把旧文件删除，准备剪切操作 if ([manager fileExistsAtPath:targetFilePath]) &#123; [manager removeItemAtPath:targetFilePath error:nil]; &#125; //剪切方法的限制：不能把已存在文件覆盖，如果此文件存在，在剪切之前需要先删除 [manager moveItemAtPath:_filePath toPath:targetFilePath error:nil]; //下载完成时，保存已下载数据量和文件总数据量到本地 NSUserDefaults *userDefault = [NSUserDefaults standardUserDefaults]; [userDefault setObject:@(_receivedLength) forKey:kReceivedTotal]; [userDefault setObject:@(_totalLength) forKey:kTotal]; //把数据同步写入到plist文件 [userDefault synchronize]; //下载完成后把已下载数据量和文件总大小清零。 _receivedLength = 0; _totalLength = 0; &#125;@end 关于NSURLConnection的使用到这里也就结束，这里只是简单的介绍了NSURLConnection的使用，其实NSURLConnection的使用还有许多的使用细节，更深入的研究可以参考相应的文档，这里只是抛砖引玉，还请大家多多指教。。 其实，在 2013的WWDC上，苹果推出了NSURLConnection的继任者：NSURLSession，大有取代NSURLConnection之势，我们可以直接研究NSURLSession。 AFNetworking的基本使用使用AFNetWorking请求网络的完整流程123456789101112131415161718192021222324252627282930313233343536//1.构造URL NSString *urlString = @&quot;https://api.weibo.com/2/statuses/home_timeline.json&quot;; //2.构造请求对象 /* 请求参数的格式： 1.JSON--&gt;AFJSONRequestSerializer 2.XML--&gt;没有给定类，需要自己进行拼接 3.KEY=VALUE--》AFHTTPRequestSerializer 默认 */ NSDictionary *params = @&#123; @&quot;access_token&quot; : @&quot;2.00TSa6WDewTgPDfa63e0f0883oK2XE&quot; &#125;; //请求参数格式化对象，会根据类型拼接好给定的格式 AFHTTPRequestSerializer *requestSer = [AFHTTPRequestSerializer serializer]; //使用请求参数格式化对象来构造一个request NSMutableURLRequest *request = [requestSer requestWithMethod:@&quot;GET&quot; URLString:urlString parameters:params error:nil]; //3.构造线程对象 AFHTTPRequestOperation--&gt;AFURLConnectionOPeration--&gt;NSOperation AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request]; //4.设置从服务器返回到客户端数据的解析方式,默认是JSON解析 operation.responseSerializer = [AFJSONResponseSerializer serializerWithReadingOptions:NSJSONReadingMutableContainers]; //5.网络请求事件的监听--&gt;请求成功和失败会回调的block [operation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) &#123; NSLog(@&quot;网络请求成功%@&quot;, responseObject); &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; NSLog(@&quot;网络请求失败%@&quot;,error); &#125;]; //6.发送网络请求--&gt;把网络请求任务添加到任务队列中执行 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [queue addOperation:operation]; 使用manager对象来请求网络的方法1234567891011121314151617181920//1.获取请求管理对象 AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; //2.设置请求参数格式化对象，确定请求参数以哪种格式进行传递拼接// manager.requestSerializer = [AFHTTPRequestSerializer serializer]; //3.设置返回数据格式化对象，确定返回数据以哪种格式进行解析// manager.responseSerializer = [AFJSONResponseSerializer serializerWithReadingOptions:&lt;#(NSJSONReadingOptions)#&gt;] //4.网络申请 NSString *urlString = @&quot;https://api.weibo.com/2/statuses/update.json&quot;; NSDictionary *params = @&#123; @&quot;status&quot; : @&quot;我在睡觉&quot;, @&quot;access_token&quot; : @&quot;2.00TSa6WDewTgPDfa63e0f0883oK2XE&quot; &#125;; [manager POST:urlString parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; NSLog(@&quot;网络请求成功%@&quot;, responseObject); &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; NSLog(@&quot;网络请求失败%@&quot;,error); &#125;]; 对网络请求进行简单的封装首先创建一个继承NSObject的类FDWebDataRequest FDWebDataRequest.h 1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;@interface FDWebDataRequest : NSObject//使用NSURLConnection组件来做网络申请+ (void)requestData:(NSString *)urlString HTTPMethod:(NSString *)method params:(NSMutableDictionary *)params completionHandle:(void(^)(id result))completionblock errorHandle:(void(^)(NSError *error))errorblock;//封装使用AFNetWorking来申请网络的方法（不上传文件）+ (void)AFRequestData:(NSString *)urlString HTTPMethod:(NSString *)method params:(NSMutableDictionary *)params completionHandle:(void(^)(id result))completionblock errorHandle:(void(^)(NSError *error))errorblock;//封装上传文件的方法:data是和文件上传相关的参数+ (void)AFRequestData:(NSString *)urlString HTTPMethod:(NSString *)method params:(NSMutableDictionary *)params data:(NSMutableDictionary *)datas completionHandle:(void(^)(id result))completionblock errorHandle:(void(^)(NSError *error))errorblock;@end FDWebDataRequest.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#import &quot;FDWebDataRequest.h&quot;#define BaseURL @&quot;https://api.weibo.com&quot;@implementation FDWebDataRequest+ (void)requestData:(NSString *)urlString HTTPMethod:(NSString *)method params:(NSMutableDictionary *)params completionHandle:(void (^)(id))completionblock errorHandle:(void (^)(NSError *))errorblock&#123; //1.拼接URL NSString *requestString = [BaseURL stringByAppendingString:urlString]; NSURL *url = [NSURL URLWithString:requestString]; //2.创建网络请求 NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; request.timeoutInterval = 60; request.HTTPMethod = method; //3.处理请求参数 //key1=value1&amp;key2=value2 NSMutableString *paramString = [NSMutableString string]; NSArray *allKeys = params.allKeys; for (NSInteger i = 0; i &lt; params.count; i++) &#123; NSString *key = allKeys[i]; NSString *value = params[key]; [paramString appendFormat:@&quot;%@=%@&quot;,key,value]; if (i &lt; params.count - 1) &#123; [paramString appendString:@&quot;&amp;&quot;]; &#125; &#125; //4.GET和POST分别处理 if ([method isEqualToString:@&quot;GET&quot;]) &#123; //http://www.baidu.com?key1=value1&amp;key2=value2 //http://www.baidu.com?key0=value0&amp;key1=value1&amp;key2=value2 NSString *seperate = url.query ? @&quot;&amp;&quot; : @&quot;?&quot;; NSString *paramsURLString = [NSString stringWithFormat:@&quot;%@%@%@&quot;,requestString,seperate,paramString]; //根据拼接好的URL进行修改 request.URL = [NSURL URLWithString:paramsURLString]; &#125; else if([method isEqualToString:@&quot;POST&quot;]) &#123; //POST请求则把参数放在请求体里 NSData *bodyData = [paramString dataUsingEncoding:NSUTF8StringEncoding]; request.HTTPBody = bodyData; &#125; //5.发送异步网络请求 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [NSURLConnection sendAsynchronousRequest:request queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123; if (connectionError) &#123; //出现错误时回调block errorblock(connectionError); return; &#125; if (data) &#123; //解析JSON NSDictionary *jsonDic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil]; //把JSON解析后的数据返回给调用者,回调block completionblock(jsonDic); &#125; &#125;];&#125;+ (void)AFRequestData:(NSString *)urlString HTTPMethod:(NSString *)method params:(NSMutableDictionary *)params completionHandle:(void (^)(id))completionblock errorHandle:(void (^)(NSError *))errorblock &#123; //拼接URL urlString = [BaseURL stringByAppendingString:urlString]; //创建管理对象 AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; //GET和POST分别处理 if ([method isEqualToString:@&quot;GET&quot;]) &#123; [manager GET:urlString parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; completionblock(responseObject); &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; errorblock(error); &#125;]; &#125; else if([method isEqualToString:@&quot;POST&quot;]) &#123; [manager POST:urlString parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; completionblock(responseObject); &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; errorblock(error); &#125;]; &#125;&#125;//使用multipart-formdata协议上传文件的方法：//multipart是HTTP协议为web表单新增的上传文件的协议，数据也是放在请求体中，和普通POST的区别是参数不再是key＝value格式，因此特定的数据格式。+ (void)AFRequestData:(NSString *)urlString HTTPMethod:(NSString *)method params:(NSMutableDictionary *)params data:(NSMutableDictionary *)datas completionHandle:(void (^)(id result))completionblock errorHandle:(void (^)(NSError *error))errorblock &#123; //拼接URL urlString = [BaseURL stringByAppendingString:urlString]; //获取管理对象 AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; AFHTTPRequestOperation *operation = [manager POST:urlString parameters:params constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) &#123; //&#123;@&quot;pic&quot; : NSData(图片的二进制数据)&#125;; for (NSString *keyName in datas) &#123; //获取文件的二进制数据 NSData *data = datas[keyName]; //需要上传的数据添加到formData中 [formData appendPartWithFileData:data name:keyName fileName:keyName mimeType:@&quot;image/jpeg&quot;]; &#125; &#125; success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; completionblock(responseObject); &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; errorblock(error); &#125;]; [operation setUploadProgressBlock:^(NSUInteger bytesWritten, long long totalBytesWritten, long long totalBytesExpectedToWrite) &#123; CGFloat progress = totalBytesWritten / (totalBytesExpectedToWrite * 1.0); NSLog(@&quot;已上传：%.2f&quot;, progress); &#125;];&#125;@end 下面我们对上面的音频文件进行改进12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 - (IBAction)startDownload:(UIButton *)sender &#123; if (!isDownloading) &#123; NSString *urlString = @&quot;http://cc.stream.qqmusic.qq.com/50450969.m4a?continfo=F6886073E0D58C26B826A7A6F02C20ED5745045FFCFDBF2D&amp;vkey=6A1FE4B71075955312B4EED3D7413AA3F0FAFBF6B31E13897B51043BD95B754982C276870A6D94720C688006886C90F3CC4683BA537FFBCA&amp;guid=238b3707a54f96885fcf9cabb0e319cda3612706&amp;fromtag=53&amp;uin=21619272&quot;; //NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; //设置返回数据的解析方式为不解析 manager.responseSerializer = [AFHTTPResponseSerializer serializer]; NSString *filePath = [NSHomeDirectory() stringByAppendingFormat:@&quot;/Documents/%@&quot;, @&quot;file.m4a&quot;]; //NSLog(@&quot;%@&quot;, filePath); //判断文件是否存在，如果不存在则创建 if (![[NSFileManager defaultManager] fileExistsAtPath:filePath]) &#123; [[NSFileManager defaultManager] createFileAtPath:filePath contents:nil attributes:nil]; &#125; AFHTTPRequestOperation *operation = [manager GET: urlString parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; NSLog(@&quot;下载成功&quot;); &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; NSLog(@&quot;下载失败&quot;); &#125;]; //设置下载文件不是保存在内存，而是保存到沙盒路径下的文件中。 operation.outputStream = [NSOutputStream outputStreamToFileAtPath:filePath append:YES]; __weak ViewController *weakSelf = self; [operation setDownloadProgressBlock:^(NSUInteger bytesRead, long long totalBytesRead, long long totalBytesExpectedToRead) &#123; CGFloat progress = totalBytesRead / (totalBytesExpectedToRead * 1.0); __strong ViewController *strongSelf = weakSelf; strongSelf.progressView.progress = progress; strongSelf.progressLabel.text = [NSString stringWithFormat:@&quot;%.2f%%&quot; , progress * 100]; &#125;]; isDownloading = YES; &#125; &#125; 扩展我们网络请求的时候array和dictionary无法打印中文 解决方法 通过类目（NSdictionary+Log)的形式复写dictionary的descriptionWithLocale方法，把key和value进行拼接。 123456789101112- (NSString *)descriptionWithLocale:(id)locale &#123; NSMutableString *log = [NSMutableString stringWithFormat:@&quot;&#123;\n&quot;]; for (NSString *key in self) &#123; NSString *value = self[key]; [log appendFormat:@&quot; %@=%@; \n&quot;,key,value]; &#125; [log appendFormat:@&quot;&#125;&quot;]; return log;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS开发-音视频]]></title>
      <url>%2F2017%2F01%2F17%2FiOS%E5%BC%80%E5%8F%91-%E9%9F%B3%E8%A7%86%E9%A2%91%2F</url>
      <content type="text"><![CDATA[访问手机相册123456789101112131415//只能选择单张图片 UIImagePickerController *pickVC = [[UIImagePickerController alloc] init]; //设置相片的来源// UIImagePickerControllerSourceTypePhotoLibrary 来自于相册库// UIImagePickerControllerSourceTypeCamera 来自于摄像头// UIImagePickerControllerSourceTypeSavedPhotosAlbum 来自于默认相册 pickVC.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum; pickVC.delegate = self; //以模态视图的形式弹出 [self presentViewController:pickVC animated:YES completion:NULL]; 当然一定要实现&lt;UINavigationControllerDelegate,UIImagePickerControllerDelegate&gt;这两个代理 1234567891011121314151617181920212223#pragma mark - UIImagePickerController 代理方法//监听图片被选择的事件- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info &#123; NSLog(@&quot;%@&quot;, info); //获取选择的图片 UIImage *image = info[UIImagePickerControllerOriginalImage]; self.imgView.image = image; //判断照片如果来自于摄像头，则要将此图片保存至相册 if (picker.sourceType == UIImagePickerControllerSourceTypeCamera) &#123; //图片的保存 UIImageWriteToSavedPhotosAlbum(image, self, @selector(image:didFinishSavingWithError:contextInfo:), NULL); &#125; [picker dismissViewControllerAnimated:YES completion:NULL];&#125;//图片保存成功调用的协议方法- (void)image: (UIImage *) image didFinishSavingWithError: (NSError *) error contextInfo: (void *) contextInfo &#123; NSLog(@&quot;保存成功&quot;);&#125; 访问照相机123456789101112131415161718BOOL isCamera = [UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceFront | UIImagePickerControllerCameraDeviceRear]; if (!isCamera) &#123; UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;提示&quot; message:@&quot;没有可用摄像头&quot; delegate:nil cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:nil, nil]; [alertView show]; return; &#125; UIImagePickerController *pickVC = [[UIImagePickerController alloc] init]; pickVC.sourceType = UIImagePickerControllerSourceTypeCamera; pickVC.delegate = self; [self presentViewController:pickVC animated:YES completion:NULL]; 音频播放首先导入依赖库AVFoundation和AudioToolbox 1.AVAudioPlayer:只能播放本地音乐。 2.AVPlayer:可以播放本地音乐和网络音乐。 系统声音(依赖AudioToolbox框架）：300KB–&gt;150K 对于小的声音文件（铃声，闹钟等），会直接调用系统的声音服务，不使用iOS音频播放组件处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#import &quot;ViewController.h&quot;#import &lt;AVFoundation/AVFoundation.h&gt;#import &lt;AudioToolbox/AudioToolbox.h&gt;@interface ViewController () &#123; AVAudioPlayer *player; AVPlayer *avPlayer; BOOL isPlay; //控制avPlayer播放和暂停&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;music&quot; ofType:@&quot;mp3&quot;];// //构造网络URL// //NSURL *url = [NSURL URLWithString:filePath];// //构造本地URL// NSURL *url = [NSURL fileURLWithPath:filePath];// // player = [[AVAudioPlayer alloc] initWithContentsOfURL:url error:nil]; // NSURL *url = [NSURL URLWithString:@&quot;http://218.76.27.57:8080/chinaschool_rs02/135275/153903/160861/160867/1370744550357.mp3&quot;];// // avPlayer = [[AVPlayer alloc] initWithURL:url];// // [avPlayer play]; NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;44&quot; ofType:@&quot;caf&quot;]; NSURL *url = [NSURL fileURLWithPath:filePath]; //注册为系统声音,soundID具有有效值 SystemSoundID soundID = 0; AudioServicesCreateSystemSoundID((__bridge CFURLRef)url, &amp;soundID); AudioServicesPlaySystemSound(soundID); //播放振动 AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);&#125;- (IBAction)playLocal:(id)sender &#123; UIButton *button = (UIButton *)sender; //播放状态 if ([player isPlaying]) &#123; [player pause]; [button setTitle:@&quot;播放本地音乐&quot; forState:UIControlStateNormal]; &#125; else &#123; //暂停状态 [player play]; [button setTitle:@&quot;暂停&quot; forState:UIControlStateNormal]; &#125;&#125;- (IBAction)playInternet:(id)sender &#123; if (isPlay) &#123; [avPlayer pause]; &#125; else &#123; [avPlayer play]; &#125; isPlay = !isPlay;&#125;@end 远程控制事件 1.支持远程控制事件，让线控耳机可以控制音乐的暂停和播放 （1）复写canBecomeFirstResponder （2）只有第一响应者才可以接收远程控制事件 （3）设置当前应用程序开始接收远程控制事件 2.让音乐支持后台播放 一般来讲支持后台运行的任务有三种： （1）音乐播放 （2）定位 （3）VOIP：网络电话 进行以下配置才能支持后台播放： （1）在info.plist文件中加入一项:Required background modes–&gt;播放音乐 （2）获取AVAudioSession对象，并设置其类别为AVAudioSessionCategoryPlayback 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#import &quot;ViewController.h&quot;#import &lt;AVFoundation/AVFoundation.h&gt;@interface ViewController () &#123; AVPlayer *_player; BOOL _isPlay;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //让音频会话支持后台播放,且必须在播放音频文件之前设置 [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback error:nil]; NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;music&quot; withExtension:@&quot;mp3&quot;]; _player = [[AVPlayer alloc] initWithURL:url]; [_player play]; &#125;//设置当前响应者具备成为第一响应者的能力- (BOOL)canBecomeFirstResponder &#123; return YES; &#125;- (void)viewDidAppear:(BOOL)animated &#123; [super viewDidAppear:animated]; //设置当前视图控制器为第一响应者，才能接收远程控制事件 [self becomeFirstResponder]; //设置当前应用程序开始接收远程控制事件 [[UIApplication sharedApplication] beginReceivingRemoteControlEvents]; &#125;- (void)viewDidDisappear:(BOOL)animated &#123; [super viewDidDisappear:animated]; //取消第一响应者 [self resignFirstResponder]; //应用程序停止接收远程控制事件 [[UIApplication sharedApplication] endReceivingRemoteControlEvents];&#125;//接收远程控制事件的方法，远程控制事件开始此方法会被触发- (void)remoteControlReceivedWithEvent:(UIEvent *)event &#123; if (event.type == UIEventTypeRemoteControl) &#123; switch (event.subtype) &#123; case UIEventSubtypeRemoteControlTogglePlayPause: if (_isPlay) &#123; [_player pause]; &#125; else &#123; [_player play]; &#125; _isPlay = !_isPlay; break; case UIEventSubtypeRemoteControlNextTrack : NSLog(@&quot;下一首&quot;); break; case UIEventSubtypeRemoteControlPreviousTrack : NSLog(@&quot;上一首&quot;); break; default: break; &#125; &#125;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS开发技巧(二)]]></title>
      <url>%2F2017%2F01%2F17%2FiOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7-%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[获取全局的Delegate对象，这样我们可以调用这个对象里的方法和变量1[(MyAppDelegate*)[[UIApplication sharedApplication] delegate] MyMethodOrMyVariable]; 获得程序的主Bundle123456789NSBundle *bundle = [NSBundle mainBundle];/*Bundle可以理解成一种文件夹，其内容遵循特定的框架。Main Bundle一种主要用途是使用程序中的资源文件，如图片、声音、plst文件等。*/NSURL *plistURL = [bundle URLForResource:@&quot;plistFile&quot; withExtension:@&quot;plist&quot;];//上面的代码获得plistFile.plist文件的路径。 在程序中播放声音12345678910111213141516/*首先在程序添加AudioToolbox：其次，在有播放声音方法的.m方法添加#import：#import*///接下来，播放声音的代码如下：NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;soundFileName&quot; ofType:@&quot;wav&quot;];SystemSoundID soundID;AudioServicesCreateSystemSoundID ((__bridge CFURLRef)[NSURL fileURLWithPath:path], &amp;soundID);AudioServicesPlaySystemSound (soundID); 设置和获取类中属性值123[self setValue: 变量值 forKey: 变量名];[self valueForKey: 变量名]; 让某一方法在未来某段时间之后执行1[self performSelector:@selector(方法名) withObject:nil afterDelay:延迟时间（s）]; 获得设备版本号1float version = [[[UIDevice currentDevice] systemVersion] floatValue]; 捕捉程序关闭或者进入后台事件12345UIApplication *app = [UIApplication sharedApplication];[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationWillResignActive:) name:UIApplicationWillResignActiveNotification object:app];//applicationWillResignActive:这个方法中添加想要的操作 查看设备支持的字体1234567891011for (NSString *family in [UIFont familyNames]) &#123;NSLog(@&quot;%@&quot;, family);for (NSString *font in [UIFont fontNamesForFamilyName:family]) &#123;NSLog(@&quot;\t%@&quot;, font);&#125;&#125; 为UIImageView添加单击事件12345imageView.userInteractionEnabled = YES;UITapGestureRecognizer *singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(yourHandlingCode:)];[imageView addGestureRecognizer:singleTap]; 页面切换效果设置1234567891011121314151617controller.modalTransitionStyle = UIModalTransitionStyleCoverVertical;[self presentModalViewController:controller animated:YES];/*可供使用的效果：UIModalTransitionStyleCoverVerticalUIModalTransitionStyleFlipHorizontalUIModalTransitionStyleCrossDissolveUIModalTransitionStylePartialCurl*///恢复之前的页面：[self dismissModalViewControllerAnimated:YES]; 视频、音频调取iOS视频播放代码（添加MediaPlayer.framework和#import）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061-(void)playMovie:(NSString *)fileName&#123;//视频文件路径NSString *path = [[NSBundle mainBundle] pathForResource:fileName ofType:@&quot;mp4&quot;];//视频URLNSURL *url = [NSURL fileURLWithPath:path];//视频播放对象MPMoviePlayerController *movie = [[MPMoviePlayerController alloc] initWithContentURL:url];movie.controlStyle = MPMovieControlStyleFullscreen;[movie.view setFrame:self.view.bounds];movie.initialPlaybackTime = -1;[self.view addSubview:movie.view];// 注册一个播放结束的通知[[NSNotificationCenter defaultCenter] addObserver:selfselector:@selector(myMovieFinishedCallback:)name:MPMoviePlayerPlaybackDidFinishNotificationobject:movie];[movie play];&#125;#pragma mark -------------------视频播放结束委托---------------------(void)myMovieFinishedCallback:(NSNotification*)notify&#123;//视频播放对象MPMoviePlayerController* theMovie = [notify object];//销毁播放通知[[NSNotificationCenter defaultCenter] removeObserver:selfname:MPMoviePlayerPlaybackDidFinishNotificationobject:theMovie];[theMovie.view removeFromSuperview];// 释放视频对象[theMovie release];&#125; 播放背景音乐，利用类进行播放背景音乐播放 支持mp3格式 循环播放长音乐这种播放音乐的方式导入框架#import 1234//设置属性：必须在h文件中实例化。不知道为什么，直接在M文件中实例化，会播不出来声音。&#123;AVAudioPlayer *myBackMusic;&#125; 123456789101112131415161718192021222324252627282930313233343536//.m-（void)viewDidLoad&#123;NSString *musicFilePath = [[NSBundle mainBundle] pathForResource:@&quot;changan&quot; ofType:@&quot;mp3&quot;]; //创建音乐文件路径NSURL *musicURL = [[NSURL alloc] initFileURLWithPath:musicFilePath];AVAudioPlayer *thePlayer = [[AVAudioPlayer alloc] initWithContentsOfURL:musicURL error:nil];//创建播放器myBackMusic = thePlayer; //赋值给自己定义的类变量[musicURL release];[thePlayer release];[myBackMusic prepareToPlay];[myBackMusic setVolume:1]; //设置音量大小myBackMusic.numberOfLoops = -1;//设置音乐播放次数 -1为一直循环 ，将音频播放器的numberOfLoops属性设为负数使得播放无限循环NSLog(@&quot;%f seconds played so far&quot;, audioPlayer.currentTime); //查看播放的初始时间，也就是从多少秒开始播放audioPlayer.currentTime = 10; // jump to the 10 second mark //设置播放开始的时间[myBackMusic play]; //播放[myBackMusic pause];[myBackMusic stop];&#125; iOS播放一段声音（添加AudioToolbox.framework和#import）1234567NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;soundFileName&quot; ofType:@&quot;wav&quot;];SystemSoundID soundID;AudioServicesCreateSystemSoundID ((__bridge CFURLRef)[NSURL fileURLWithPath:path], &amp;soundID);AudioServicesPlaySystemSound (soundID); 文本框输入时使当前TextField移动到弹出的键盘顶部123456789101112131415161718192021222324252627282930313233343536373839404142//首先先设置TextField的代理为self，并添加&lt;UITextFieldDelegate&gt;//然后通过代理方法来处理视图的上下移动#pragma mark - TextField delegete 处理键盘弹出时视图的上下移动//键盘上移- (void)textFieldDidBeginEditing:(UITextField *)textField&#123; CGRect frame = textField.frame; CGFloat heights = self.view.frame.size.height; // 当前点击textfield的坐标的Y值 + 当前点击textFiled的高度 - （屏幕高度- 键盘高度 - 键盘上tabbar高度） // 在这一部 就是了一个 当前textfile的的最大Y值 和 键盘的最全高度的差值，用来计算整个view的偏移量 int offset = frame.origin.y + frame.size.height - ( heights - 216.0-49.0);//键盘高度216 NSTimeInterval animationDuration = 0.30f; [UIView beginAnimations:@&quot;ResizeForKeyBoard&quot; context:nil]; [UIView setAnimationDuration:animationDuration]; float width = self.view.frame.size.width; float height = self.view.frame.size.height; if(offset &gt; 0) &#123; CGRect rect = CGRectMake(0.0f, -offset,width,height); self.view.frame = rect; &#125; [UIView commitAnimations];&#125;//屏幕恢复原样-(void)textFieldDidEndEditing:(UITextField *)textField&#123; //滑动效果 NSTimeInterval animationDuration = 0.30f; [UIView beginAnimations:@&quot;ResizeForKeyboard&quot; context:nil]; [UIView setAnimationDuration:animationDuration]; //恢复屏幕 self.view.frame = CGRectMake(0.0f, 0.0f, self.view.frame.size.width, self.view.frame.size.height);//64-216 [UIView commitAnimations];&#125;//return返回- (BOOL)textFieldShouldReturn:(UITextField *)textField &#123; [self.contentView endEditing:YES]; return YES;&#125; 判断是否为正确的手机号码12345678910111213141516171819202122232425262728293031323334353637383940#pragma mark - 判断用户输入的手机号码是否正确- (BOOL)isMobileNumber:(NSString *)mobileNum &#123; // 电信号段:133/153/180/181/189/177 // 联通号段:130/131/132/155/156/185/186/145/176 // 移动号段:134/135/136/137/138/139/150/151/152/157/158/159/182/183/184/187/188/147/178 // 虚拟运营商:170 NSString *MOBILE = @&quot;^1(3[0-9]|4[57]|5[0-35-9]|8[0-9]|7[06-8])\\d&#123;8&#125;$&quot;; NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, MOBILE]; return [regextestmobile evaluateWithObject:mobileNum];&#125;/* case let .email(str): predicateStr = &quot;^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)$&quot; currObject = str case let .phoneNum(str): predicateStr = &quot;^((13[0-9])|(15[^4,\\D]) |(17[0,0-9])|(18[0,0-9]))\\d&#123;8&#125;$&quot; currObject = str case let .carNum(str): predicateStr = &quot;^[A-Za-z]&#123;1&#125;[A-Za-z_0-9]&#123;5&#125;$&quot; currObject = str case let .username(str): predicateStr = &quot;^[A-Za-z0-9]&#123;6,20&#125;+$&quot; currObject = str case let .password(str): predicateStr = &quot;^[a-zA-Z0-9]&#123;6,20&#125;+$&quot; currObject = str case let .nickname(str): predicateStr = &quot;^[\\u4e00-\\u9fa5]&#123;4,8&#125;$&quot; currObject = str case let .URL(str): predicateStr = &quot;^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)([\\/\\w \\.-]*)*\\/?$&quot; currObject = str case let .IP(str): predicateStr = &quot;^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$&quot; currObject = str &#125;*/ 判断当前版本号业务逻辑：从服务器获得最新的版本号和是否要强制更新的字段，当用户版本与服务器版本不同时，弹出警告框让用户更新，若用户点击确定则跳转到appStore下载，点击取消则判断服务器返回的强制更新字段是否有值，有则关闭app不让用户使用(当后台接口改变时会出现这种情况) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#pragma mark - 判断版本号- (void)getVersion&#123; //通过发送网络请求从服务器上获取最新版本号[manager GET:kGetVersion parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, NSDictionary *responseObject) &#123; //得到服务器版本 NSString *updataVersion = responseObject[@&quot;currVesion&quot;]; //获取当前设备中应用的版本号 NSDictionary *infoDic = [[NSBundle mainBundle] infoDictionary]; NSString *currentVersion = [infoDic objectForKey:@&quot;CFBundleShortVersionString&quot;]; //判断两个版本是否相同 if ([updataVersion compare:currentVersion options:NSNumericSearch] == NSOrderedDescending) &#123; UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;更新&quot; message:@&quot;您当前版本过低，请更新&quot; preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *update = [UIAlertAction actionWithTitle:@&quot;更新&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; //跳转到响应地址进行更新 //appID根据上传的应用取得 NSString *appID = @&quot;114XXXXXXX&quot;; NSString *appUrl = @&quot;http://itunes.apple.com/lookup?id=&quot;; NSString *urlStr = [NSString stringWithFormat:@&quot;%@%@&quot;, appUrl, appID]; NSURL *url = [NSURL URLWithString:urlStr]; // NSURL *url = [NSURL URLWithString:[NSString stringWithFormat:@&quot;http://%@&quot;,infoDict[@&quot;currVesionDetail&quot;]]]; [[UIApplication sharedApplication] openURL:url]; &#125;]; UIAlertAction *cancel = [UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; //判断是否要强制更新 if (responseObject[@&quot;checkVesion&quot;]) &#123; //说明要强制更新，则杀死程序 UIApplication *app = [UIApplication sharedApplication]; UIWindow *window = app.keyWindow; [UIView animateWithDuration:1.0f animations:^&#123; window.alpha = 0; window.frame = CGRectMake(0, window.bounds.size.width, 0, 0); &#125; completion:^(BOOL finished) &#123; exit(0); &#125;]; //exit(0); &#125; &#125;]; [alert addAction:update]; [alert addAction:cancel]; [self presentViewController:alert animated:YES completion:nil]; &#125; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; &#125;];&#125; 使用SDWebImage当收到内存警告时清除缓存12345678- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application&#123; SDWebImageManager *mrg = [SDWebImageManager sharedManager]; //1,取消下砸操作 [mrg cancelAll]; //2,清除内存缓存 [mrg.imageCache clearMemory];&#125; KVO模式监听数组的变化123456789101112131415161718192021- (void)viewDidLoad&#123; .... [self addObserver:self forKeyPath:@&quot;array&quot; options:NSKeyValueObservingOptionNew context:nil]; ...&#125;//这样监听是无效的- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context&#123; //实现监听方法&#125;//下面方法才有效//注意，方法名中inArrayAtIndex,其中Array要根据属性名和改变-(void)insertObject:(id)object inArrayAtIndex:(NSUInteger)index&#123; //向数组中插入数据 [self.array insertObject:object atIndex:index];&#125;-(void)removeObjectFromArrayAtIndex:(NSUInteger)index&#123; //向数组中删除数据 [self.array removeObjectAtIndex:index];&#125; 当要往数组上增加/删除数据，要通过上面两个方法，而不是直接使用self.array addObject：添加 更多方法如下： 1234-(void)insertArray:(NSArray *)array atIndexes:(NSIndexSet *)indexes&#123;&#125;-(void)removeArrayAtIndexes:(NSIndexSet *)indexes&#123;&#125;-(void)replaceArrayAtIndexes:(NSIndexSet*)indexes withArray:(NSArray *)array&#123;&#125;-(void)replaceObjectInArrayAtIndex:(NSUInteger)index withObject:(id)object&#123;&#125; ScrollView及其子类下拉放大头部图片原理:让ScrollView顶部缩进要放的headerView的高度,在拖动ScrollView时,保持headerView的y始终在原位,而高度加上偏移值 123456789101112131415161718192021222324- (void)viewDidLoad &#123; ... //设置tableView的缩进 tableView.contentInset = UIEdgeInsetsMake(headerViewHeight, 0, 0, 0); //设置headerView imageView.frame = CGRectMake(0, -headerViewHeight, self.view.frame.size.width, headerViewHeight); imageView.contentMode = UIViewContentModeScaleAspectFill; //将imageView插入到tableView的最上层,盖住空白处 [self.tableView insertSubview:imageView atIndex:0]; ...&#125;#pragma mark - delegate//偏移改变headerView大小- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; CGFloat y = scrollView.contentOffset.y ; //如果有导航栏则要加上64 if (y&lt; -headerViewHeight) &#123; CGRect frame = self.headerView.frame; frame.origin.y = y; frame.size.height = -y; self.headerView.frame = frame; &#125;&#125; 判断手机号码格式是否正确，利用正则表达式验证123456789101112131415161718192021222324252627282930313233343536373839404142434445+ (BOOL)isMobileNumber:(NSString *)mobileNum&#123; if (mobileNum.length != 11) &#123; return NO; &#125; /** * 手机号码: * 13[0-9], 14[5,7], 15[0, 1, 2, 3, 5, 6, 7, 8, 9], 17[6, 7, 8], 18[0-9], 170[0-9] * 移动号段: 134,135,136,137,138,139,150,151,152,157,158,159,182,183,184,187,188,147,178,1705 * 联通号段: 130,131,132,155,156,185,186,145,176,1709 * 电信号段: 133,153,180,181,189,177,1700 */ NSString *MOBILE = @&quot;^1(3[0-9]|4[57]|5[0-35-9]|8[0-9]|70)\d&#123;8&#125;$&quot;; /** * 中国移动：China Mobile * 134,135,136,137,138,139,150,151,152,157,158,159,182,183,184,187,188,147,178,1705 */ NSString *CM = @&quot;(^1(3[4-9]|4[7]|5[0-27-9]|7[8]|8[2-478])\d&#123;8&#125;$)|(^1705\d&#123;7&#125;$)&quot;; /** * 中国联通：China Unicom * 130,131,132,155,156,185,186,145,176,1709 */ NSString *CU = @&quot;(^1(3[0-2]|4[5]|5[56]|7[6]|8[56])\d&#123;8&#125;$)|(^1709\d&#123;7&#125;$)&quot;; /** * 中国电信：China Telecom * 133,153,180,181,189,177,1700 */ NSString *CT = @&quot;(^1(33|53|77|8[019])\d&#123;8&#125;$)|(^1700\d&#123;7&#125;$)&quot;; NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, MOBILE]; NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CM]; NSPredicate *regextestcu = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CU]; NSPredicate *regextestct = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CT]; if (([regextestmobile evaluateWithObject:mobileNum] == YES) || ([regextestcm evaluateWithObject:mobileNum] == YES) || ([regextestct evaluateWithObject:mobileNum] == YES) || ([regextestcu evaluateWithObject:mobileNum] == YES)) &#123; return YES; &#125; else &#123; return NO; &#125;&#125; 判断邮箱格式是否正确，利用正则表达式验证123456+ (BOOL)isAvailableEmail:(NSString *)email&#123; NSString *emailRegex = @&quot;[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]&#123;2,4&#125;&quot;; NSPredicate *emailTest = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, emailRegex]; return [emailTest evaluateWithObject:email];&#125; 判断字符串中是否含有空格12345678+ (BOOL)isHaveSpaceInString:(NSString *)string&#123; NSRange _range = [string rangeOfString:@&quot; &quot;]; if (_range.location != NSNotFound) &#123; return YES; &#125;else &#123; return NO; &#125;&#125; 判断字符串中是否含有中文12345678910+ (BOOL)isHaveChineseInString:(NSString *)string&#123; for(NSInteger i = 0; i &lt; [string length]; i++)&#123; int a = [string characterAtIndex:i]; if (a &gt; 0x4e00 &amp;&amp; a &lt; 0x9fff) &#123; return YES; &#125; &#125; return NO;&#125; 判断字符串是否全部为数字123456789101112131415161718+ (BOOL)isAllNum:(NSString *)string&#123; unichar c; for (int i=0; i&lt;string.length; i++) &#123; c=[string characterAtIndex:i]; if (!isdigit(c)) &#123; return no; &#125; &#125;return yes;&#125;//判断是否是纯数字+ (BOOL)isPureInteger:(NSString *)str &#123; NSScanner *scanner = [NSScanner scannerWithString:str]; NSInteger val; return [scanner scanInteger:&amp;val] &amp;&amp; [scanner isAtEnd];&#125; 过滤一些特殊字符 似乎只能去除头尾的特殊字符(不准)123456789+ (NSString *)filterSpecialWithString:(NSString *)string&#123; // 定义一个特殊字符的集合 NSCharacterSet *set = [NSCharacterSet characterSetWithCharactersInString: @&quot;@／：；: ;（）?「」＂、[]&#123;&#125;#%-*+=_|~＜＞$?^?&apos;@#$%^&amp;*()_+&apos;&quot;]; // 过滤字符串的特殊字符 NSString *newString = [string stringByTrimmingCharactersInSet:set]; return newString;&#125; 让iOS应用直接退出12345678+ (void)backOutApp &#123; UIWindow *window = [[UIApplication sharedApplication].delegate window]; [UIView animateWithDuration:1.0f animations:^&#123; window.alpha = 0; &#125; completion:^(BOOL finished) &#123; exit(0); &#125;];&#125; 验证身份证(本人试过,还挺准的)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273+ (BOOL)checkIdentityCardNo:(NSString*)value &#123; value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]; NSInteger length =0; if (!value) &#123; return NO; &#125;else &#123; length = value.length; if (length !=15 &amp;&amp; length !=18) &#123; return NO; &#125; &#125; // 省份代码 NSArray *areasArray =@[@&quot;11&quot;,@&quot;12&quot;, @&quot;13&quot;,@&quot;14&quot;, @&quot;15&quot;,@&quot;21&quot;, @&quot;22&quot;,@&quot;23&quot;, @&quot;31&quot;,@&quot;32&quot;, @&quot;33&quot;,@&quot;34&quot;, @&quot;35&quot;,@&quot;36&quot;, @&quot;37&quot;,@&quot;41&quot;, @&quot;42&quot;,@&quot;43&quot;, @&quot;44&quot;,@&quot;45&quot;, @&quot;46&quot;,@&quot;50&quot;, @&quot;51&quot;,@&quot;52&quot;, @&quot;53&quot;,@&quot;54&quot;, @&quot;61&quot;,@&quot;62&quot;, @&quot;63&quot;,@&quot;64&quot;, @&quot;65&quot;,@&quot;71&quot;, @&quot;81&quot;,@&quot;82&quot;, @&quot;91&quot;]; NSString *valueStart2 = [value substringToIndex:2]; BOOL areaFlag =NO; for (NSString *areaCode in areasArray) &#123; if ([areaCode isEqualToString:valueStart2]) &#123; areaFlag =YES; break; &#125; &#125; if (!areaFlag) &#123; return false; &#125; NSRegularExpression *regularExpression; NSUInteger numberofMatch; NSInteger year =0; switch (length) &#123; case 15: year = [[value substringWithRange:NSMakeRange(6,2)] integerValue] +1900; if (year %4 ==0 || (year 0 ==0 &amp;&amp; year %4 ==0)) &#123; regularExpression = [[NSRegularExpression alloc]initWithPattern:@&quot;^[1-9][0-9]&#123;5&#125;[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]&#123;3&#125;$&quot; options:NSRegularExpressionCaseInsensitive error:nil];//测试出生日期的合法性 &#125;else &#123; regularExpression = [[NSRegularExpression alloc]initWithPattern:@&quot;^[1-9][0-9]&#123;5&#125;[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8]))[0-9]&#123;3&#125;$&quot; options:NSRegularExpressionCaseInsensitive error:nil];//测试出生日期的合法性 &#125; numberofMatch = [regularExpression numberOfMatchesInString:value options:NSMatchingReportProgress range:NSMakeRange(0, value.length)]; if(numberofMatch &gt;0) &#123; return YES; &#125;else &#123; return NO; &#125; case 18: year = [value substringWithRange:NSMakeRange(6,4)].intValue; if (year %4 ==0 || (year 0 ==0 &amp;&amp; year %4 ==0)) &#123; regularExpression = [[NSRegularExpression alloc]initWithPattern:@&quot;^[1-9][0-9]&#123;5&#125;19[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]&#123;3&#125;[0-9Xx]$&quot;options:NSRegularExpressionCaseInsensitive error:nil];//测试出生日期的合法性 &#125;else &#123; regularExpression = [[NSRegularExpression alloc]initWithPattern:@&quot;^[1-9][0-9]&#123;5&#125;19[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8]))[0-9]&#123;3&#125;[0-9Xx]$&quot; options:NSRegularExpressionCaseInsensitive error:nil];//测试出生日期的合法性 &#125; numberofMatch = [regularExpression numberOfMatchesInString:value options:NSMatchingReportProgress range:NSMakeRange(0, value.length)]; if(numberofMatch &gt;0) &#123; int S = ([value substringWithRange:NSMakeRange(0,1)].intValue + [value substringWithRange:NSMakeRange(10,1)].intValue) *7 + ([value substringWithRange:NSMakeRange(1,1)].intValue + [value substringWithRange:NSMakeRange(11,1)].intValue) *9 + ([value substringWithRange:NSMakeRange(2,1)].intValue + [value substringWithRange:NSMakeRange(12,1)].intValue) *10 + ([value substringWithRange:NSMakeRange(3,1)].intValue + [value substringWithRange:NSMakeRange(13,1)].intValue) *5 + ([value substringWithRange:NSMakeRange(4,1)].intValue + [value substringWithRange:NSMakeRange(14,1)].intValue) *8 + ([value substringWithRange:NSMakeRange(5,1)].intValue + [value substringWithRange:NSMakeRange(15,1)].intValue) *4 + ([value substringWithRange:NSMakeRange(6,1)].intValue + [value substringWithRange:NSMakeRange(16,1)].intValue) *2 + [value substringWithRange:NSMakeRange(7,1)].intValue *1 + [value substringWithRange:NSMakeRange(8,1)].intValue *6 + [value substringWithRange:NSMakeRange(9,1)].intValue *3; int Y = S ; NSString *M =@&quot;F&quot;; NSString *JYM =@&quot;10X98765432&quot;; M = [JYM substringWithRange:NSMakeRange(Y,1)];// 判断校验位 if ([M isEqualToString:[value substringWithRange:NSMakeRange(17,1)]]) &#123; return YES;// 检测ID的校验位 &#125;else &#123; return NO; &#125; &#125;else &#123; return NO; &#125; default: return false; &#125;&#125; 设置Label里的字符有不同的颜色123456789101112//可根据自己的需求进行增删改- (void)stringColorSet &#123; NSString*string = @&quot;如何使得Label里的字符有不同的颜色？&quot;; NSRange range = [string rangeOfString: @&quot;Label&quot;]; NSMutableAttributedString*attribute = [[NSMutableAttributedString alloc] initWithString: string]; [attribute addAttributes: @&#123;NSForegroundColorAttributeName: [UIColor redColor]&#125;range: range]; [attribute addAttributes: @&#123;NSForegroundColorAttributeName: [UIColor greenColor]&#125;range: NSMakeRange(0, range.location)]; [attribute addAttributes: @&#123;NSForegroundColorAttributeName: [UIColor cyanColor]&#125;range: NSMakeRange(range.location+ range.length, 5)]; UILabel *label = [[UILabel alloc] initWithFrame: CGRectMake(0.0f, 100.0f, 320.0f, 100.0f)]; [label setText: string]; [label setAttributedText: attribute];&#125; 磁盘总空间大小123456789101112131415+ (CGFloat)diskOfAllSizeMBytes&#123; CGFloat size = 0.0; NSError *error; NSDictionary *dic = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&amp;error]; if (error) &#123;#ifdef DEBUG NSLog(@&quot;error: %@&quot;, error.localizedDescription);#endif &#125;else&#123; NSNumber *number = [dic objectForKey:NSFileSystemSize]; size = [number floatValue]/1024/1024; &#125; return size;&#125; 磁盘可用空间大小123456789101112131415+ (CGFloat)diskOfFreeSizeMBytes&#123; CGFloat size = 0.0; NSError *error; NSDictionary *dic = [[NSFileManager defaultManager] attributesOfFileSystemForPath:NSHomeDirectory() error:&amp;error]; if (error) &#123;#ifdef DEBUG NSLog(@&quot;error: %@&quot;, error.localizedDescription);#endif &#125;else&#123; NSNumber *number = [dic objectForKey:NSFileSystemFreeSize]; size = [number floatValue]/1024/1024; &#125; return size;&#125; 将字符串数组按照元素首字母顺序进行排序分组123456789101112131415161718192021222324252627282930313233343536373839404142+ (NSDictionary *)dictionaryOrderByCharacterWithOriginalArray:(NSArray *)array&#123; if (array.count == 0) &#123; return nil; &#125; for (id obj in array) &#123; if (![obj isKindOfClass:[NSString class]]) &#123; return nil; &#125; &#125; UILocalizedIndexedCollation *indexedCollation = [UILocalizedIndexedCollation currentCollation]; NSMutableArray *objects = [NSMutableArray arrayWithCapacity:indexedCollation.sectionTitles.count]; //创建27个分组数组 for (int i = 0; i &lt; indexedCollation.sectionTitles.count; i++) &#123; NSMutableArray *obj = [NSMutableArray array]; [objects addObject:obj]; &#125; NSMutableArray *keys = [NSMutableArray arrayWithCapacity:objects.count]; //按字母顺序进行分组 NSInteger lastIndex = -1; for (int i = 0; i &lt; array.count; i++) &#123; NSInteger index = [indexedCollation sectionForObject:array[i] collationStringSelector:@selector(uppercaseString)]; [[objects objectAtIndex:index] addObject:array[i]]; lastIndex = index; &#125; //去掉空数组 for (int i = 0; i &lt; objects.count; i++) &#123; NSMutableArray *obj = objects[i]; if (obj.count == 0) &#123; [objects removeObject:obj]; &#125; &#125; //获取索引字母 for (NSMutableArray *obj in objects) &#123; NSString *str = obj[0]; NSString *key = [self firstCharacterWithString:str]; [keys addObject:key]; &#125; NSMutableDictionary *dic = [NSMutableDictionary dictionary]; [dic setObject:objects forKey:keys]; return dic;&#125; 将字符串数组按照元素首字母顺序进行排序分组123456789101112131415161718192021222324252627282930313233343536373839404142+ (NSDictionary *)dictionaryOrderByCharacterWithOriginalArray:(NSArray *)array&#123; if (array.count == 0) &#123; return nil; &#125; for (id obj in array) &#123; if (![obj isKindOfClass:[NSString class]]) &#123; return nil; &#125; &#125; UILocalizedIndexedCollation *indexedCollation = [UILocalizedIndexedCollation currentCollation]; NSMutableArray *objects = [NSMutableArray arrayWithCapacity:indexedCollation.sectionTitles.count]; //创建27个分组数组 for (int i = 0; i &lt; indexedCollation.sectionTitles.count; i++) &#123; NSMutableArray *obj = [NSMutableArray array]; [objects addObject:obj]; &#125; NSMutableArray *keys = [NSMutableArray arrayWithCapacity:objects.count]; //按字母顺序进行分组 NSInteger lastIndex = -1; for (int i = 0; i &lt; array.count; i++) &#123; NSInteger index = [indexedCollation sectionForObject:array[i] collationStringSelector:@selector(uppercaseString)]; [[objects objectAtIndex:index] addObject:array[i]]; lastIndex = index; &#125; //去掉空数组 for (int i = 0; i &lt; objects.count; i++) &#123; NSMutableArray *obj = objects[i]; if (obj.count == 0) &#123; [objects removeObject:obj]; &#125; &#125; //获取索引字母 for (NSMutableArray *obj in objects) &#123; NSString *str = obj[0]; NSString *key = [self firstCharacterWithString:str]; [keys addObject:key]; &#125; NSMutableDictionary *dic = [NSMutableDictionary dictionary]; [dic setObject:objects forKey:keys]; return dic;&#125; 对图片进行滤镜处理1234567891011121314151617// 怀旧 --&gt; CIPhotoEffectInstant 单色 --&gt; CIPhotoEffectMono// 黑白 --&gt; CIPhotoEffectNoir 褪色 --&gt; CIPhotoEffectFade// 色调 --&gt; CIPhotoEffectTonal 冲印 --&gt; CIPhotoEffectProcess// 岁月 --&gt; CIPhotoEffectTransfer 铬黄 --&gt; CIPhotoEffectChrome// CILinearToSRGBToneCurve, CISRGBToneCurveToLinear, CIGaussianBlur, CIBoxBlur, CIDiscBlur, CISepiaTone, CIDepthOfField+ (UIImage *)filterWithOriginalImage:(UIImage *)image filterName:(NSString *)name&#123; CIContext *context = [CIContext contextWithOptions:nil]; CIImage *inputImage = [[CIImage alloc] initWithImage:image]; CIFilter *filter = [CIFilter filterWithName:name]; [filter setValue:inputImage forKey:kCIInputImageKey]; CIImage *result = [filter valueForKey:kCIOutputImageKey]; CGImageRef cgImage = [context createCGImage:result fromRect:[result extent]]; UIImage *resultImage = [UIImage imageWithCGImage:cgImage]; CGImageRelease(cgImage); return resultImage;&#125; 对图片进行模糊处理123456789101112131415161718192021222324252627// CIGaussianBlur ---&gt; 高斯模糊// CIBoxBlur ---&gt; 均值模糊(Available in iOS 9.0 and later)// CIDiscBlur ---&gt; 环形卷积模糊(Available in iOS 9.0 and later)// CIMedianFilter ---&gt; 中值模糊, 用于消除图像噪点, 无需设置radius(Available in iOS 9.0 and later)// CIMotionBlur ---&gt; 运动模糊, 用于模拟相机移动拍摄时的扫尾效果(Available in iOS 9.0 and later)+ (UIImage *)blurWithOriginalImage:(UIImage *)image blurName:(NSString *)name radius:(NSInteger)radius&#123; CIContext *context = [CIContext contextWithOptions:nil]; CIImage *inputImage = [[CIImage alloc] initWithImage:image]; CIFilter *filter; if (name.length != 0) &#123; filter = [CIFilter filterWithName:name]; [filter setValue:inputImage forKey:kCIInputImageKey]; if (![name isEqualToString:@&quot;CIMedianFilter&quot;]) &#123; [filter setValue:@(radius) forKey:@&quot;inputRadius&quot;]; &#125; CIImage *result = [filter valueForKey:kCIOutputImageKey]; CGImageRef cgImage = [context createCGImage:result fromRect:[result extent]]; UIImage *resultImage = [UIImage imageWithCGImage:cgImage]; CGImageRelease(cgImage); return resultImage; &#125;else&#123; return nil; &#125;&#125; 跳转到系统的相关界面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* * 需要添加一个字段 * 蓝色的项目工程文件 -&gt; Info -&gt; URL Types -&gt; 添加一个 -&gt; 设置URL Sch**** 为 prefs的url NSURL *url = [NSURL URLWithString:@&quot;prefs:root=WIFI&quot;]; if ([[UIApplication sharedApplication] canOpenURL:url])&#123;[[UIApplication sharedApplication] openURL:url];&#125; 跳转到其他的界面的字段(不全,详细看链接)About — prefs:root=General&amp;path=About Accessibility — prefs:root=General&amp;path=ACCESSIBILITY AirplaneModeOn— prefs:root=AIRPLANE_MODE Auto-Lock — prefs:root=General&amp;path=AUTOLOCK Brightness — prefs:root=Brightness Bluetooth — prefs:root=General&amp;path=BluetoothDate&amp; Time — prefs:root=General&amp;path=DATE_AND_TIME FaceTime — prefs:root=FACETIMEGeneral— prefs:root=GeneralKeyboard — prefs:root=General&amp;path=Keyboard iCloud — prefs:root=CASTLE iCloud Storage &amp; Backup — prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP International — prefs:root=General&amp;path=INTERNATIONAL Location Services — prefs:root=LOCATION_SERVICES Music — prefs:root=MUSIC Music Equalizer — prefs:root=MUSIC&amp;path=EQ Music VolumeLimit— prefs:root=MUSIC&amp;path=VolumeLimit Network — prefs:root=General&amp;path=Network Nike + iPod — prefs:root=NIKE_PLUS_IPOD Notes — prefs:root=NOTES Notification — prefs:root=NOTIFICATIONS_ID Phone — prefs:root=Phone Photos — prefs:root=Photos Profile — prefs:root=General&amp;path=ManagedConfigurationList Reset — prefs:root=General&amp;path=Reset Safari — prefs:root=Safari Siri — prefs:root=General&amp;path=Assistant Sounds — prefs:root=Sounds SoftwareUpdate— prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK Store — prefs:root=STORE Twitter — prefs:root=TWITTER Usage — prefs:root=General&amp;path=USAGE VPN — prefs:root=General&amp;path=Network/VPN Wallpaper — prefs:root=Wallpaper Wi-Fi — prefs:root=WIFISetting—prefs:root=INTERNET_TETHERING */ 创建一张实时模糊效果 View (毛玻璃效果)12345678//Avilable in iOS 8.0 and later+ (UIVisualEffectView *)effectViewWithFrame:(CGRect)frame&#123; UIBlurEffect *effect = [UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]; UIVisualEffectView *effectView = [[UIVisualEffectView alloc] initWithEffect:effect]; effectView.frame = frame; return effectView;&#125; 设置Label的行间距1234567891011121314+ (void)setLineSpaceWithString:(UILabel *)label&#123; NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:label.text]; NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init]; [paragraphStyle setLineSpacing:3]; //调整行间距 [attributedString addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [label.text length])]; label.attributedText = attributedString;&#125; 让Plain风格的TableView的区头可以”不悬停”(可以直接百度搜到):12345678910111213- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123; if(scrollView == self.myTab) &#123; CGFloat sectionHeaderHeight = 40; if (scrollView.contentOffset.y=0) &#123; scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0); &#125; else if (scrollView.contentOffset.y&gt;=sectionHeaderHeight) &#123; scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0); &#125; &#125;&#125; 清理缓存功能的实现移动应用在处理网络资源时，一般都会做离线缓存处理，其中以图片缓存最为典型，其中很流行的离线缓存框架为SDWebImage。 但是，离线缓存会占用手机存储空间，所以缓存清理功能基本成为资讯、购物、阅读类app的标配功能。 下面介绍的离线缓存功能的实现，主要分为缓存文件大小的获取、删除缓存文件的实现。 获取缓存文件的大小由于缓存文件存在沙箱中，我们可以通过NSFileManager API来实现对缓存文件大小的计算。 计算单个文件大小12345678+(float)fileSizeAtPath:(NSString *)path&#123; NSFileManager *fileManager=[NSFileManager defaultManager]; if([fileManager fileExistsAtPath:path])&#123; long long size=[fileManager attributesOfItemAtPath:path error:nil].fileSize; return size/1024.0/1024.0; &#125; return 0;&#125; 计算目录大小123456789101112131415+(float)folderSizeAtPath:(NSString *)path&#123; NSFileManager *fileManager=[NSFileManager defaultManager]; float folderSize; if ([fileManager fileExistsAtPath:path]) &#123; NSArray *childerFiles=[fileManager subpathsAtPath:path]; for (NSString *fileName in childerFiles) &#123; NSString *absolutePath=[path stringByAppendingPathComponent:fileName]; folderSize +=[FileService fileSizeAtPath:absolutePath]; &#125; //SDWebImage框架自身计算缓存的实现 folderSize+=[[SDImageCache sharedImageCache] getSize]/1024.0/1024.0; return folderSize; &#125; return 0;&#125; 清理缓存文件同样也是利用NSFileManager API进行文件操作，SDWebImage框架自己实现了清理缓存操作，我们可以直接调用。 123456789101112+(void)clearCache:(NSString *)path&#123; NSFileManager *fileManager=[NSFileManager defaultManager]; if ([fileManager fileExistsAtPath:path]) &#123; NSArray *childerFiles=[fileManager subpathsAtPath:path]; for (NSString *fileName in childerFiles) &#123; //如有需要，加入条件，过滤掉不想删除的文件 NSString *absolutePath=[path stringByAppendingPathComponent:fileName]; [fileManager removeItemAtPath:absolutePath error:nil]; &#125; &#125; [[SDImageCache sharedImageCache] cleanDisk];&#125; 比较number型的数据是否相同1234567NSNumber *num1 = [[NSNumber alloc]initWithInt:10];NSNumber *num2 = [NSNumber numberWithInt:10];//isEqualToNumber: 比较的是对象中存储的数据BOOL isEqual = [num1 isEqualToNumber:num2];NSLog(@&quot;isEqual=%d&quot;, isEqual); NSNumber *num = [NSNumber numberWithInt:score]; 比较字符串的大小12345678910NSString *str1=@&quot;xuzhonglin&quot;;NSString *str2=@&quot;sunkeqiang&quot;;NSComparisonResult result = [str1 caseInsensitiveCompare:str2];if (result == NSOrderedAscending)&#123; NSLog(@&quot;升序，str1&lt;str2&quot;);&#125;else if(result == NSOrderedSame)&#123; NSLog(@&quot;大小相同&quot;);&#125;else if (result == NSOrderedDescending)&#123; NSLog(@&quot;降序，str1&gt;str2&quot;);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS开发技巧(一)]]></title>
      <url>%2F2017%2F01%2F16%2FiOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[常用代码块遍历可变数组的同时删除数组元素1234567NSMutableArray *copyArray = [NSMutableArray arrayWithArray:array]; NSString *str1 = @“zhangsan”; for (AddressPerson *perName in copyArray) &#123; if ([[perName name] isEqualToString:str1]) &#123; [array removeObject:perName]; &#125; &#125; 获取系统当前语言1234567891011121314151617181920NSString *currentLanguage = [[NSLocale preferredLanguages] objectAtIndex:0];NSLog(@&quot;currentlanguage = %@&quot;,currentLanguage);if ([currentLanguage containsString:@&quot;zh-Hans&quot;]) &#123; NSLog(@&quot;zh-Hans简体中文&quot;);&#125;else if ([currentLanguage containsString:@&quot;zh-Hant&quot;]) &#123; NSLog(@&quot;zh-Hant繁体中文&quot;);&#125;// 当前所在地信息NSString *identifier = [[NSLocalecurrentLocale] localeIdentifier];NSString *displayName = [[NSLocale currentLocale] displayNameForKey:NSLocaleIdentifiervalue:identifier];NSLog(@&apos;%@&apos;, displayName);// 当前所在地的使用语言NSLocale *currentLocale = [NSLocale currentLocale];NSLog(@&apos;Language Code is %@&apos;, [currentLocale objectForKey:NSLocaleLanguageCode]);// 系统语言NSArray *arLanguages = [[NSUserDefaultsstandardUserDefaults] objectForKey:@&apos;AppleLanguages&apos;];NSString *strLang = [arLanguages objectAtIndex:0];NSLog(@&apos;LANG:%@&apos;,strLang); UITableView的Group样式下顶部空白处理12UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, 0.1)];self.tableView.tableHeaderView = view; UITableView的plain样式下，取消区头停滞效果123456789101112- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; CGFloat sectionHeaderHeight = sectionHead.height; if (scrollView.contentOffset.y&lt;=sectionHeaderHeight&amp;&amp;scrollView;.contentOffset.y&gt;=0) &#123; scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0); &#125; else if(scrollView.contentOffset.y&gt;=sectionHeaderHeight) &#123; scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0); &#125;&#125; 获取某个view所在的控制器123456789101112131415- (UIViewController *)viewController&#123; UIViewController *viewController = nil; UIResponder *next = self.nextResponder; while (next) &#123; if ([next isKindOfClass:[UIViewController class]]) &#123; viewController = (UIViewController *)next; break; &#125; next = next.nextResponder; &#125; return viewController;&#125; 两种方法删除NSUserDefaults所有记录12345678910111213141516//方法一NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];//方法二- (void)resetDefaults&#123; NSUserDefaults * defs = [NSUserDefaults standardUserDefaults]; NSDictionary * dict = [defs dictionaryRepresentation]; for (id key in dict) &#123; [defs removeObjectForKey:key]; &#125; [defs synchronize];&#125; 打印系统所有已注册的字体名称123456789101112void enumerateFonts()&#123; for(NSString *familyName in [UIFont familyNames]) &#123; NSLog(@&quot;%@&quot;,familyName); NSArray *fontNames = [UIFont fontNamesForFamilyName:familyName]; for(NSString *fontName in fontNames) &#123; NSLog(@&quot;\t|- %@&quot;,fontName); &#125; &#125;&#125; 获取图片某一点的颜色12345678910111213141516171819202122232425262728293031- (UIColor*) getPixelColorAtLocation:(CGPoint)point inImage:(UIImage *)image&#123; UIColor* color = nil; CGImageRef inImage = image.CGImage; CGContextRef cgctx = [self createARGBBitmapContextFromImage:inImage]; if (cgctx == NULL) &#123; return nil; /* error */ &#125; size_t w = CGImageGetWidth(inImage); size_t h = CGImageGetHeight(inImage); CGRect rect = &#123;&#123;0,0&#125;,&#123;w,h&#125;&#125;; CGContextDrawImage(cgctx, rect, inImage); unsigned char* data = CGBitmapContextGetData (cgctx); if (data != NULL) &#123; int offset = 4*((w*round(point.y))+round(point.x)); int alpha = data[offset]; int red = data[offset+1]; int green = data[offset+2]; int blue = data[offset+3]; color = [UIColor colorWithRed:(red/255.0f) green:(green/255.0f) blue: (blue/255.0f) alpha:(alpha/255.0f)]; &#125; CGContextRelease(cgctx); if (data) &#123; free(data); &#125; return color;&#125; 字符串反转123456789101112131415161718192021//第一种：- (NSString *)reverseWordsInString:(NSString *)str&#123; NSMutableString *newString = [[NSMutableString alloc] initWithCapacity:str.length]; for (NSInteger i = str.length - 1; i &gt;= 0 ; i --) &#123; unichar ch = [str characterAtIndex:i]; [newString appendFormat:@&quot;%c&quot;, ch]; &#125; return newString;&#125;//第二种：- (NSString*)reverseWordsInString:(NSString*)str&#123; NSMutableString *reverString = [NSMutableString stringWithCapacity:str.length]; [str enumerateSubstringsInRange:NSMakeRange(0, str.length) options:NSStringEnumerationReverse | NSStringEnumerationByComposedCharacterSequences usingBlock:^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop) &#123; [reverString appendString:substring]; &#125;]; return reverString;&#125; 禁止锁屏1234//第一种[UIApplication sharedApplication].idleTimerDisabled = YES;//第二种[[UIApplication sharedApplication] setIdleTimerDisabled:YES]; 模态推出透明界面12345678910111213UIViewController *vc = [[UIViewController alloc] init];UINavigationController *na = [[UINavigationController alloc] initWithRootViewController:vc];if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8.0)&#123; na.modalPresentationStyle = UIModalPresentationOverCurrentContext;&#125;else&#123; self.modalPresentationStyle=UIModalPresentationCurrentContext;&#125;[self presentViewController:na animated:YES completion:nil]; iOS跳转到App Store下载应用评分1[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;itms-apps://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?type=Purple+Software&amp;id=APPID&quot;]]; 手动更改iOS状态栏的颜色123456789- (void)setStatusBarBackgroundColor:(UIColor *)color&#123; UIView *statusBar = [[[UIApplication sharedApplication] valueForKey:@&quot;statusBarWindow&quot;] valueForKey:@&quot;statusBar&quot;]; if ([statusBar respondsToSelector:@selector(setBackgroundColor:)]) &#123; statusBar.backgroundColor = color; &#125;&#125; 判断当前ViewController是push还是present的方式显示123456789101112131415NSArray *viewcontrollers=self.navigationController.viewControllers;if (viewcontrollers.count &gt; 1)&#123; if ([viewcontrollers objectAtIndex:viewcontrollers.count - 1] == self) &#123; //push方式 [self.navigationController popViewControllerAnimated:YES]; &#125;&#125;else&#123; //present方式 [self dismissViewControllerAnimated:YES completion:nil];&#125; 获取实际使用的LaunchImage图片1234567891011121314151617- (NSString *)getLaunchImageName&#123; CGSize viewSize = self.window.bounds.size; // 竖屏 NSString *viewOrientation = @&quot;Portrait&quot;; NSString *launchImageName = nil; NSArray* imagesDict = [[[NSBundle mainBundle] infoDictionary] valueForKey:@&quot;UILaunchImages&quot;]; for (NSDictionary* dict in imagesDict) &#123; CGSize imageSize = CGSizeFromString(dict[@&quot;UILaunchImageSize&quot;]); if (CGSizeEqualToSize(imageSize, viewSize) &amp;&amp; [viewOrientation isEqualToString:dict[@&quot;UILaunchImageOrientation&quot;]]) &#123; launchImageName = dict[@&quot;UILaunchImageName&quot;]; &#125; &#125; return launchImageName;&#125; iOS在当前屏幕获取第一响应12UIWindow * keyWindow = [[UIApplication sharedApplication] keyWindow];UIView * firstResponder = [keyWindow performSelector:@selector(firstResponder)]; 判断对象是否遵循了某协议1234if ([self.selectedController conformsToProtocol:@protocol(RefreshPtotocol)])&#123; [self.selectedController performSelector:@selector(onTriggerRefresh)];&#125; 判断view是不是指定视图的子视图1BOOL isView = [textView isDescendantOfView:self.view]; NSArray 快速求总和 最大值 最小值 和 平均值123456NSArray *array = [NSArray arrayWithObjects:@&quot;2.0&quot;, @&quot;2.3&quot;, @&quot;3.0&quot;, @&quot;4.0&quot;, @&quot;10&quot;, nil];CGFloat sum = [[array valueForKeyPath:@&quot;@sum.floatValue&quot;] floatValue];CGFloat avg = [[array valueForKeyPath:@&quot;@avg.floatValue&quot;] floatValue];CGFloat max =[[array valueForKeyPath:@&quot;@max.floatValue&quot;] floatValue];CGFloat min =[[array valueForKeyPath:@&quot;@min.floatValue&quot;] floatValue];NSLog(@&quot;%f\n%f\n%f\n%f&quot;,sum,avg,max,min); 修改UITextField中Placeholder的文字颜色1[textField setValue:[UIColor redColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;]; 获取一个类的所有子类123456789101112131415161718192021+ (NSArray *) allSubclasses&#123; Class myClass = [self class]; NSMutableArray *mySubclasses = [NSMutableArray array]; unsigned int numOfClasses; Class *classes = objc_copyClassList(&amp;numOfClasses;); for (unsigned int ci = 0; ci &lt; numOfClasses; ci++) &#123; Class superClass = classes[ci]; do&#123; superClass = class_getSuperclass(superClass); &#125; while (superClass &amp;&amp; superClass != myClass); if (superClass) &#123; [mySubclasses addObject: classes[ci]]; &#125; &#125; free(classes); return mySubclasses;&#125; 阿拉伯数字转中文格式12345678910111213141516171819202122232425262728293031323334353637383940414243+(NSString *)translation:(NSString *)arebic&#123; NSString *str = arebic; NSArray *arabic_numerals = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;0&quot;]; NSArray *chinese_numerals = @[@&quot;一&quot;,@&quot;二&quot;,@&quot;三&quot;,@&quot;四&quot;,@&quot;五&quot;,@&quot;六&quot;,@&quot;七&quot;,@&quot;八&quot;,@&quot;九&quot;,@&quot;零&quot;]; NSArray *digits = @[@&quot;个&quot;,@&quot;十&quot;,@&quot;百&quot;,@&quot;千&quot;,@&quot;万&quot;,@&quot;十&quot;,@&quot;百&quot;,@&quot;千&quot;,@&quot;亿&quot;,@&quot;十&quot;,@&quot;百&quot;,@&quot;千&quot;,@&quot;兆&quot;]; NSDictionary *dictionary = [NSDictionary dictionaryWithObjects:chinese_numerals forKeys:arabic_numerals]; NSMutableArray *sums = [NSMutableArray array]; for (int i = 0; i &lt; str.length; i ++) &#123; NSString *substr = [str substringWithRange:NSMakeRange(i, 1)]; NSString *a = [dictionary objectForKey:substr]; NSString *b = digits[str.length -i-1]; NSString *sum = [a stringByAppendingString:b]; if ([a isEqualToString:chinese_numerals[9]]) &#123; if([b isEqualToString:digits[4]] || [b isEqualToString:digits[8]]) &#123; sum = b; if ([[sums lastObject] isEqualToString:chinese_numerals[9]]) &#123; [sums removeLastObject]; &#125; &#125;else &#123; sum = chinese_numerals[9]; &#125; if ([[sums lastObject] isEqualToString:sum]) &#123; continue; &#125; &#125; [sums addObject:sum]; &#125; NSString *sumStr = [sums componentsJoinedByString:@&quot;&quot;]; NSString *chinese = [sumStr substringToIndex:sumStr.length-1]; NSLog(@&quot;%@&quot;,str); NSLog(@&quot;%@&quot;,chinese); return chinese;&#125; 取消UICollectionView的隐式动画12345678910111213141516171819//方法一[UIView performWithoutAnimation:^&#123; [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];&#125;];//方法二[UIView animateWithDuration:0 animations:^&#123; [collectionView performBatchUpdates:^&#123; [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]]; &#125; completion:nil];&#125;];//方法三[UIView setAnimationsEnabled:NO];[self.trackPanel performBatchUpdates:^&#123; [collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];&#125; completion:^(BOOL finished) &#123; [UIView setAnimationsEnabled:YES];&#125;]; 判断邮箱格式是否正确的代码1234567891011-(BOOL)isValidateEmail:(NSString *)email &#123; NSString *emailRegex = @&quot;[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,4&#125;&quot;; NSPredicate *emailTest = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES%@&quot;,emailRegex]; return [emailTest evaluateWithObject:email]; &#125; iOS中UITextField的字数限制1234567891011121314151617181920212223242526272829303132//在viewDidLoad中注册&lt;UITextFieldTextDidChangeNotification&gt;通知[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(textFiledEditChanged:) name:@&quot;UITextFieldTextDidChangeNotification&quot; object:myTextField];//实现监听方法#pragma mark - Notification Method-(void)textFieldEditChanged:(NSNotification *)obj&#123; UITextField *textField = (UITextField *)obj.object; NSString *toBeString = textField.text; //获取高亮部分 UITextRange *selectedRange = [textField markedTextRange]; UITextPosition *position = [textField positionFromPosition:selectedRange.start offset:0]; // 没有高亮选择的字，则对已输入的文字进行字数统计和限制 if (!position) &#123; if (toBeString.length &gt; MAX_STARWORDS_LENGTH) &#123; NSRange rangeIndex = [toBeString rangeOfComposedCharacterSequenceAtIndex:MAX_STARWORDS_LENGTH]; if (rangeIndex.length == 1) &#123; textField.text = [toBeString substringToIndex:MAX_STARWORDS_LENGTH]; &#125; else &#123; NSRange rangeRange = [toBeString rangeOfComposedCharacterSequencesForRange:NSMakeRange(0, MAX_STARWORDS_LENGTH)]; textField.text = [toBeString substringWithRange:rangeRange]; &#125; &#125; &#125;&#125; GCD定时器1234567891011dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);dispatch_source_set_timer(timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行dispatch_source_set_event_handler(timer, ^&#123; //倒计时结束，关闭 dispatch_source_cancel(timer); dispatch_async(dispatch_get_main_queue(), ^&#123; &#125;);&#125;);dispatch_resume(timer); 图片上绘制文字123456789101112131415161718192021222324252627282930- (UIImage *)imageWithTitle:(NSString *)title fontSize:(CGFloat)fontSize&#123; //画布大小 CGSize size=CGSizeMake(self.size.width,self.size.height); //创建一个基于位图的上下文 UIGraphicsBeginImageContextWithOptions(size,NO,0.0);//opaque:NO scale:0.0 [self drawAtPoint:CGPointMake(0.0,0.0)]; //文字居中显示在画布上 NSMutableParagraphStyle* paragraphStyle = [[NSParagraphStyle defaultParagraphStyle] mutableCopy]; paragraphStyle.lineBreakMode = NSLineBreakByCharWrapping; paragraphStyle.alignment=NSTextAlignmentCenter;//文字居中 //计算文字所占的size,文字居中显示在画布上 CGSize sizeText=[title boundingRectWithSize:self.size options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:fontSize]&#125;context:nil].size; CGFloat width = self.size.width; CGFloat height = self.size.height; CGRect rect = CGRectMake((width-sizeText.width)/2, (height-sizeText.height)/2, sizeText.width, sizeText.height); //绘制文字 [title drawInRect:rect withAttributes:@&#123; NSFontAttributeName:[UIFont systemFontOfSize:fontSize],NSForegroundColorAttributeName:[ UIColor whiteColor],NSParagraphStyleAttributeName:paragraphStyle&#125;]; //返回绘制的新图形 UIImage *newImage= UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage;&#125; 查找一个视图的所有子视图12345678910111213- (NSMutableArray *)allSubViewsForView:(UIView *)view&#123; NSMutableArray *array = [NSMutableArray arrayWithCapacity:0]; for (UIView *subView in view.subviews) &#123; [array addObject:subView]; if (subView.subviews.count &gt; 0) &#123; [array addObjectsFromArray:[self allSubViewsForView:subView]]; &#125; &#125; return array;&#125; 计算文件大小12345678910111213141516171819202122232425262728293031323334353637//文件大小- (long long)fileSizeAtPath:(NSString *)path&#123; NSFileManager *fileManager = [NSFileManager defaultManager]; if ([fileManager fileExistsAtPath:path]) &#123; long long size = [fileManager attributesOfItemAtPath:path error:nil].fileSize; return size; &#125; return 0;&#125;//文件夹大小- (long long)folderSizeAtPath:(NSString *)path&#123; NSFileManager *fileManager = [NSFileManager defaultManager]; long long folderSize = 0; if ([fileManager fileExistsAtPath:path]) &#123; NSArray *childerFiles = [fileManager subpathsAtPath:path]; for (NSString *fileName in childerFiles) &#123; NSString *fileAbsolutePath = [path stringByAppendingPathComponent:fileName]; if ([fileManager fileExistsAtPath:fileAbsolutePath]) &#123; long long size = [fileManager attributesOfItemAtPath:fileAbsolutePath error:nil].fileSize; folderSize += size; &#125; &#125; &#125; return folderSize;&#125; UIView的设置部分圆角12345678CGRect rect = view.bounds;CGSize radio = CGSizeMake(30, 30);//圆角尺寸UIRectCorner corner = UIRectCornerTopLeft|UIRectCornerTopRight;//这只圆角位置UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corner cornerRadii:radio];CAShapeLayer *masklayer = [[CAShapeLayer alloc]init];//创建shapelayermasklayer.frame = view.bounds;masklayer.path = path.CGPath;//设置路径view.layer.mask = masklayer; 计算字符串字符长度，一个汉字算两个字符1234567891011121314151617181920212223242526272829303132//方法一：- (int)convertToInt:(NSString*)strtemp&#123; int strlength = 0; char* p = (char*)[strtemp cStringUsingEncoding:NSUnicodeStringEncoding]; for (int i=0 ; i&lt;[strtemp lengthOfBytesUsingEncoding:NSUnicodeStringEncoding] ;i++) &#123; if (*p) &#123; p++; strlength++; &#125; else &#123; p++; &#125; &#125; return strlength;&#125;//方法二：-(NSUInteger) unicodeLengthOfString: (NSString *) text&#123; NSUInteger asciiLength = 0; for (NSUInteger i = 0; i &lt; text.length; i++) &#123; unichar uc = [text characterAtIndex: i]; asciiLength += isascii(uc) ? 1 : 2; &#125; return asciiLength;&#125; 防止滚动视图手势覆盖侧滑手势1[scrollView.panGestureRecognizer requireGestureRecognizerToFail:self.navigationController.interactivePopGestureRecognizer]; 去掉导航栏返回的标题1[[UIBarButtonItem appearance]setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60)forBarMetrics:UIBarMetricsDefault]; 字符串中是否含有中文123456789101112+ (BOOL)checkIsChinese:(NSString *)string&#123; for (int i=0; i&lt;string.length; i++) &#123; unichar ch = [string characterAtIndex:i]; if (0x4E00 &lt;= ch &amp;&amp; ch &lt;= 0x9FA5) &#123; return YES; &#125; &#125; return NO;&#125; dispatch_group的使用1234567891011121314151617dispatch_group_t dispatchGroup = dispatch_group_create(); dispatch_group_enter(dispatchGroup); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;第一个请求完成&quot;); dispatch_group_leave(dispatchGroup); &#125;); dispatch_group_enter(dispatchGroup); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;第二个请求完成&quot;); dispatch_group_leave(dispatchGroup); &#125;); dispatch_group_notify(dispatchGroup, dispatch_get_main_queue(), ^()&#123; NSLog(@&quot;请求完成&quot;); &#125;); UITextField每四位加一个空格，实现代理123456789101112131415161718192021- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string&#123; // 四位加一个空格 if ([string isEqualToString:@&quot;&quot;]) &#123; // 删除字符 if ((textField.text.length - 2) % 5 == 0) &#123; textField.text = [textField.text substringToIndex:textField.text.length - 1]; &#125; return YES; &#125; else &#123; if (textField.text.length % 5 == 0) &#123; textField.text = [NSString stringWithFormat:@&quot;%@ &quot;, textField.text]; &#125; &#125; return YES;&#125; 获取手机安装的应用123456789Class c =NSClassFromString(@&quot;LSApplicationWorkspace&quot;);id s = [(id)c performSelector:NSSelectorFromString(@&quot;defaultWorkspace&quot;)];NSArray *array = [s performSelector:NSSelectorFromString(@&quot;allInstalledApplications&quot;)];for (id item in array)&#123; NSLog(@&quot;%@&quot;,[item performSelector:NSSelectorFromString(@&quot;applicationIdentifier&quot;)]); NSLog(@&quot;%@&quot;,[item performSelector:NSSelectorFromString(@&quot;bundleVersion&quot;)]); NSLog(@&quot;%@&quot;,[item performSelector:NSSelectorFromString(@&quot;shortVersionString&quot;)]);&#125; 应用内打开系统设置界面12345678910111213141516171819202122232425262728293031323334353637383940414243444546//iOS8之后[[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];//如果App没有添加权限，显示的是设定界面。如果App有添加权限（例如通知），显示的是App的设定界面。//iOS8之前//先添加一个url type，在代码中调用如下代码,即可跳转到设置页面的对应项[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;prefs:root=WIFI&quot;]];/*可选值如下：About — prefs:root=General&amp;path=AboutAccessibility — prefs:root=General&amp;path=ACCESSIBILITYAirplane Mode On — prefs:root=AIRPLANE_MODEAuto-Lock — prefs:root=General&amp;path=AUTOLOCKBrightness — prefs:root=BrightnessBluetooth — prefs:root=General&amp;path=BluetoothDate &amp; Time — prefs:root=General&amp;path=DATE_AND_TIMEFaceTime — prefs:root=FACETIMEGeneral — prefs:root=GeneralKeyboard — prefs:root=General&amp;path=KeyboardiCloud — prefs:root=CASTLEiCloud Storage &amp; Backup — prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUPInternational — prefs:root=General&amp;path=INTERNATIONALLocation Services — prefs:root=LOCATION_SERVICESMusic — prefs:root=MUSICMusic Equalizer — prefs:root=MUSIC&amp;path=EQMusic Volume Limit — prefs:root=MUSIC&amp;path=VolumeLimitNetwork — prefs:root=General&amp;path=NetworkNike + iPod — prefs:root=NIKE_PLUS_IPODNotes — prefs:root=NOTESNotification — prefs:root=NOTIFICATI*****_IDPhone — prefs:root=PhonePhotos — prefs:root=PhotosProfile — prefs:root=General&amp;path=ManagedConfigurationListReset — prefs:root=General&amp;path=ResetSafari — prefs:root=SafariSiri — prefs:root=General&amp;path=AssistantSounds — prefs:root=SoundsSoftware Update — prefs:root=General&amp;path=SOFTWARE_UPDATE_LINKStore — prefs:root=STORETwitter — prefs:root=TWITTERUsage — prefs:root=General&amp;path=USAGEVPN — prefs:root=General&amp;path=Network/VPNWallpaper — prefs:root=WallpaperWi-Fi — prefs:root=WIFI */ 动画暂停再开始12345678910111213141516-(void)pauseLayer:(CALayer *)layer&#123; CFTimeInterval pausedTime = [layer convertTime:CACurrentMediaTime() fromLayer:nil]; layer.speed = 0.0; layer.timeOffset = pausedTime;&#125;-(void)resumeLayer:(CALayer *)layer&#123; CFTimeInterval pausedTime = [layer timeOffset]; layer.speed = 1.0; layer.timeOffset = 0.0; layer.beginTime = 0.0; CFTimeInterval timeSincePause = [layer convertTime:CACurrentMediaTime() fromLayer:nil] - pausedTime; layer.beginTime = timeSincePause;&#125; iOS版中数字的格式化1234567891011121314151617181920212223//通过NSNumberFormatter，同样可以设置NSNumber输出的格式。例如如下代码：NSNumberFormatter *formatter = [[NSNumberFormatter alloc] init];formatter.numberStyle = NSNumberFormatterDecimalStyle;NSString *string = [formatter stringFromNumber:[NSNumber numberWithInt:123456789]];NSLog(@&quot;Formatted number string:%@&quot;,string);//输出结果为：[1223:403] Formatted number string:123,456,789//其中NSNumberFormatter类有个属性numberStyle，它是一个枚举型，设置不同的值可以输出不同的数字格式。该枚举包括：typedef NS_ENUM(NSUInteger, NSNumberFormatterStyle) &#123; NSNumberFormatterNoStyle = kCFNumberFormatterNoStyle, NSNumberFormatterDecimalStyle = kCFNumberFormatterDecimalStyle, NSNumberFormatterCurrencyStyle = kCFNumberFormatterCurrencyStyle, NSNumberFormatterPercentStyle = kCFNumberFormatterPercentStyle, NSNumberFormatterScientificStyle = kCFNumberFormatterScientificStyle, NSNumberFormatterSpellOutStyle = kCFNumberFormatterSpellOutStyle&#125;;//各个枚举对应输出数字格式的效果如下：其中第三项和最后一项的输出会根据系统设置的语言区域的不同而不同。[1243:403] Formatted number string:123456789[1243:403] Formatted number string:123,456,789[1243:403] Formatted number string:￥123,456,789.00[1243:403] Formatted number string:-539,222,988%[1243:403] Formatted number string:1.23456789E8[1243:403] Formatted number string:一亿二千三百四十五万六千七百八十九 如何获取的WebView所有的图片地址1234567891011121314151617181920212223242526272829303132333435363738//UIWebView- (void)webViewDidFinishLoad:(UIWebView *)webView&#123; //这里是js，主要目的实现对url的获取 static NSString * const jsGetImages = @&quot;function getImages()&#123;\ var objs = document.getElementsByTagName(\&quot;img\&quot;);\ var imgScr = &apos;&apos;;\ for(var i=0;i&lt;objs.length;i++)&#123;\ imgScr = imgScr + objs[i].src + &apos;+&apos;;\ &#125;;\ return imgScr;\ &#125;;&quot;; [webView stringByEvaluatingJavaScriptFromString:jsGetImages];//注入js方法 NSString *urlResult = [webView stringByEvaluatingJavaScriptFromString:@&quot;getImages()&quot;]; NSArray *urlArray = [NSMutableArray arrayWithArray:[urlResult componentsSeparatedByString:@&quot;+&quot;]]; //urlResurlt 就是获取到得所有图片的url的拼接；mUrlArray就是所有Url的数组&#125;//WKWebView- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation&#123; static NSString * const jsGetImages = @&quot;function getImages()&#123;\ var objs = document.getElementsByTagName(\&quot;img\&quot;);\ var imgScr = &apos;&apos;;\ for(var i=0;i&lt;objs.length;i++)&#123;\ imgScr = imgScr + objs[i].src + &apos;+&apos;;\ &#125;;\ return imgScr;\ &#125;;&quot;; [webView evaluateJavaScript:jsGetImages completionHandler:nil]; [webView evaluateJavaScript:@&quot;getImages()&quot; completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123; NSLog(@&quot;%@&quot;,result); &#125;];&#125; 获取到的WebView的高度1CGFloat height = [[self.webView stringByEvaluatingJavaScriptFromString:@&quot;document.body.offsetHeight&quot;] floatValue]; 导航栏变为纯透明12345678//第一种方法//导航栏纯透明[self.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];//去掉导航栏底部的黑线self.navigationBar.shadowImage = [UIImage new];//第二种方法[[self.navigationBar subviews] objectAtIndex:0].alpha = 0; tabBar变为纯透明12[self.tabBar setBackgroundImage:[UIImage new]];self.tabBar.shadowImage = [UIImage new]; navigationBar根据滑动距离的渐变色实现12345678910111213141516171819202122232425262728293031//第一种- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; CGFloat offsetToShow = 200.0;//滑动多少就完全显示 CGFloat alpha = 1 - (offsetToShow - scrollView.contentOffset.y) / offsetToShow; [[self.navigationController.navigationBar subviews] objectAtIndex:0].alpha = alpha;&#125;//第二种- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; CGFloat offsetToShow = 200.0; CGFloat alpha = 1 - (offsetToShow - scrollView.contentOffset.y) / offsetToShow; [self.navigationController.navigationBar setShadowImage:[UIImage new]]; [self.navigationController.navigationBar setBackgroundImage:[self imageWithColor:[[UIColor orangeColor]colorWithAlphaComponent:alpha]] forBarMetrics:UIBarMetricsDefault];&#125;//生成一张纯色的图片- (UIImage *)imageWithColor:(UIColor *)color&#123; CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f); UIGraphicsBeginImageContext(rect.size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, [color CGColor]); CGContextFillRect(context, rect); UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return theImage;&#125; 常用宏尺寸宏12345678910111213#define StatusBar_HEIGHT 20#define NavigationBar_HEIGHT 44#define NavigationBarIcon 20#define TabBar_HEIGHT 49#define TabBarIcon 30#define SCREEN_WIDTH ([UIScreen mainScreen].bounds.size.width)#define SCREEN_HEIGHT ([UIScreen mainScreen].bounds.size.height) 打印宏123456//替换NSLog来使用，debug模式下可以打印很多方法名，行信息。#ifdef DEBUG# define DLog(fmt, ...) NSLog((@&quot;%s [Line %d] &quot; fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__);#else # define DLog(...) #endif 123456//直接替换NSLog#if DEBUG #define NSLog(FORMAT, ...) fprintf(stderr,&quot;\nfunction:%s line:%d content:%s\n&quot;, __FUNCTION__, __LINE__, [[NSString stringWithFormat:FORMAT, ##__VA_ARGS__] UTF8String]); #else #define NSLog(FORMAT, ...) nil #endif 123456//DEBUG 模式下打印日志,当前行以及弹出一个警告#ifdef DEBUG# define ULog(fmt, ...) &#123; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:[NSString stringWithFormat:@&quot;%s\n [Line %d] &quot;, __PRETTY_FUNCTION__, __LINE__] message:[NSString stringWithFormat:fmt, ##__VA_ARGS__] delegate:nil cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil]; [alert show]; &#125;#else# define ULog(...)#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#define ITTDEBUG#define ITTLOGLEVEL_INFO 10#define ITTLOGLEVEL_WARNING 3#define ITTLOGLEVEL_ERROR 1#ifndef ITTMAXLOGLEVEL#ifdef DEBUG#define ITTMAXLOGLEVEL ITTLOGLEVEL_INFO#else#define ITTMAXLOGLEVEL ITTLOGLEVEL_ERROR#endif#endif// The general purpose logger. This ignores logging levels.#ifdef ITTDEBUG#define ITTDPRINT(xx, ...) NSLog(@&quot;%s(%d): &quot; xx, __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)#else#define ITTDPRINT(xx, ...) ((void)0)#endif// Prints the current method&apos;s name.#define ITTDPRINTMETHODNAME() ITTDPRINT(@&quot;%s&quot;, __PRETTY_FUNCTION__)// Log-level based logging macros.#if ITTLOGLEVEL_ERROR &lt;= ITTMAXLOGLEVEL#define ITTDERROR(xx, ...) ITTDPRINT(xx, ##__VA_ARGS__)#else#define ITTDERROR(xx, ...) ((void)0)#endif#if ITTLOGLEVEL_WARNING &lt;= ITTMAXLOGLEVEL#define ITTDWARNING(xx, ...) ITTDPRINT(xx, ##__VA_ARGS__)#else#define ITTDWARNING(xx, ...) ((void)0)#endif#if ITTLOGLEVEL_INFO &lt;= ITTMAXLOGLEVEL#define ITTDINFO(xx, ...) ITTDPRINT(xx, ##__VA_ARGS__)#else#define ITTDINFO(xx, ...) ((void)0)#endif#ifdef ITTDEBUG#define ITTDCONDITIONLOG(condition, xx, ...) &#123; if ((condition)) &#123; \ITTDPRINT(xx, ##__VA_ARGS__); \&#125; \&#125; ((void)0)#else#define ITTDCONDITIONLOG(condition, xx, ...) ((void)0)#endif#define ITTAssert(condition, ...) \do &#123; \if (!(condition)) &#123; \[[NSAssertionHandler currentHandler] \handleFailureInFunction:[NSString stringWithUTF8String:__PRETTY_FUNCTION__] \file:[NSString stringWithUTF8String:__FILE__] \lineNumber:__LINE__ \description:__VA_ARGS__]; \&#125; \&#125; while(0) 系统宏123//获取版本#define IOS_VERSION [[[UIDevice currentDevice] systemVersion] floatValue]#define CurrentSystemVersion [[UIDevice currentDevice] systemVersion] 12//获取当前语言#define CurrentLanguage ([[NSLocale preferredLanguages] objectAtIndex:0]) 12345678//判断是真机还是模拟器 #if TARGET_OS_IPHONE //iPhone Device #endif #if TARGET_IPHONE_SIMULATOR //iPhone Simulator #endif 123456//检查系统版本#define SYSTEM_VERSION_EQUAL_TO(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedSame)#define SYSTEM_VERSION_GREATER_THAN(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedDescending)#define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending)#define SYSTEM_VERSION_LESS_THAN(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedAscending)#define SYSTEM_VERSION_LESS_THAN_OR_EQUAL_TO(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedDescending) 内存宏1234567891011121314//使用ARC和不使用ARC#if __has_feature(objc_arc)//compiling with ARC#else// compiling without ARC#endif#pragma mark - common functions#define RELEASE_SAFELY(__POINTER) &#123; [__POINTER release]; __POINTER = nil; &#125;//释放一个对象#define SAFE_DELETE(P) if(P) &#123; [P release], P = nil; &#125;#define SAFE_RELEASE(x) [x release];x=nil 图片宏1234567891011//读取本地图片#define LOADIMAGE(file,ext) [UIImage imageWithContentsOfFile:[[NSBundle mainBundle]pathForResource:file ofType:ext]]//定义UIImage对象#define IMAGE(A) [UIImage imageWithContentsOfFile:[[NSBundle mainBundle] pathForResource:A ofType:nil]]//定义UIImage对象//#define ImageNamed(_pointer) [UIImage imageNamed:[UIUtil imageName:_pointer]]//前两种宏性能高，省内存//第三个没有必要使用，因为我们可以使用Xcode的插件 颜色宏12345678910111213141516171819// rgb颜色转换（16进制-&gt;10进制）#define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) &gt;&gt; 16))/255.0 green:((float)((rgbValue &amp; 0xFF00) &gt;&gt; 8))/255.0 blue:((float)(rgbValue &amp; 0xFF))/255.0 alpha:1.0]//带有RGBA的颜色设置#define COLOR(R, G, B, A) [UIColor colorWithRed:R/255.0 green:G/255.0 blue:B/255.0 alpha:A]// 获取RGB颜色#define RGBA(r,g,b,a) [UIColor colorWithRed:r/255.0f green:g/255.0f blue:b/255.0f alpha:a]#define RGB(r,g,b) RGBA(r,g,b,1.0f)//背景色#define BACKGROUND_COLOR [UIColor colorWithRed:242.0/255.0 green:236.0/255.0 blue:231.0/255.0 alpha:1.0]//清除背景色#define CLEARCOLOR [UIColor clearColor]#pragma mark - color functions#define RGBCOLOR(r,g,b) [UIColor colorWithRed:(r)/255.0f green:(g)/255.0f blue:(b)/255.0f alpha:1]#define RGBACOLOR(r,g,b,a) [UIColor colorWithRed:(r)/255.0f green:(g)/255.0f blue:(b)/255.0f alpha:(a)] 其他宏123456789101112131415161718192021222324//方正黑体简体字体定义#define FONT(F) [UIFont fontWithName:@&quot;FZHTJW--GB1-0&quot; size:F]//定义一个API#define APIURL @&quot;http://xxxxx/&quot;//登陆API#define APILogin [APIURL stringByAppendingString:@&quot;Login&quot;]//设置View的tag属性#define VIEWWITHTAG(_OBJECT, _TAG) [_OBJECT viewWithTag : _TAG]//程序的本地化,引用国际化的文件#define MyLocal(x, ...) NSLocalizedString(x, nil)//G－C－D#define BACK(block) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), block)#define MAIN(block) dispatch_async(dispatch_get_main_queue(),block)//NSUserDefaults 实例化#define USER_DEFAULT [NSUserDefaults standardUserDefaults]//由角度获取弧度 有弧度获取角度#define degreesToRadian(x) (M_PI * (x) / 180.0)#define radianToDegrees(radian) (radian*180.0)/(M_PI) 单例宏1234567891011121314151617181920212223242526272829303132333435#define SYNTHESIZE_SINGLETON_FOR_CLASS(classname) \\static classname *shared##classname = nil; \\+ (classname *)shared##classname \&#123; \@synchronized(self) \&#123; \if (shared##classname == nil) \&#123; \shared##classname = [[self alloc] init]; \&#125; \&#125; \\return shared##classname; \&#125; \\+ (id)allocWithZone:(NSZone *)zone \&#123; \@synchronized(self) \&#123; \if (shared##classname == nil) \&#123; \shared##classname = [super allocWithZone:zone]; \return shared##classname; \&#125; \&#125; \\return nil; \&#125; \\- (id)copyWithZone:(NSZone *)zone \&#123; \return self; \&#125; 小技巧CGRect1CGRectFromString(&lt;#NSString *string#&gt;)//有字符串恢复出矩形CGRectInset(&lt;#CGRect rect#&gt;, &lt;#CGFloat dx#&gt;, &lt;#CGFloat dy#&gt;)//创建较小或者较大的矩形CGRectIntersectsRect(&lt;#CGRect rect1#&gt;, &lt;#CGRect rect2#&gt;)//判断两巨星是否交叉，是否重叠CGRectZero//高度和宽度为零的，位于（0，0）的矩形常量 隐藏状态栏1[UIApplicationsharedApplication]setStatusBarHidden:&lt;#(BOOL)#&gt; withAnimation:&lt;#(UIStatusBarAnimation)#&gt;//隐藏状态栏 自动适应父视图大小12self.view.autoresizesSubviews=YES;self.view.autoresizingMask=UIViewAutoresizingFlexibleWidth|UIViewAutoresizingFlexibleHeight; UITableView的一些方法12//缩进级别设置为行号，row越大，缩进越多 -(NSInteger)tableView:(UITableView*)tableView indentationLevelForRowAtIndexPath:(NSIndexPath*)indexPath&#123;NSIntegerrow=indexPath.row;returnrow;&#125; 把plist文件中的数据赋给数组12NSString*path=[[NSBundlemainBundle]pathForResource:@&quot;States&quot;ofType:@&quot;plist&quot;];NSArray*array=[NSArrayarrayWithContentsOfFile:path]; 获取触摸的点1-(CGPoint)locationInView:(UIView*)view;-(CGPoint)previousLocationInView:(UIView*)view; 获取触摸的属性123@property(nonatomic,readonly)NSTimeIntervaltimestamp;@property(nonatomic,readonly)UITouchPhasephase;@property(nonatomic,readonly)NSUIntegertapCount; 从plist中获取数据赋给字典12NSString*plistPath=[[NSBundlemainBundle]pathForResource:@&quot;book&quot;ofType:@&quot;plist&quot;];NSDictionary*dictionary=[NSDictionarydictionaryWithContentsOfFile:plistPath]; NSUserDefaults注意事项1//设置完了以后如果存储的东西比较重要的话，一定要同步一下[[NSUserDefaultsstandardUserDefaults]synchronize]; 获取Documents目录1NSString*documentsDirectory=NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES)[0]; 获取tmp目录1NSString*tmpPath=NSTemporaryDirectory(); 利用Safari打开一个链接1NSURL*url=[NSURLURLWithString:@&quot;http://baidu.com&quot;];[[UIApplicationsharedApplication]openURL:url]; 利用UIWebView显示pdf文件，网页等等1234567891011121314151617UIWebView *webView = [[UIWebView alloc]initWithFrame:self.view.bounds];webView.delegate = self;webView.scalesPageToFit = YES;webView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;[webView setAllowsInlineMediaPlayback:YES];[self.view addSubview:webView];NSString *pdfPath = [[NSBundle mainBundle] pathForResource:@&quot;book&quot; ofType:@&quot;pdf&quot;];NSURL *url = [NSURL fileURLWithPath:pdfPath];NSURLRequest *request = [NSURLRequest requestWithURL:url cachePolicy:(NSURLRequestUseProtocolCachePolicy) timeoutInterval:5]; UIWebView和html的简单交互123456789101112myWebView=[[UIWebViewalloc]initWithFrame:self.view.bounds];[myWebView loadRequest:[NSURLRequestrequestWithURL:[NSURLURLWithString:@&quot;http://www.baidu.com&quot;]]];NSError*error;NSString*errorString=[NSStringstringWithFormat:@&quot;AnError Occurred;%@&quot;,error];[myWebView loadHTMLString:errorString baseURL:nil]; //页面跳转了以后，停止载入-(void)viewWillDisappear:(BOOL)animated&#123; if(myWebView.isLoading)&#123; [myWebView stopLoading];&#125; myWebView.delegate=nil; [UIApplicationsharedApplication].networkActivityIndicatorVisible=NO;&#125; 汉字转码12NSString*oriString=@&quot;\u67aa\u738b&quot;;NSString*escapedString=[oriString stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; 处理键盘通知123456789101112131415161718192021222324252627先注册通知，然后实现具体当键盘弹出来要做什么，键盘收起来要做什么 -(void)registerForKeyboardNotifications&#123; keyboardShown=NO;//标记当前键盘是没有显示的 [[NSNotificationCenterdefaultCenter]addObserver:selfselector:@selector(keyboardWasShown:)name:UIKeyboardWillShowNotificationobject:nil];[[NSNotificationCenterdefaultCenter]addObserver:selfselector:@selector(keyboardWasHidden:)name:UIKeyboardDidHideNotificationobject:nil];&#125;//键盘显示要做什么-(void)keyboardWasShown:(NSNotification*)notification&#123; if(keyboardShown)&#123; return; &#125; NSDictionary*info=[notification userInfo]; NSValue*aValue=[info objectForKey:UIKeyboardFrameBeginUserInfoKey]; CGSizekeyboardSize=[aValueCGRectValue].size; CGRectviewFrame=scrollView.frame; viewFrame.size.height=keyboardSize.height; CGRecttextFieldRect=activeField.frame; [scrollView scrollRectToVisible:textFieldRect animated:YES]; keyboardShown=YES;&#125;-(void)keyboardWasHidden:(NSNotification*)notification&#123; NSDictionary*info=[notification userInfo]; NSValue*aValue=[info objectForKey:UIKeyboardFrameEndUserInfoKey]; CGSizekeyboardSize=[aValueCGRectValue].size; CGRectviewFrame=scrollView.frame; viewFrame.size.height+=keyboardSize.height; scrollView.frame=viewFrame; keyboardShown=NO;&#125; 点击键盘的next按钮，在不同的textField之间换行1234567891011-(BOOL)textFieldShouldReturn:(UITextField*)textField&#123; if([textField returnKeyType]!=UIReturnKeyDone) &#123; NSIntegernextTag=[textField tag]+1; UIView*nextTextField=[self.tableView viewWithTag:nextTag]; [nextTextField becomeFirstResponder]; &#125;else&#123; [textField resignFirstResponder]; &#125; return YES;&#125; 设置日期格式123456dateFormatter=[[NSDateFormatteralloc]init];dateFormatter.locale=[NSLocalecurrentLocale];dateFormatter.calendar=[NSCalendarautoupdatingCurrentCalendar];dateFormatter.timeZone=[NSTimeZonedefaultTimeZone];dateFormatter.dateStyle=NSDateFormatterShortStyle; NSLog(@&quot;%@&quot;,[dateFormatter stringFromDate:[NSDatedate]]); 加载大量图片的时候，可以使用12NSString*imagePath=[[NSBundlemainBundle]pathForResource:@&quot;icon&quot;ofType:@&quot;png&quot;];UIImage*myImage=[UIImageimageWithContentsOfFile:imagePath]; 有时候在iPhone游戏中，既要播放背景音乐，同时又要播放比如枪的开火音效12345NSString*musicFilePath=[[NSBundlemainBundle]pathForResource:@&quot;xx&quot;ofType:@&quot;wav&quot;];NSURL*musicURL=[NSURL fileURLWithPath:musicFilePath];AVAudioPlayer*musicPlayer=[[AVAudioPlayeralloc]initWithContentsOfURL:musicURL error:nil];[musicPlayer prepareToPlay];musicPlayer.volume=1;musicPlayer.numberOfLoops=-1;//-1表示一直循环 从通讯录中读取电话号码，去掉数字之间的-123456789101112131415NSString*originalString=@&quot;(123)123123abc&quot;;NSMutableString*strippedString=[NSMutableStringstringWithCapacity:originalString.length];NSScanner*scanner=[NSScannerscannerWithString:originalString];NSCharacterSet*numbers=[NSCharacterSetcharacterSetWithCharactersInString:@&quot;0123456789&quot;];while([scanner isAtEnd]==NO)&#123; NSString*buffer; if([scanner scanCharactersFromSet:numbers intoString:&amp;buffer]) &#123; [strippedString appendString:buffer]; &#125;else&#123; scanner.scanLocation=[scanner scanLocation]+1; &#125;&#125;NSLog(@&quot;%@&quot;,strippedString); 正则判断：字符串只包含字母和数字123456NSString*myString=@&quot;Letter1234&quot;;NSString*regex=@&quot;[a-z][A-Z][0-9]&quot;;NSPredicate*predicate=[NSPredicatepredicateWithFormat:@&quot;SELF MATCHES %@&quot;,regex];if([predicate evaluateWithObject:myString])&#123; //implement&#125; 设置UITableView的滚动条颜色123self.tableView.indicatorStyle=UIScrollViewIndicatorStyleWhite;/*网络编程 开发web等网络应用程序的时候，需要确认网络环境，连接情况等信息。如果没有处理它们，是不会通过apple的审查的。 系统自带的网络检查是原生的，AFNetworking也为我们添加了相关检测机制，所以这个直接在介绍AFNetworking的时候详解吧。*/ 使用NSURLConnection下载数据12345678910111213141516171819202122//1.创建对象 NSMutableURLRequest*request=[NSMutableURLRequestrequestWithURL:[NSURLURLWithString:@&quot;http://www.baidu.com&quot;]];[NSURLConnectionconnectionWithRequest:requestdelegate:self];//2.NSURLConnectiondelegate委托方法-(void)connection:(NSURLConnection*)connection didReceiveResponse:(NSURLResponse*)response&#123;&#125;-(void)connection:(NSURLConnection*)connection didReceiveData:(NSData*)data&#123;&#125;-(void)connection:(NSURLConnection*)connection didFailWithError:(NSError*)error&#123;&#125;-(void)connectionDidFinishLoading:(NSURLConnection*)connection&#123;&#125;//3.实现委托方法-(void)connection:(NSURLConnection*)connection didReceiveResponse:(NSURLResponse*)response&#123; self.receiveData.length=0;//先清空数据&#125;-(void)connection:(NSURLConnection*)connection didReceiveData:(NSData*)data&#123; [self.receiveData appendData:data];&#125;-(void)connection:(NSURLConnection*)connection didFailWithError:(NSError*)error&#123; //错误处理&#125;-(void)connectionDidFinishLoading:(NSURLConnection*)connection&#123; [UIApplicationsharedApplication].networkActivityIndicatorVisible=NO; NSString*returnString=[[NSStringalloc]initWithData:self.receiveData encoding:NSUTF8StringEncoding]; firstTimeDownloaded=YES;&#125; 读取一般性文件123456789101112-(void)readFromTXT&#123;NSString*tmp;NSArray*lines;//将文件转化为一行一行的 lines=[[NSStringstringWithContentsOfFile:@&quot;testFileReadLines.txt&quot;]componentsSeparatedByString:@&quot;\n&quot;]; NSEnumerator*nse=[lines objectEnumerator];//读取&lt;&gt;里的内容 while(tmp==[nse nextObject])&#123; NSString*stringBetweenBrackets=nil; NSScanner*scanner=[NSScannerscannerWithString:tmp]; [scanner scanUpToString:@&quot;&lt;&quot;intoString:nil]; [scanner scanString:@&quot;&lt;&quot;intoString:nil]; [scanner scanUpToString:@&quot;&gt;&quot;intoString:&amp;stringBetweenBrackets]; NSLog(@&quot;%@&quot;,[stringBetweenBrackets description]); &#125;&#125; 调用电话，短信，邮件1[[UIApplicationsharedApplication]openURL:[NSURLURLWithString:@&quot;mailto:apple@mac.com?Subject=hello&quot;]];sms://调用短信tel://调用电话itms://打开MobileStore.app 获取版本信息12UIDevice*myDevice=[UIDevicecurrentDevice];NSString*systemVersion=myDevice.systemVersion; UIWebView的使用12345678910111213webView.delegate = self;(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123;NSURL *url = request.URL;NSString *urlStirng = url.absoluteString;NSLog(@&quot;%@&quot;,urlStirng);return YES;&#125; NSNotificationCenter带参数发送123456MPMoviePlayerController*theMovie=[[MPMoviePlayerControlleralloc]initWithContentURL:[NSURL fileURLWithPath:moviePath]];[[NSNotificationCenterdefaultCenter]addObserver:selfselector:@selector(myMovieFinishedCallback:)name:MPMoviePlayerPlaybackDidFinishNotificationobject:theMovie];[theMovie play];-(void)myMovieFinishedCallback:(NSNotification*)aNotification&#123; MPMoviePlayerController*theMovie=[aNotificationobject];[[NSNotificationCenterdefaultCenter]removeObserver:selfname:MPMoviePlayerPlaybackDidFinishNotificationobject:theMovie];&#125; 延迟一段时间执行某个函数1[selfperformSelector:@selector(dismissModal)withObject:selfafterDelay:1.0]; 用NSDateFormatter调整时间格式代码123NSDateFormatter*dateFormatter=[[NSDateFormatteralloc]init];dateFormatter.dateFormat=@&quot;yyyy-MM-dd HH:mm:ss&quot;;NSString*currentDateStr=[dateFormatter stringFromDate:[NSDatedate]]; iPhone 更改键盘右下角按键的 type1234567SearchBar*mySearchBar=[[UISearchBaralloc]init];mySearchBar.frame=CGRectMake(0,0,self.view.bounds.size.width,44);mySearchBar.placeholder=@&quot;placeholderString&quot;;mySearchBar.delegate=self;[self.view addSubview:mySearchBar];UITextField*searchField=[[mySearchBar subviews]lastObject];searchField.returnKeyType=UIReturnKeyDone;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多线程和GCD]]></title>
      <url>%2F2017%2F01%2F15%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CGCD%2F</url>
      <content type="text"><![CDATA[使用NSThread来操作多线程不说废话直接上代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* 使用NSThread来操作多线程 */#import &quot;ViewController.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // //主线程中的循环打印任务1// for (int j = 0; j &lt; 50; j++) &#123;// // NSLog(@&quot;主线程1:%i&quot;, j);// // &#125; // //1.创建一个线程对象,可以获取线程对象，指定线程名优先级等，灵活处理。// NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(thread:) object:@&quot;multiThread1&quot;];// thread.name = @&quot;multiThread1&quot;;// // //开启多线程，程序开始有了一条新的执行路径// [thread start]; //2.创建一个线程对象，并且直接启动此线程 //[NSThread detachNewThreadSelector:@selector(thread:) toTarget:self withObject:@&quot;multiThread1&quot;]; //3.创建一个线程对象，并且直接启动此线程 [self performSelectorInBackground:@selector(thread:) withObject:@&quot;multiThread1&quot;]; //主线程中的循环打印任务2 for (int i = 0; i &lt; 50; i++) &#123; NSLog(@&quot;主线程2:%i&quot;, i); &#125; &#125;//多线程的入口方法- (void)thread:(NSString *)threadName &#123; //获取当前线程对象 NSThread *thread = [NSThread currentThread]; NSLog(@&quot;多线程:%@&quot;, thread); //当前线程分配的堆栈大小:512K NSLog(@&quot;多线程stackSize:%li&quot;, thread.stackSize); for (int j = 0; j &lt; 50; j++) &#123; NSLog(@&quot;%@:%i&quot;, threadName, j); // if(j % 10 == 0) &#123;// //线程睡眠// [NSThread sleepForTimeInterval:1];// &#125; // if (j == 10) &#123;// // //线程退出的方法// [NSThread exit];//// &#125; &#125; //判断当前线程是否为主线程 if (![NSThread isMainThread]) &#123; NSLog(@&quot;当前线程不是主线程&quot;); &#125;&#125;@end 线程同步解决方案ViewController.h 12345678910#import &lt;UIKit/UIKit.h&gt;@interface ViewController : UIViewController//atomic--&gt;给多线程加锁//nonatomic--&gt;不加锁@property(atomic, copy)NSString *name;@end ViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#import &quot;ViewController.h&quot;@interface ViewController () &#123; int tickets; //剩余票数 NSCondition *condition; //线程代码加锁的处理类&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; tickets = 50; condition = [[NSCondition alloc] init]; [self performSelectorInBackground:@selector(saleTickets:) withObject:@&quot;thread1&quot;]; [self performSelectorInBackground:@selector(saleTickets:) withObject:@&quot;thread2&quot;]; [self performSelectorInBackground:@selector(saleTickets:) withObject:@&quot;thread3&quot;];&#125;//多线程访问共享资源会产生数据不同步的问题。//解决方案：给共享资源所在的代码加锁，当一个线程在访问此段代码时，会把这段代码锁住，其它线程无法操作这段代码。//加锁后会保证数据同步，但是会影响性能，实际开发中，要根据具体的需要进行加锁处理。- (void)saleTickets:(NSString *)name &#123; while (true) &#123; //加锁 [condition lock]; if (tickets &gt; 0) &#123; if ([name isEqualToString:@&quot;thread1&quot;]) &#123; [NSThread sleepForTimeInterval:2]; &#125; else &#123; [NSThread sleepForTimeInterval:0.1]; &#125; tickets--; NSLog(@&quot;%@卖了一张车票，剩余票数为%i&quot;, name, tickets); &#125; //解锁 [condition unlock]; &#125;&#125;- (void)setName:(NSString *)name &#123; if (_name != name) &#123; [condition lock]; _name = [name copy]; [condition unlock]; &#125;&#125; NSOperationQueue任务队列处理多线程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#import &quot;ViewController.h&quot;@interface ViewController () &#123; NSInvocationOperation *op2; NSInvocationOperation *op1;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //1.创建任务队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; //5.(1)设置任务队列的并发数 queue.maxConcurrentOperationCount = 1; //2.创建任务对象 op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(thread1:) object:@&quot;operation1&quot;]; op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(thread2:) object:@&quot;operation2&quot;]; //5(2）设置任务执行的优先级 //如果当前队列正常运行，则优先级别不起作用 op1.queuePriority = NSOperationQueuePriorityVeryLow; op2.queuePriority = NSOperationQueuePriorityHigh; //5（3）任务完成时调用的block op2.completionBlock = ^&#123; NSLog(@&quot;任务2执行完毕&quot;); &#125;; //暂停执行队列中的任务，再添加任务，此时会按照任务的优先级别来执行任务。 queue.suspended = YES; //4.将任务对象添加到任务队列中。任务队列就会给此任务绑定一个线程开始执行。 [queue addOperation:op1]; [queue addOperation:op2]; //把任务队列唤醒 queue.suspended = NO; //6.创建任务对象，并将任务对象添加到任务队列的另一种方式 [queue addOperationWithBlock:^&#123; //block中的代码就可以理解一个任务的入口方法 for (int i = 0; i &lt; 50; i++) &#123; NSLog(@&quot;block-thread:%i&quot;, i); &#125; &#125;]; //3.主线程中的打印任务 for (int i = 0; i &lt; 50; i++) &#123; NSLog(@&quot;mainThread:%i&quot;, i); &#125;&#125;//多线程的入口方法- (void)thread1:(NSString *)name &#123; for (int i = 0; i &lt; 50; i++) &#123; NSLog(@&quot;%@：%i&quot;, name, i); &#125;&#125;- (void)thread2:(NSString *)name &#123; for (int i = 0; i &lt; 50; i++) &#123; // if (i == 25) &#123;// //如果当前任务在执行状态，此方法无作用// [op1 cancel];// //如果当前任务没有执行，此方法的作用是把任务从队列中移除// //cancel只是更新了任务对象的一个属性isCancelled＝YES。// // &#125; NSLog(@&quot;%@：%i&quot;, name, i); &#125;&#125;@end 自定义任务类MyOperation.h 123456789#import &lt;Foundation/Foundation.h&gt;@interface MyOperation : NSOperation@property(nonatomic, copy)NSString *mask;- (instancetype)initWithName:(NSString *)mask;@end MyOperation.m 1234567891011121314151617181920212223242526272829#import &quot;MyOperation.h&quot;@implementation MyOperation- (instancetype)initWithName:(NSString *)mask &#123; if (self = [super init]) &#123; _mask = mask; &#125; return self;&#125;//自定义任务类时，必须在类中重写main方法，此方法执行此任务的入口方法- (void)main &#123; //多线程创建的实例对象是不会加入到主线程的自动释放池中的，可能会导致内存泄露。 //需要在多线程的入口方法中加入自动释放池。 @autoreleasepool &#123; for (int i = 0; i &lt; 1000; i++) &#123; //cancel方法的作用只是改变了isCancelled的状态，不会马上取消当前任务。会在未来的某个时刻，在main方法中检查isCancelled状态时退出当前操作。 if (self.isCancelled) &#123; break; &#125; NSLog(@&quot;%@:%i&quot;, self.mask, i); &#125; &#125;&#125;@end 然后再主控制器中实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#import &quot;ViewController.h&quot;#import &quot;MyOperation.h&quot;@interface ViewController () &#123; MyOperation *_op1; MyOperation *_op2; NSOperationQueue *_queue;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. _queue = [[NSOperationQueue alloc] init]; _op1 = [[MyOperation alloc] initWithName:@&quot;myOp1&quot;]; _op2 = [[MyOperation alloc] initWithName:@&quot;myOp2&quot;]; _queue.maxConcurrentOperationCount = 2; [_queue addOperation:_op1]; [_queue addOperation:_op2]; _op1.completionBlock = ^&#123; NSLog(@&quot;任务1结束了----------------&quot;); &#125;; _op2.completionBlock = ^&#123; NSLog(@&quot;任务2结束了----------------&quot;); &#125;; //[self performSelector:@selector(afterDelay) withObject:nil afterDelay:0.1]; [self performSelector:@selector(cancelAllTasks) withObject:nil afterDelay:0.5];&#125;- (void)afterDelay &#123; [_op1 cancel]; //isCancelled--&gt;YES //如果任务没有开始执行，则取消，如果任务开始执行了，则需要在当前任务类的main方法中手动去判断isCancelled属性是否为YES，如果为YES,则退出当前操作。&#125;- (void)cancelAllTasks &#123; //取消当前队列中的所有任务 [_queue cancelAllOperations];&#125;@end GCD的基本使用1.GCD的本质就是定义想要执行的任务，并把任务追加到适当的Dispatch Queue中。 2.Dispatch Queue就是执行处理的等待队列，使用block语法来追加任务到队列中，队列按照先进先出的原则处理任务。 分为两种： （1）串行队列：所有的任务排队执行，按照添加到队列中的顺序执行。可能只会开启一个线程。 （2）并行队列：所有任务并发执行。可能开启多个线程。并行队列并发的线程数量取决当前系统的状态，GCD会根据当前操作系统中CPU的核数，CPU的负荷，状态来确定并发数量。 （3）主队列（串行队列）：其中只有一个主线程在运行。 3.两种追加任务的方式：同步追加和异步追加 （1）异步追加：可能会开启新的线程来执行新任务。 1&gt;dispatch_async函数的特点：追加任务立即返回，执行下面的代码。 2&gt;追加到串行队列：新任务排队执行。 3&gt;追加到并行队列：并发执行新任务。 （2）同步追加：在当前线程执行新任务，一般来讲不会开启新线程。 1&gt;dispatch_sync函数的特点：会一直等待，等待到当前的新任务添加到队列并且执行完毕才能返回，继续执行下面的代码。 2&gt;必须等到追加的队列中所有的前面排队的任务执行完成后，才能把新任务追加到队列中，并且执行。 4.分为四种情况来解释GCD的基本操作 （1）向并行队列中异步添加任务（最常用） （2）向串行队列中异步添加任务 （3）向并行队列中同步添加任务 （4）向串行队列中同步添加任务 下面直接上代码： ViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#import &quot;ViewController.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //[self concurrentAndAsync]; //[self serialAndAsync]; [self concurrentAndSync]; //[self serialAndSync]; [self mainQueuePrintTask];&#125;- (void)mainQueuePrintTask &#123; for (int i = 0; i &lt; 200; i++) &#123; NSLog(@&quot;主线程任务:%i&quot;, i); &#125;&#125;//(4) 向串行队列中同步添加任务- (void)serialAndSync &#123; //创建一个串行队列 dispatch_queue_t queue = dispatch_queue_create(&quot;huiwen&quot;, DISPATCH_QUEUE_SERIAL); //向串行队列中同步的添加任务 dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 50; i++) &#123; NSLog(@&quot;同步任务1:%i&quot;, i); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 50; i++) &#123; NSLog(@&quot;同步任务2:%i&quot;, i); &#125; &#125;);&#125;//（3）向并行队列中同步添加任务- (void)concurrentAndSync &#123; //获取系统提供的并行队列：一般来讲不会创建新的并行队列 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //同步添加任务 dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 50; i++) &#123; NSLog(@&quot;同步任务1:%i&quot;, i); &#125; &#125;); dispatch_sync(queue, ^&#123; for (int i = 0; i &lt; 50; i++) &#123; NSLog(@&quot;同步任务2:%i&quot;, i); &#125; &#125;);&#125;// （2）向串行队列中异步添加任务- (void)serialAndAsync &#123; //创建一个串行队列 dispatch_queue_t queue = dispatch_queue_create(&quot;huiwen&quot;, DISPATCH_QUEUE_SERIAL); //向串行队列中异步的添加任务 dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 50; i++) &#123; NSLog(@&quot;异步任务1:%i&quot;, i); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 50; i++) &#123; NSLog(@&quot;异步任务2:%i&quot;, i); &#125; &#125;); /* 主线程中有三个任务：异步添加任务1，异步添加任务2，打印任务 先执行异步添加任务1，dispatch_asyc不做任何等待，立即执行主线程中下面的任务。要把任务添加串行队列中，要等待串行队列中排队的任务执行完成新任务才能被添加且执行。此时串行队列无排队任务，新任务1立即添加执行（绑定一个新的多线程）。 主线程执行异步添加任务2，dispatch_asyc不做任何等待，立即执行主线程中下面的任务。要把任务添加串行队列中，要等待串行队列中排队的任务执行完成新任务才能被添加且执行。此时串行队列有排队新任务1在执行，新任务2需要等待新任务1执行完毕后才能添加到串行队列中并执行。因此没有开启新线程执行新任务2，而是和新任务1在同一个线程中执行。 主线程中的打印任务。 两条路径，新任务1和新任务2在多线程中有顺序的运行，主线程中的打印任务和它们并发执行。 */&#125;//（1）向并行队列中异步添加任务（最常用）- (void)concurrentAndAsync &#123; //获取系统提供的并行队列：一般来讲不会创建新的并行队列 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //向并行队列中异步添加两个任务 dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 50; i++) &#123; NSLog(@&quot;异步任务1:%i&quot;, i); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 50; i++) &#123; NSLog(@&quot;异步任务2:%i&quot;, i); &#125; &#125;); /* 主线程中有三个任务：异步添加任务1，异步添加任务2，打印任务 先执行异步添加任务1，dispatch_asyc不做任何等待，立即添加任务到并行队列中，新任务1立即执行（开启新线程1），与此同时，主线程中继续执行dispatch_async下面的代码。 异步添加任务2，dispatch_asyc不做任何等待，立即添加任务到并行队列中，新任务2立即执行（开启新线程2），与此同时，主线程中继续执行dispatch_async下面的代码。 主线程中执行打印任务。 三个线程，三条程序执行的路径，并行。因此三个打印任务是并发执行的。 */&#125;@end GCD可以运用到遍历数组中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 //遍历数组的方式 //1.普通遍历 //2.快速遍历 NSArray *array = @[@1,@2,@3,@4,@5,@6,@7,@8,@9];// // for (NSNumber *object in array) &#123;// // NSLog(@&quot;%@&quot;,object);// // &#125; //3.枚举器遍历// [array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;// // NSLog(@&quot;%@&quot;, obj);// // if (idx == 5) &#123;// *stop = YES;// &#125;// // // &#125;];// // NSDictionary *dic = @&#123;@&quot;hello&quot; : @&quot;world&quot;,// @&quot;hi&quot;: @&quot;hate&quot;// // &#125;;// [dic enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;// NSLog(@&quot;%@:%@&quot;, key, obj);// &#125;]; // BOOL isStop = NO;// // for (int index = 0; index &lt; array.count; index++) &#123;// block(array[index], index, &amp;isStop);// // if (isStop) &#123;// break;// &#125;// // // &#125; //4. 用队列异步操作数组，进行数组的遍历 //操作无序的，把访问每一个元素的任务异步添加到并行队列，并发执行。这样的操作非常高效。 dispatch_queue_t gloableQueue = dispatch_get_global_queue(0, 0); dispatch_apply(array.count, gloableQueue, ^(size_t index) &#123; NSLog(@&quot;%lu:%@&quot;, index, array[index]); &#125;); 同步追加产生的死锁 同步追加任务到主队列产生死锁 如何从多线程中回到主线程中去更新UI GCD使用总结： 向并行队列异步添加会开启一条新线程。 向串行队列异步添加可能会开启一条新线程。 同步添加不会开启一条新线程。 向主队列同步追加任务很容易产生死锁。 大任务的处理一般使用多线程完成，如网络申请，大文件的操作以及数据库操作。但是如果多线程中任务完成，需要更新UI,则必须回到主线程更新UI。 需要回到主线程更新UI时，可以使用同步追加或者异步追加，具体使用哪种追加方式，需要根据实际情况判断，如果多线程中的其它任务需要等到更新UI之后才进行，则使用同步追加，如果没有特殊需求，则两种方式都可以进行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#import &quot;ViewController.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // [self addSyncTaskToMainQueue];// [self mainQueuePrintTask]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; //网络申请 //网络申请图片成功后要更新UI,将图片显示在界面上。 //更新UI的动作要在主线程完成，需要添加任务到主队列。 dispatch_sync(dispatch_get_main_queue(), ^&#123; // UIImageView *imageView; // // imageView.image = image; NSLog(@&quot;GCD主线程&quot;); &#125;); NSLog(@&quot;GCD多线程&quot;); &#125;);&#125;- (void)mainQueuePrintTask &#123; for (int i = 0; i &lt; 50; i++) &#123; NSLog(@&quot;主线程打印任务:%i&quot;, i); &#125;&#125;- (void)addSyncTaskToMainQueue &#123; //获取主队列 dispatch_queue_t mainQueue = dispatch_get_main_queue(); //向主队列中同步追加任务,产生死锁 //同步追加时，dispatch_sync函数在一直等待block任务添加到主队列中并执行，不添加不执行完毕无法继续下面的代码。 //而同步追加的特点是必须等到当前队列中所有的任务全部执行完毕才能追加到队列中，因此互相等待，造成死锁。 //异步追加，可以正常运行，因为dispathc_async函数不需要等待。 dispatch_async(mainQueue, ^&#123; NSLog(@&quot;主线程block任务&quot;); &#125;);&#125;@end 多线程下载图片我们自定义一个UIImageView的扩展：UIImageView+ImageRequest UIImageView+ImageRequest.h 1234567#import &lt;UIKit/UIKit.h&gt;@interface UIImageView (ImageRequest)- (void)setImageWithURL:(NSURL *)url;@end UIImageView+ImageRequest.m 12345678910111213141516171819202122232425262728#import &quot;UIImageView+ImageRequest.h&quot;@implementation UIImageView (ImageRequest)- (void)setImageWithURL:(NSURL *)url &#123; // NSData *data = [NSData dataWithContentsOfURL:url];// // UIImage *image = [UIImage imageWithData:data];// // self.image = image; dispatch_queue_t queue = dispatch_get_global_queue(0, 0); dispatch_async(queue, ^&#123; //下载图片数据任务在多线程中处理 NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; //更新UI要在主线程中处理 dispatch_sync(dispatch_get_main_queue(), ^&#123; self.image = image; &#125;); &#125;);&#125;@end 然后在主控制器中实现： 123456789101112131415161718192021222324252627282930313233343536373839404142#import &quot;ViewController.h&quot;#import &quot;UIImageView+ImageRequest.h&quot;@interface ViewController () &#123; NSMutableArray *imgViews; BOOL isLoad;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; imgViews = [NSMutableArray array]; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3 ; j++) &#123; UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(110*j, 110*i+20, 105, 105)]; imageView.backgroundColor = [UIColor orangeColor]; [self.view addSubview:imageView]; [imgViews addObject:imageView]; &#125; &#125; isLoad = NO;&#125;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123; if (!isLoad) &#123; for (UIImageView *imageView in imgViews) &#123; NSString *urlString = @&quot;https://ww3.sinaimg.cn/large/006y8lVagw1fbrqb5ry15j303c03cwee.jpg&quot;; NSURL *url = [NSURL URLWithString:urlString]; //网络加载，将imageView显示的图片设置为网络加载图片 [imageView setImageWithURL:url]; &#125; isLoad = YES; &#125; &#125;@end 单例不说废话，直接上demo是我的风格： AdressBook.h 1234567891011121314#import &lt;Foundation/Foundation.h&gt;@interface AdressBook : NSObject@property(nonatomic,assign)NSUInteger phone;@property(nonatomic,copy)NSString *name;//...//单例的类方法+ (AdressBook *)shareInstance;@end AdressBook.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#import &quot;AdressBook.h&quot;static AdressBook *instance = nil;@implementation AdressBook+ (AdressBook *)shareInstance &#123; // AdressBook *book = [[AdressBook alloc] init];// return [book autorelease]; // if (instance == nil) &#123;// instance = [[self alloc] init];// &#125;//// return instance; //API:当dispatch_once函数被调用多次时，block中的代码只被执行一次,onceToken是记录是否是第一次执行标记（令牌） //GCD的接口可以保证线程安全。 static dispatch_once_t onceTocken = 0; dispatch_once(&amp;onceTocken, ^&#123; instance = [[self alloc] init]; &#125;); return instance; &#125;//+ (instancetype)alloc &#123;// // [self allocWithZone:&lt;#(struct _NSZone *)#&gt;];////&#125;//allo分配内存的工作是自动调用allocWithZone完成的，如果要实现单例则需要复写allocWithZone//实现一些限制方法，限制这个类始终只能创建一个对象，并且此对象不能销毁+ (id)allocWithZone:(struct _NSZone *)zone &#123; if (instance == nil) &#123; instance = [super allocWithZone:zone]; &#125; return instance;&#125;//此方法是调用copy方法之后调用的- (id)copyWithZone:(NSZone *)zone &#123; //正常实现是新创建对象，作为复制的副本对象 return self;&#125;- (oneway void)release &#123; &#125;- (id)autorelease &#123; return self;&#125;- (id)retain &#123; return self;&#125;- (NSUInteger)retainCount &#123; return UINT_MAX;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CALayer的基本使用]]></title>
      <url>%2F2017%2F01%2F13%2FCALayer%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[CALayer和UIView的区别1.UIView是UIKit的(只能iOS使用)，CALayer是QuartzCore的(iOS和mac os通用) 2.UIView继承UIResponder,CALayer继承NSObject,UIView比CALayer多了一个事件处理的功能，也就是说，CALayer不能处理用户的触摸事件，而UIView可以 3.UIView来自CALayer，是CALayer的高层实现和封装，UIView的所有特性来源于CALayer支持 4.CABasicAnimation，CAAnimation，CAKeyframeAnimation等动画类都需要加到CALayer上 其实UIView之所以能显示在屏幕上，完全是因为它内部的一个图层 在创建UIView对象时，UIView内部会自动创建一个图层(即CALayer对象)，通过UIView的layer属性可以访问这个层 CALayer的基本属性12//圆角半径view.layer.cornerRadius = 50; 1234//阴影view.layer.shadowColor = [UIColor lightGrayColor].CGColor;view.layer.shadowOffset = CGSizeMake(10, 10);view.layer.shadowOpacity = 1; 123//边框view.layer.borderColor = [UIColor redColor].CGColor;view.layer.borderWidth = 3; 1234//仅表示给父层倒圆角,子层无相关设置//imgView.layer.cornerRadius = 100;//表示子层随父层一起变化//imgView.layer.masksToBounds = YES; 1234//阴影效果不能和maskToBounds一起设置imgView.layer.shadowColor = [UIColor lightGrayColor].CGColor;imgView.layer.shadowOffset = CGSizeMake(10, 10);imgView.layer.shadowOpacity = 1; 12345678//3D形变//旋转效果：1为顺时针，-1为逆时针//imgView.layer.transform = CATransform3DMakeRotation(M_PI/2, 0, 0, 1);//KVC来设置形变效果,可以进行效果叠加[imgView.layer setValue:@-100 forKeyPath:@&quot;transform.translation&quot;];[imgView.layer setValue:@M_PI_4 forKeyPath:@&quot;transform.rotation.z&quot;]; 详细请见下图： 创建CALayer来显示内容CALayer不能接收点击事件，只能显示界面，它的出现只是为了提高动画的执行效率，父类是NSObject。 UIView的父类是UIResponder，可以接收事件，并且参与到事件响应者链中。 1234567891011121314151617181920212223242526272829303132 //1.创建图层 CALayer *myLayer = [CALayer layer]; //2.添加到self.view的rootLayer上才能显示 [self.view.layer addSublayer:myLayer]; //3.设置属性 myLayer.bounds = CGRectMake(0, 0, 200, 200); myLayer.backgroundColor = [UIColor redColor].CGColor; myLayer.position = CGPointMake(100, 100); //锚点的取值是0-1之间的值,默认值为0.5，0.5 //锚点决定了当前层和postion之间的相对位置 myLayer.anchorPoint = CGPointMake(0.5, 0.5); //当层进行3D形变时，会以锚点为轴进行放大缩小以及旋转 [myLayer setValue:@-M_PI_4 forKeyPath:@&quot;transform.rotation.z&quot;]; UIImage *image =[UIImage imageNamed:@&quot;ali.jpg&quot;]; //把图片作为当前层的显示内容 myLayer.contents = (id)image.CGImage; //myLayer.contents = (__bridge id _Nullable)([UIImage imageNamed:@&quot;ali.jpg&quot;].CGImage);//内容模式，类似于UIImageView的contentMode。默认是填充整个区域 kCAGravityResize//kCAGravityResizeAspectFill 这个会向左边靠 贴到view的边边上//kCAGravityResizeAspect 这个好像就是按比例了 反正是长方形myLayer.contentsGravity = kCAGravityResizeAspect; CALayer的隐式动画属性非rootLayer才有存在隐式动画。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#import &quot;ViewController.h&quot;@interface ViewController () &#123; CALayer *myLayer;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. myLayer = [CALayer layer]; myLayer.bounds = CGRectMake(0, 0, 100, 100); myLayer.backgroundColor = [UIColor orangeColor].CGColor; [self.view.layer addSublayer:myLayer]; myLayer.position = CGPointMake(100, 100);&#125;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123; UITouch *touch = [touches anyObject]; CGPoint p = [touch locationInView:self.view]; //开始动画,动画事务性的处理 [CATransaction begin]; //关闭CALayer的隐式动画效果 [CATransaction setDisableActions:YES]; //修改图层的显示位置 myLayer.position = p; NSInteger size = arc4random_uniform(50) + 50; myLayer.bounds = CGRectMake(0, 0, size, size); myLayer.opacity = arc4random_uniform(10)/10.0; //提交动画效果 [CATransaction commit]; // [UIView beginAnimations:&lt;#(NSString *)#&gt; context:&lt;#(void *)#&gt;];// [UIView commitAnimations];&#125; 在CALayer上绘图1234567891011121314CALayer *layer = [CALayer layer];layer.bounds = CGRectMake(0, 0, 200, 200);layer.backgroundColor = [UIColor grayColor].CGColor;layer.position = CGPointMake(100, 100);[self.view.layer addSublayer:layer];//设置图层的代理对象，调用代理对象的相关协议方法进行内容的绘制//不能把self.view作为当前层的代理，因为它已经是rootLayer的代理，再次设置会出问题：self.view.layer.delegate = self.view;layer.delegate = self;//必须发送此消息，才能触发当前层代理对象绘图协议方法的调用[layer setNeedsDisplay]; 然后实现代理 1234567891011121314151617#pragma mark - CALayer delegate- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx &#123; //NSLog(@&quot;%@&quot;, layer); //用UIKit提供的方法进行绘制无法实现绘制 //此协议方法是CALayer的协议方法，为了避免CA框架和UIKit耦合，UIKit提供的方法在此处无效，因为在此处使用UIKit函数无法获取到context。// [[UIColor blueColor] setFill];// // UIRectFill(CGRectMake(50, 50, 100, 100)); //只能使用CG框架提供的接口进行绘制 CGContextAddRect(ctx, CGRectMake(50, 50, 100, 100)); CGContextSetRGBFillColor(ctx, 0, 0, 1, 1); CGContextDrawPath(ctx, kCGPathFill); &#125; 下面我们通过CALayer来创建一个UIView,说明UIView,CALayer,图形上下文之间的关系 在一个UIView的子类中实现下面的方法： 123456789101112131415161718192021222324252627282930313233343536- (instancetype)initWithFrame:(CGRect)frame &#123; if (self = [super initWithFrame:frame]) &#123; //在UIView的构造方法中做了如下设置，把当前UIView的Layer属性的delegate设置为当前UIView对象。 //self.layer.delegate = self; &#125; return self;&#125;// Only override drawRect: if you perform custom drawing.// An empty implementation adversely affects performance during animation.- (void)drawRect:(CGRect)rect &#123; // Drawing code // NSLog(@&quot;%@&quot;, self);// NSLog(@&quot;%@&quot;, self.layer.delegate); CGContextRef context = UIGraphicsGetCurrentContext(); //在drawRect:方法中获取的context就是CALayer准备好的context传入协议方法中的context。 NSLog(@&quot;%p&quot;, context); &#125;- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx &#123; NSLog(@&quot;%p&quot;, ctx); //必须调用父类的协议方法，因为在UIView的此协议方法中会自动调用drawRect:进行绘制，如果不调用则drawRect:不会被调用。 [super drawLayer:layer inContext:ctx]; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Quartz 2D的基本使用]]></title>
      <url>%2F2017%2F01%2F13%2FQuartz-2D%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[什么是Quartz2D?Quartz 2D是一个二维绘图引擎，同时支持iOS和Mac系统 Quartz 2D能完成的工作 绘制图形 : 线条\三角形\矩形\圆\弧\贝塞尔曲线等 绘制文字 绘制\生成图片(图像) 读取\生成PDF 截图\裁剪图片 自定义UI控件 Quartz2D在iOS开发中的价值: 绘制一些系统UIKit框架中不好展示的内容，例如饼图 自定义一些控件 不添加UI控件的情况下，使UI内容更丰富 …… iOS中，大部分控件都是Quartz2D绘制出来的 图形上下文图形上下文就相当于画布，不同类型的画布就是决定着画得内容将展示在哪里 Quartz2D提供了以下几种类型的Graphics Context：◦ Bitmap Graphics Context 位图上下文，在这个上下文上绘制或者渲染的内容，可以获取成图片（需要主动创建一个位图上下文来使用，使用完毕，一定要销毁）◦ PDF Graphics Context◦ Window Graphics Context◦ Layer Graphics Context 图层上下文，针对UI控件的上下文◦ Printer Graphics Context drawRect:为什么要实现drawRect:方法才能绘图到view上？因为在drawRect:方法中才能取得跟view相关联的图形上下文 drawRect:中取得的上下文，然后就可以绘制东西到view上 View内部有个layer（图层）属性，drawRect:方法中取得的是一个Layer Graphics Context，因此，绘制的东西其实是绘制到view的layer上去了 View之所以能显示东西，完全是因为它内部的layer drawRect:方法的调用？• 当view第一次显示到屏幕上时，系统会创建好一个跟当前view相关的Layer上下文• 系统会通过此上下文，在drawRect:方法中绘制好当前view的内容• 主动让view重绘内容的时候，调用setNeedsDisplay或者setNeedsDisplayInRect:。我们主动调用drawRect:方法是无效的。• 调用view的setNeedsDisplay或者setNeedsDisplayInRect:时。• 注意：setNeedsDisplay和setNeedsDisplayInRect:方法调用后，屏幕并不是立即刷新，而是会在下一次刷新屏幕的时候把绘制的内容显示出来。 也正是系统会在调用这个方法之前创建一个与该view相关的上下文，才让我们可以在drawRect:方法中绘制。注意：在其他地方拿不到view相关的上下文，所以不能实现绘制。 自定义view如何利用Quartz2D绘制东西到view上？• 首先，得有图形上下文，因为它能保存绘图信息，并且决定着绘制到什么地方去• 其次，那个图形上下文必须跟view相关联，才能将内容绘制到view上面 自定义view的步骤:1 新建一个类，继承自UIView2 实现- (void)drawRect:(CGRect)rect方法，然后在这个方法中3 取得跟当前view相关联的图形上下文4 绘制相应的图形内容5 利用图形上下文将绘制的所有内容渲染显示到view上面 常用拼接路径函数• 新建一个起点void CGContextMoveToPoint(CGContextRef c, CGFloat x, CGFloat y)• 添加新的线段到某个点void CGContextAddLineToPoint(CGContextRef c, CGFloat x, CGFloat y)• 添加一个矩形void CGContextAddRect(CGContextRef c, CGRect rect)• 添加一个椭圆void CGContextAddEllipseInRect(CGContextRef context, CGRect rect)• 添加一个圆弧void CGContextAddArc(CGContextRef c, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat endAngle, int clockwise) 常用绘制路径函数• Mode参数决定绘制的模式void CGContextDrawPath(CGContextRef c, CGPathDrawingMode mode)• 绘制空心路径void CGContextStrokePath(CGContextRef c)• 绘制实心路径void CGContextFillPath(CGContextRef c)提示：一般以CGContextDraw、CGContextStroke、CGContextFill开头的函数，都是用来绘制路径的 图形上下文栈的操作• 将当前的上下文copy一份,保存到栈顶(那个栈叫做”图形上下文栈”)void CGContextSaveGState(CGContextRef c)• 将栈顶的上下文出栈,替换掉当前的上下文void CGContextRestoreGState(CGContextRef c) 矩阵操作利用矩阵操作，能让绘制到上下文中的所有路径一起发生变化• 缩放void CGContextScaleCTM(CGContextRef c, CGFloat sx, CGFloat sy)• 旋转void CGContextRotateCTM(CGContextRef c, CGFloat angle)• 平移void CGContextTranslateCTM(CGContextRef c, CGFloat tx, CGFloat ty) 绘图的核心步骤：1 获得上下文2 绘制/拼接绘图路径3 将路径添加到上下文4 渲染上下文记住：所有的绘图，都是这个步骤，即使使用贝塞尔路径，也只是对这个步骤进行了封装。对于绘图而言，拿到上下文很关键。 贝塞尔路径就是UIKit框架中，对绘图的封装。实际操作起来，使用贝塞尔路径，更为方便。• 用法与CGContextRef类似，但是oc对其进行了封装，更加面向对象。• 常用的方法：◦ 返回一个描述椭圆的路径:+ (UIBezierPath *)bezierPathWithOvalInRect:(CGRect)rect;◦ 设置起始点:- (void)moveToPoint:(CGPoint)point;◦ 添加直线到一点:- (void)addLineToPoint:(CGPoint)point;◦ 三次贝塞尔曲线：- (void)addCurveToPoint:(CGPoint)endPoint controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2; 贝塞尔曲线:- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint; 绘制圆弧:- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise; 封闭闭路径:- (void)closePath; 接下来针对上面讲的一些内容，我们来做几个小demo。上代码：下面的都是在drawRect方法里面实现的。 绘制线条 绘制线条的第一种方式：创建路径，将线条添加到路径上，再把路径添加到图形上下文 123456789101112131415161718192021222324252627282930313233343536373839//1.获取当前的图形上下文CGContextRef context = UIGraphicsGetCurrentContext();// .创建一条绘制的路径，此路径为可变的路径CGMutablePathRef path = CGPathCreateMutable();//3.起始点CGPathMoveToPoint(path, NULL, 50, 50);CGPathAddLineToPoint(path, NULL, 100, 100);CGPathAddLineToPoint(path, NULL, 50, 100);//4.关闭路径CGPathCloseSubpath(path); //5.把路径添加到图形上下文，才能显示在界面上。 CGContextAddPath(context, path);//6.设置图形上下文的属性（如线条的颜色宽度等）CGContextSetRGBStrokeColor(context, 254/255.0, 201/255.0, 22/255.0, 1);CGContextSetRGBFillColor(context, 1, 0, 0, 1);CGContextSetLineWidth(context, 3.0);//7.绘制CGContextDrawPath(context, kCGPathFillStroke); //8.释放路径CGPathRelease(path); 绘制线条的第二种方式：直接将线条绘制到图形上下文上。 12345678910111213141516171819//获取当前的图形上下文CGContextRef context = UIGraphicsGetCurrentContext();CGPoint points[] = &#123;&#123;50,50&#125;, &#123;200,200&#125;, &#123;50,200&#125;, &#123;50,50&#125;&#125;;//直接将线条添加到图形上下文CGContextAddLines(context, points, 4);//设置图形上下文的属性[[UIColor redColor] setStroke];[[UIColor blueColor] setFill];//[[UIColor orangeColor] set]; //一起设置线条和填充颜色CGContextSetLineWidth(context, 5);//绘制CGContextDrawPath(context, kCGPathFillStroke); ​ 绘制矩形 123456789//获取当前的图形上下文CGContextRef context = UIGraphicsGetCurrentContext();CGContextAddRect(context, CGRectMake(10, 10, 200, 200));[[UIColor orangeColor] set];CGContextSetLineWidth(context, 5);//绘制CGContextDrawPath(context, kCGPathFillStroke); ​ 绘制圆形 1234567//获取当前的图形上下文CGContextRef context = UIGraphicsGetCurrentContext();CGContextAddArc(context, 100, 100, 100, 0, M_PI * 2, 0);[[UIColor redColor] set];CGContextDrawPath(context, kCGPathFillStroke); 绘制Bezier曲线 12345678//获取当前的图形上下文CGContextRef context = UIGraphicsGetCurrentContext();CGContextMoveToPoint(context, 20, 200);CGContextAddCurveToPoint(context, 100, 220, 200, 300, 300, 50);[[UIColor redColor] set];CGContextDrawPath(context, kCGPathFillStroke); 绘制文本:轻量级，不需要创建一个UI控件 12345678910111213NSString *str = @&quot;I am a teacher and you are a student&quot;;UIFont *font = [UIFont systemFontOfSize:18];UIColor *color = [UIColor redColor];NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];style.alignment = NSTextAlignmentCenter;NSDictionary *attributes = @&#123; NSFontAttributeName : font, NSForegroundColorAttributeName : color, NSParagraphStyleAttributeName : style &#125;;[str drawInRect:CGRectMake(50, 50, 200, 400) withAttributes:attributes]; 绘制图片：轻量级，不需要创建UIIMageView就能显示图片 123456789101112131415161718192021//获取当前的图形上下文CGContextRef context = UIGraphicsGetCurrentContext();//1.创建UIImageUIImage *image = [UIImage imageNamed:@&quot;ali.jpg&quot;];//2.坐标系统的转换 UIKit(左上）--&gt;Quarz2D（左下）//(1)保存UIKitContexCGContextSaveGState(context);//(2)把y缩放为原来的-1倍CGContextScaleCTM(context, 1, -1);//(3)把y平移图片高度CGContextTranslateCTM(context, 0, -image.size.height);CGContextDrawImage(context, CGRectMake(0, 0, image.size.width, image.size.height), image.CGImage);//(4）恢复contexCGContextRestoreGState(context); ​ 这里是我的一个关于自定义水印的demo:FDWaterImage 我们在做一个自定义的UILabel好了：FDLabel.h里面自定义两个开放的属性: 123456789import &lt;UIKit/UIKit.h&gt;@interface MyLabel : UIView@property(nonatomic, copy)NSString *text;@property(nonatomic, strong)UIFont *font;@end FDLabel.m 里面实现drawRect方法： 12345678910111213141516171819202122232425262728293031323334353637383940import &quot;FDLabel.h&quot;@implementation FDLabel- (instancetype)initWithFrame:(CGRect)frame &#123; if (self = [super initWithFrame:frame]) &#123; self.font = [UIFont systemFontOfSize:14]; self.text = @&quot;Label&quot;; &#125; return self;&#125;- (void)drawRect:(CGRect)rect &#123; // Drawing code //绘制文本 NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init]; style.alignment = NSTextAlignmentCenter; UIColor *color = [UIColor greenColor]; [self.text drawInRect:rect withAttributes:@&#123;NSFontAttributeName : self.font, NSForegroundColorAttributeName : color, NSParagraphStyleAttributeName : style &#125;];&#125;- (void)setFont:(UIFont *)font &#123; if (_font != font) &#123; _font = font; //刷新Label,要发送setNeedsDisplay方法来让系统自动调用drawRect:刷新 [self setNeedsDisplay]; &#125;&#125;- (void)setText:(NSString *)text &#123; if (_text != text) &#123; _text = text; [self setNeedsDisplay]; &#125;&#125;@end ​ 读取生成PDF首先创建一个工程，导入CoreText.framework框架。在ViewController.h文件中引入CoreText文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152-(void)drawText&#123; //在沙盒目录下创建PDF文件，并命名为Invoice.pdfNSString* fileName = @&quot;Invoice.PDF&quot;;NSArray *arrayPaths =NSSearchPathForDirectoriesInDomains( NSDocumentDirectory, NSUserDomainMask, YES);NSString *path = [arrayPaths objectAtIndex:0];NSString* pdfFileName = [path stringByAppendingPathComponent:fileName];//创建一个已“Hello，world”为内容的PDF，将string转换为CFStringRef格式NSString* textToDraw = @&quot;Hello World&quot;;CFStringRef stringRef = (__bridge CFStringRef)textToDraw;// 使用 Core Text Framesetter.CFAttributedStringRef currentText = CFAttributedStringCreate(NULL, stringRef, NULL);CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString(currentText);//创建一个CGRect用于定义文本的大小 CGRect frameRect = CGRectMake(0, 0, 300, 50);CGMutablePathRef framePath = CGPathCreateMutable();CGPathAddRect(framePath, NULL, frameRect);// 获取将要被渲染的帧CFRange currentRange = CFRangeMake(0, 0);CTFrameRef frameRef = CTFramesetterCreateFrame(framesetter, currentRange, framePath, NULL);CGPathRelease(framePath); //创建一个PDF上下文和标记的PDF的起始页。 PDF的每个页面都有开始并调用UIGraphicsBeginPDFPageWithInfo // 创建一个PDF的上下文，页面大小默认为 612 x 792UIGraphicsBeginPDFContextToFile(pdfFileName, CGRectZero, nil);// 标记新页面的开头UIGraphicsBeginPDFPageWithInfo(CGRectMake(0, 0, 612, 792), nil);// 获取上下文.CGContextRef currentContext = UIGraphicsGetCurrentContext(); // 创建一个PDF的上下文，页面大小默认为 612 x 792UIGraphicsBeginPDFContextToFile(pdfFileName, CGRectZero, nil);// 标记新页面的开头UIGraphicsBeginPDFPageWithInfo(CGRectMake(0, 0, 612, 792), nil);// 获取上下文.CGContextRef currentContext = UIGraphicsGetCurrentContext(); //由于Core Graphics 的坐标是从左下角开始，而UIKit的坐标是从左上角开始，所以需做一个变换： // 把文字变成矩阵已知状态。这将确保没有旧缩放因子被留在原处。 CGContextSetTextMatrix(currentContext, CGAffineTransformIdentity); //文本坐标翻转 CGContextTranslateCTM(currentContext, 0, 100); CGContextScaleCTM(currentContext, 1.0, -1.0); //绘制文本实际帧，释放Core Graphics对象，并关闭PDF上下文至此PDF写入到沙盒目录下。 // 绘制帧 CTFrameDraw(frameRef, currentContext); CFRelease(frameRef); CFRelease(stringRef); CFRelease(framesetter); //关闭PDF上下文 UIGraphicsEndPDFContext(); &#125; 我们使用UIWebView来加载PDF文件 1234567891011121314151617181920212223242526272829303132333435363738- (void)showPDFFile&#123;NSString* fileName = @&quot;Invoice.PDF&quot;;NSArray *arrayPaths =NSSearchPathForDirectoriesInDomains( NSDocumentDirectory, NSUserDomainMask, YES); NSString *path = [arrayPaths objectAtIndex:0]; NSString* pdfFileName = [path stringByAppendingPathComponent:fileName]; UIWebView* webView = [[UIWebView alloc] initWithFrame:CGRectMake(0, 0, 320, 480)]; NSURL *url = [NSURL fileURLWithPath:pdfFileName]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; [webView setScalesPageToFit:YES]; [webView loadRequest:request]; [self.view addSubview:webView]; &#125; -(void)viewDidLoad &#123; [self drawText]; [self showPDFFile]; [super viewDidLoad]; &#125; Quartz 2D的渐变方式分为两种：a.线性渐变线：渐变色以直线方式从开始位置逐渐向结束位置渐变 b.径向渐变：以中心点为圆心从起始渐变色向四周辐射，直到终止渐变色 要做渐变则必须先设置从开始位置到结束位置的渐变颜色，做过photoshop的朋友相信对于渐变色设置并不陌生，只要在指定位置指定不同的颜色，剩下的事情交给系统处理即可，如下图在起始位置、3/10位置、结束位置指定了三种颜色就形成由三种颜色组成的渐变色： 另外，在iOS中绘制渐变还需要注意一点就是指定颜色空间，所谓颜色空间就是不同颜色在不同的维度上取值最终组成一种颜色的过程。就拿RGB来说，如果将红色、绿色、蓝色看成是x、y、z轴坐标系，那么在三个坐标上分别取0~255范围内的不同值则可以组成各类颜色。当然，不同颜色空间的“坐标系”也是不同的（也就是说颜色表示的方式是不同的），常用的颜色空间除了RGB还有CMYK（印刷业常用这种颜色模式）、Gray。 在使用Quartz 2D绘图时我们的颜色除了使用常规的方法（前面CGContextSetRGBFillColor(CGContextRef context, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)方法）设置RGB和透明度外，有时还会遇到颜色参数是一个数组情况。如使用颜色空间填充时用到的CGContextSetFillColor(CGContextRef context, const CGFloat *components)方法，这个时候components数组中具体是如何存储颜色就要根据颜色空间而定，如果颜色空间使用RGB则数组中的元素四个为一组，分别是red（红）、green（绿）、blue（蓝）、alpha（透明度）；如果使用CMYK颜色空间，那么数组中的元素五个为一组，分别是cyan（青）、magenta（洋红）、yellow（黄）、black（黑）、alpha（透明度）。 详细demo请看：FDQuartz2DGradualChange或者还有一篇比较好的博客： http://blog.csdn.net/xy_26207005/article/details/51481510]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ARC的基本使用]]></title>
      <url>%2F2017%2F01%2F12%2FARC%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[ARC中可以重写dealloc，但是不允许调用[super dealloc] ARC中一般不需要重写Dealloc,但是一些情况比如移除通知，移除观察者等需要重写dealloc,在对象释放之前做一些内存的清理工作。 弱指针指向的实例对象被释放后，弱指针自动清空为nil __unsafe\__unretained修饰的指针，当其指向的实例对象被释放后，此指针不会自动清空。此关键字在iOS5之前会使用，目前几乎不使用。 弱指针使用的场景： (1)delegate属性一般使用weak避免产生循环引用 self–&gt;self.view–&gt;tableView–&gt;self 产生循环引用 (2)block (3)storyboard连线默认是weak:viewController–&gt;view–&gt;button,没有必要再让viewController再次持有一次button。 ARC桥接（Toll-free Bridging。 简称：TFB） 允许OC类型与对应的CoreFoundation类型之间相互转换的机制。 ARC进行内存管理的范围即OC对象，对于CF框架框架中的对象无法进行管理。 两个框架之间类型进行转换时，有三个关键字进行桥接：_bridge\_ bridge_retained __bridge_transfer \bridge表示即不授权也不放权，仍然由ARC来管理string对象的内存.__ CFStringRef cfstring1 = (__bridge CFStringRef)string; __bridge_retained表示ARC放弃管理内存，把此权利交给CF,由其管理内存 CFStringRef cfstring1 = (__bridge_retained CFStringRef)string; CFStringRef cfstring2 = CFBridgingRetain(string); CF释放内存 CFRelease(cfstring1); 下面举个例子： 123456CFStringRef cfString = CFStringCreateWithFormat(kCFAllocatorDefault, NULL, (__bridge CFStringRef)@&quot;text-%i&quot;, 100); //把CF对象转成OC对象 __bridge_transfer：表示把管理内存的权利授权给ARC,CF不需要管理内存 NSString *ocString = (__bridge_transfer NSString *)cfString; CFRelease(cfString); ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Block的基本用法]]></title>
      <url>%2F2017%2F01%2F12%2FBlock%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[block是OC中另外一种对象和对象的通信方式，是一对一的关系，类似于delegate，而通知时一对多的关系 Block的基本用法 block 也可以看做是一个变量，也有点类似于函数 123456789101112131415161718192021// block 的声明 // 返回值 (^变量名)(参数类型1, 参数类型2, ...) int (^block1)(int, int); // block 的赋值 // 注意 1. 参数不能只写类型，必须要带上参数名。 2. block的创建不代表代码块的运行 block1 = ^(int a, int b)&#123; return a + b; &#125;; // block 的调用 int sum = block1(10,20); NSLog(@&quot;%i&quot;, sum); 定义一个block类型 12345678910111213141516171819//---------------------block类型的定义---------------------// 定义一个block类型// 类型名：StringBlock 指代返回值为NSString* 参数为一个int 的blocktypedef NSString *(^StringBlock)(int);// 使用block类型 来定义变量StringBlock block2 = ^(int b)&#123; return [NSString stringWithFormat:@&quot;%i&quot;, b];&#125;;NSString *str1 = block2(5);NSLog(@&quot;%@&quot;, str1); block作为参数传递 首先我们先定义一个Person类，里面定义一个Block属性 Person.h 123456789101112131415- #import &lt;Foundation/Foundation.h&gt; typedef NSString *(^YearBlock)(); @interface Person : NSObject @property (nonatomic, copy) NSString *name; // 名字 @property (nonatomic, assign) NSInteger age; // 年龄 @property (nonatomic, copy) YearBlock block;- (instancetype)initWithName:(NSString *)name age:(NSInteger)age;- (void)setBlock:(YearBlock)block; @end Person.m 1234567891011121314151617181920 #import &quot;Person.h&quot; @implementation Person- (instancetype)initWithName:(NSString *)name age:(NSInteger)age &#123; self = [super init]; if (self) &#123; self.name = name; self.age = age; &#125; return self; &#125;- (void)setBlock:(YearBlock)block &#123; // block 在作为类的属性 或者全局变量时 需要使用copy _block = [block copy]; &#125; @end 然后在控制器中实现： 12345678910111213//---------------------block作为参数--------------------- Person *p = [[Person alloc] initWithName:@&quot;jack&quot; age:18]; [p setBlock:^NSString *&#123; return [NSString stringWithFormat:@&quot;%li&quot;, 2015 - p.age]; &#125;]; NSString *yearString = p.block(); NSLog(@&quot;%@&quot;, yearString); block页面传值 首先创建一个控制器SecondViewController，里面定义一个block SecondViewController.h 12345678910111213#import &lt;UIKit/UIKit.h&gt;// 给block 声明一个数据类型typedef void(^ShowTextBlock)(NSString *);@interface SecondViewController : UIViewController// 定义一个block@property (nonatomic, copy) ShowTextBlock block;@end ​ SecondViewController.m 12345678910111213141516171819#import &quot;SecondViewController.h&quot;@interface SecondViewController ()@property (weak, nonatomic) IBOutlet UITextField *textField;@end@implementation SecondViewController- (IBAction)enterButtonAction:(id)sender &#123; // 使用block 来回传数据 if (_block) &#123; block(textField.text); &#125; [self.navigationController popToRootViewControllerAnimated:YES]; &#125; @end ​ 然后在主控制器中给block赋值 1234567891011121314151617181920212223242526#import &quot;ViewController.h&quot;#import &quot;SecondViewController.h&quot;@interface ViewController ()@property (weak, nonatomic) IBOutlet UILabel *label;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. &#125;- (IBAction)pushInputView:(id)sender &#123; SecondViewController *second = [self.storyboard instantiateViewControllerWithIdentifier:@&quot;SecondViewController&quot;]; // 给block赋值 用于将回传的值 显示到label上面去 [second setBlock:^(NSString *text)&#123; _label.text = text; &#125;]; [self.navigationController pushViewController:second animated:YES]; &#125;@end ​ block的内存管理问题 循环引用的原因：某个对象 持有了一个 被 copy的block，这个block中，又引用了这个对象 解决方法: 使用一个__weak类型的中间指针 来引用这个对象。如：__ weak Person *weakP = p; 循环引用：造成了内存泄漏 在ARC中，block中使用到了某个对象，或者对象的属性，可以看作是block持有了这个对象 block和变量 局部变量：在block中，会把局部变量当成常量变量 123456789101112131415int num=10; int num=30; MyBlock myblock=^(int a) &#123; num=20; //此处会报错 NSLog(@&quot;%d&quot;,a); return 30; &#125;; ​ 原因：block代码块不会在写的地方执行，是在其他地方调用时才会执行，局部变量在跳出此作用域时销毁，所以block代码块会将局部变量当成一个常量变量来处理，要修改前面加__block 解决方法： 1234567891011121314151617__block int num=10; MyBlock myblock=^(int a) &#123; NSLog(@&quot;before the val of num is %d&quot;,num);num++; return 30; &#125;; num=30; [self testBlock:myblock];NSLog(@&quot;after the val of num is %d&quot;,num); ​ 输出结果： 1232013-10-28 15:38:24.602 blockDemo[1541:70b] before the val of num is 302013-10-28 15:38:24.603 blockDemo[1541:70b] after the val of num is 31 ​ 用block自定义一个按钮 BlockButton.h 1234567891011121314151617 #import &lt;UIKit/UIKit.h&gt; // 定义block类型 typedef void(^ButtonBlock)(UIButton *); @interface BlockButton : UIButton // 属性 block 用于在按钮被点击之后执行回调 @property (nonatomic, copy) ButtonBlock block; // 给按钮设置回调的block- (void)addBlock:(ButtonBlock)block;@end ​ BlockButton.m 1234567891011121314151617181920212223242526#import &quot;BlockButton.h&quot;@implementation BlockButton// 给按钮添加block回调- (void)addBlock:(ButtonBlock)block &#123; // 1. 储存block _block = [block copy]; // 2. 添加一个点击事件 [self addTarget:self action:@selector(buttonAction:) forControlEvents:UIControlEventTouchUpInside]; &#125;// 按钮的点击事件- (void)buttonAction:(UIButton *)button &#123; // 调用block // 判断 如果没有block if (_block) &#123; _block(button); &#125; &#125; @end ​ 然后在主控制器中 12345678910111213141516171819202122232425#import &quot;ViewController.h&quot;#import &quot;BlockButton.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; BlockButton *button2 = [BlockButton buttonWithType:UIButtonTypeContactAdd]; button2.frame = CGRectMake(100, 100, 30, 30); // 给按钮添加点击回调block [button2 addBlock:^(UIButton *button) &#123; // 按钮被点击之后 运行的代码 NSLog(@&quot;按钮被点击了&quot;); &#125;]; [self.view addSubview:button2]; &#125;- (void)buttonAction:(UIButton *)button &#123; &#125; @end ​ ​ ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[触摸与手势]]></title>
      <url>%2F2017%2F01%2F12%2F%E8%A7%A6%E6%91%B8%E4%B8%8E%E6%89%8B%E5%8A%BF%2F</url>
      <content type="text"><![CDATA[UITouch 触摸实现的方法很简单，只需要在视图中重写以下的方法就行 12345678910111213141516171819202122232425262728293031323334353637// 当有一个或者多个手指 开始触摸屏幕时调用- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;开始了一次触摸&quot;); //---------------------UITouch--------------------- // 从NSSet从 取出一个触摸对象 UITouch *touch = [touches anyObject]; // 获取触摸所在的window //NSLog(@&quot;触摸所在的window %@&quot;, touch.window); //NSLog(@&quot;当前视图所在的window%@&quot;, self.window); // 获取触摸所在的View// NSLog(@&quot;触摸所在的View:%@, self = %@&quot;, touch.view, self); // 触摸的位置 相对于某个视图的坐标点 CGPoint point = [touch locationInView:self.superview]; NSLog(@&quot;point x = %f, y = %f&quot;, point.x, point.y);&#125;- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;触摸结束&quot;);&#125;- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;移动触摸点&quot;);&#125;- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;触摸取消&quot;);&#125; 注：如果是在封装的控件中（如：UIView）实现UITouch的方法，那么只有点击这个View的时候才会触发这些方法。 下面我们实现两个小的demo 1、运用手势移动视图： 定义一个视图UIView的子类，然后实现下面的代码，然后就可以实现拖动视图的效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#import &quot;TouchView.h&quot;@interface TouchView()&#123; CGPoint _beganPoint; // 触摸开始的位置点&#125;@end@implementation TouchView// 开始- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;触摸开始&quot;); UITouch *touch = [touches anyObject]; // 获取起始点 相关与红色视图的位置 _beganPoint = [touch locationInView:self];&#125;// 移动- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event&#123; /* // 方法一 ：根据两次触摸之间的偏移 来改变视图的位置 // 当触摸移动时，视图跟着触摸一起移动 // 1. 获取触摸对象 UITouch *touch = [touches anyObject]; // 2. 获取触摸的位置 CGPoint point = [touch locationInView:self.superview]; // 获取前一个触摸点的位置 CGPoint prePoint = [touch previousLocationInView:self.superview]; // 计算位置的改变 CGPoint changed = CGPointMake(point.x - prePoint.x, point.y - prePoint.y); // 3. 改变视图位置 self.center = CGPointMake(self.center.x + changed.x, self.center.y + changed.y); */ // 方法二 ： 纪录触摸开始时的坐标点 来改变视图的位置 UITouch *touch = [touches anyObject]; // 获取触摸的位置 CGPoint point = [touch locationInView:self.superview]; // 计算位置的偏移 CGPoint point2 = CGPointMake(50 - _beganPoint.x, 50 - _beganPoint.y); // 计算实际中心点的位置 CGPoint center = CGPointMake(point.x + point2.x, point.y + point2.y); self.center = center; &#125;// 结束- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event&#123; &#125; 2、自定义按钮点击方法（继承UIView）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#import &quot;MyButton.h&quot;@interface MyButton()&#123; id _target; SEL _selector; NSTimeInterval _time; //点击开始的时间&#125;@end@implementation MyButton- (instancetype)initWithFrame:(CGRect)frame target:(id)target selector:(SEL)selector&#123; self = [super initWithFrame:frame]; if (self) &#123; _target = target; _selector = selector; &#125; return self;&#125;// 按钮的点击- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; // 调用SEL方法 if ([_target respondsToSelector:_selector]) &#123; [_target performSelector:_selector]; &#125; // 获取点击开始的时间 NSDate *date = [NSDate date]; _time = [date timeIntervalSince1970]; &#125;- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event&#123; // 获取触摸对象 UITouch *touch = [touches anyObject]; // 获取触摸点 CGPoint point = [touch locationInView:self]; // 点击结束之后 再次读取时间，比较两个时间差 NSDate *date = [NSDate date]; NSTimeInterval endedTime = [date timeIntervalSince1970]; // 结束时间 － 开始时间 if (endedTime - _time &gt; 3) &#123; NSLog(@&quot;长按&quot;); &#125; else &#123; NSLog(@&quot;普通点击&quot;); &#125; // 判断某个点 是否在视图中 BOOL isInside = [self pointInside:point withEvent:nil]; if (isInside) &#123; NSLog(@&quot;在按钮内部放开&quot;); &#125; else &#123; NSLog(@&quot;在按钮外部放开&quot;); &#125; &#125;@end 然后直接创建按钮,并实现按钮方法就行 1234MyButton *button = [[MyButton alloc] initWithFrame:CGRectMake(30, 30, 50, 50) target:self selector:@selector(buttonAction)];button.backgroundColor = [UIColor orangeColor];[self.view addSubview:button]; 事件的分发 基本上有下面两个方法： - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event - (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event ​ 处理原理如下： 当用户点击屏幕时，会产生一个触摸事件，系统会将该事件加入到一个由UIApplication管理的事件队列中 UIApplication会从事件队列中取出最前面的事件进行分发以便处理，通常，先发送事件给应用程序的主窗口(UIWindow) 主窗口会调用hitTest:withEvent:方法在视图(UIView)层次结构中找到一个最合适的UIView来处理触摸事件 (hitTest:withEvent:其实是UIView的一个方法，UIWindow继承自UIView，因此主窗口UIWindow也是属于视图的一种) hitTest:withEvent:方法大致处理流程是这样的： 首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内： 若pointInside:withEvent:方法返回NO，说明触摸点不在当前视图内，则当前视图的hitTest:withEvent:返回nil 若pointInside:withEvent:方法返回YES，说明触摸点在当前视图内，则遍历当前视图的所有子视图(subviews)，调用子视图的hitTest:withEvent:方法重复前面的步骤，子视图的遍历顺序是从top到bottom，即从subviews数组的末尾向前遍历，直到有子视图的hitTest:withEvent:方法返回非空对象或者全部子视图遍历完毕： 若第一次有子视图的hitTest:withEvent:方法返回非空对象,则当前视图的hitTest:withEvent:方法就返回此对象，处理结束 若所有子视图的hitTest:withEvent:方法都返回nil，则当前视图的hitTest:withEvent:方法返回当前视图自身(self) 最终，这个触摸事件交给主窗口的hitTest:withEvent:方法返回的视图对象去处理。 拿到这个UIView后，就调用该UIView的touches系列方法。 ​ 消息处理过程，在找到的那个视图里处理，处理完后根据需要，利用响应链nextResponder可将消息往下一个响应者传递。 UIAppliactionDelegate &lt;- UIWindow &lt;- UIViewController &lt;- UIView &lt;- UIView 【关键】：要理解的有三点：1、iOS判断哪个界面能接受消息是从View层级结构的父View向子View传递，即树状结构的根节点向叶子节点递归传递。2、hitTest和pointInside成对，且hitTest会调用pointInside。3、iOS的消息处理是，当消息被人处理后默认不再向父层传递 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * 分发一个触摸事件 * * @param point 触摸的位置 * @param event 触摸的事件 * * @return 响应事件的视图 */- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; // 判断点在不在视图上面 // 判断触摸在不在子视图上 // 1. 获取当前视图的所有子视图 NSArray *subViews = self.subviews; for (int i = (int)subViews.count - 1; i &gt;=0; i--) &#123; // 按照从后到前的顺序 取出一个子视图 UIView *view = subViews[i]; // 如果视图没有开启用户事件接收 if (view.userInteractionEnabled == NO) &#123; // 跳出本次循环，继续后面的循环 continue; &#125; // 2. 判断点击是否在该视图内 // 将一个点的坐标 转化为另一个视图上坐标系中的点 CGPoint newPoint = [self convertPoint:point toView:view]; // 判断 BOOL isInside = [view pointInside:newPoint withEvent:nil]; if (isInside) &#123; // 如果点在视图上，则由此视图来响应这次触摸事件 UIView *view2 = [view hitTest:newPoint withEvent:event]; return view2; &#125; &#125; // 1. 父视图接收到触摸事件 // 2. 从上到下判断触摸的点 是否在每一个子视图上 // 2.1 在某个子视图上,则由这个子视图来响应本次触摸事件 // 2.2 不在任何一个子视图上,则由父视图本身响应触摸事件 return self;&#125; 12345678910111213141516// 事件的分发- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; // 判断 子视图是否接受点击事件 UIView *view = [super hitTest:point withEvent:event]; // 判断触摸的范围 是否在100-200之间 if (point.y &gt;= 0 &amp;&amp; point.y &lt;= 100 &amp;&amp; view == nil) &#123; // 由滑动视图 来响应事件 view = self; &#125; // 由上一级 决定响应者 return view;&#125; 响应者链 12345UIResponder *responder = self.nextResponder; while (responder != nil &amp;&amp; ![responder isKindOfClass:[UIViewController class]]) &#123; responder = responder.nextResponder; &#125; return (UIViewController *)responder; 手势 手势分为很多种：单击、双击、轻扫、平移、长按、旋转、捏合等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128- (void)viewDidLoad &#123; [super viewDidLoad]; //---------------------tap 点击--------------------- // 单击 UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapAction:)]; // 短时间内点击的次数 tap.numberOfTapsRequired = 1; // 触摸的手指数量 tap.numberOfTouchesRequired = 1; [self.view addGestureRecognizer:tap]; // 双击 UITapGestureRecognizer *tap2 = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap2Action:)]; tap2.numberOfTapsRequired = 2; [self.view addGestureRecognizer:tap2]; // 区别单击双击手势 [tap requireGestureRecognizerToFail:tap2]; //---------------------swipe 轻扫--------------------- UISwipeGestureRecognizer *swipe = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipeAction:)]; // 设定手指滑动的方向 swipe.direction = UISwipeGestureRecognizerDirectionRight; [self.view addGestureRecognizer:swipe]; //---------------------pan 平移--------------------- UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panAction:)]; // 当视图添加了平移手势的时候，轻扫手势就失效了 [self.view addGestureRecognizer:pan]; //---------------------longPress 长按--------------------- UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressAction:)]; // 长按的最短时间 longPress.minimumPressDuration = 2; // 手指移动的最大距离 longPress.allowableMovement = 10; [self.view addGestureRecognizer:longPress]; //---------------------rotation 旋转--------------------- UIRotationGestureRecognizer *rotation = [[UIRotationGestureRecognizer alloc] initWithTarget:self action:@selector(rotationAction:)]; [self.view addGestureRecognizer:rotation]; //---------------------pinch 捏合--------------------- UIPinchGestureRecognizer *pinch = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(pinchActiuon:)]; [self.view addGestureRecognizer:pinch]; &#125;#pragma mark - 点击- (void)tapAction:(UITapGestureRecognizer *)tap&#123; NSLog(@&quot;单击&quot;);&#125;- (void)tap2Action:(UITapGestureRecognizer *)tap&#123; NSLog(@&quot;双击&quot;);&#125;#pragma maek - 轻扫- (void)swipeAction:(UISwipeGestureRecognizer *)swipe&#123; NSLog(@&quot;向右轻扫一次&quot;);&#125;#pragma mark - 平移- (void)panAction:(UIPanGestureRecognizer *)pan&#123; NSLog(@&quot;平移&quot;); // 平移的位置改变 终点坐标 － 起点坐标 CGPoint translation = [pan translationInView:self.view]; // NSLog(@&quot;%f,%f&quot;, translation.x, translation.y); // 平移时。位置变换的速度值 CGPoint velocity = [pan velocityInView:self.view]; //_imageView.center = translation; NSLog(@&quot;%f,%f&quot;, velocity.x, velocity.y); &#125;#pragma mark - 长按// 长按触发时调用第一次，手指离开屏幕时再次调用- (void)longPressAction:(UILongPressGestureRecognizer *)longPress&#123; // 通过 state 来判断当前手势是处于那种状态下 if (longPress.state == UIGestureRecognizerStateBegan) &#123; NSLog(@&quot;长按开始&quot;); &#125; else if (longPress.state == UIGestureRecognizerStateEnded) &#123; NSLog(@&quot;长按结束&quot;); &#125; &#125;#pragma mark - 旋转- (void)rotationAction:(UIRotationGestureRecognizer *)rotation&#123; NSLog(@&quot;旋转 角度:%f, 速度:%f&quot;, rotation.rotation, rotation.velocity); CGAffineTransform transform = CGAffineTransformMakeRotation(rotation.rotation); _imageView.transform = transform;&#125;#pragma mark - 捏合- (void)pinchActiuon:(UIPinchGestureRecognizer *)pinch&#123; NSLog(@&quot;捏合 倍数 :%f&quot;, pinch.scale); CGAffineTransform transform = CGAffineTransformMakeScale(pinch.scale, pinch.scale); _imageView.transform = transform;&#125;@end ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[单元格UITableViewCell的基本使用]]></title>
      <url>%2F2017%2F01%2F11%2F%E5%8D%95%E5%85%83%E6%A0%BCUITableViewCell%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[在单元格的使用中，最重要的就是单元格重用机制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//创建单元格 ,此方法,当滑动表视图时就会调用/* 懒加载 :如果需要需要显示100单元格,则系统不会一次性把所有的单元格创建出来 单元格重用: N+1机制: 如果屏幕上能显示N个单元格那么最多也就创建N+1个单元格,就可以满足需求 */- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; //标识符用于标记单元格 static NSString *identy = @&quot;cell&quot;; //从复用池中取单元格 UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identy]; //如果复用池中没有单元格 if (cell == nil) &#123; index++; //创建单元格 cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:identy]; //________________单元格的常用属性______________ //1. 单元格选中的样式 默认为UITableViewCellSelectionStyleBlue // UITableViewCellSelectionStyleNone:取消选中效果// cell.selectionStyle = UITableViewCellSelectionStyleNone; //2.辅助视图 cell.accessoryType = UITableViewCellAccessoryCheckmark; //3.自定义辅助视图 UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 30, 30)]; view.backgroundColor = [UIColor redColor]; cell.accessoryView = view; //4.背景视图 UIImageView *imgView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;tableCell_common.png&quot;]]; cell.backgroundView = imgView; //当单元格被点击,单元格上的子视图的背景会变为透明 NSLog(@&quot;%ld&quot;,index); //index是几,就说明创建了几个单元格 //在单元格上添加按钮(创建单元格的同时创建子视图) UIButton *btn = [UIButton buttonWithType:UIButtonTypeContactAdd]; btn.frame = CGRectMake(50, 0, 60, 30); [cell addSubview:btn]; NSLog(@&quot;%@&quot;,cell.subviews); &#125; //填充数据(更新数据) cell.textLabel.text = [NSString stringWithFormat:@&quot;%ld&quot;,indexPath.row]; /* 不要在此处添加子视图,此方法会调用多次,会有性能问题 //以字符作为打断方式 cell.lineBreakMode = NSLineBreakByCharWrapping; //设置自动换行 cell.textLabel.numberOfLines = 0; //在单元格上添加按钮 UIButton *btn = [UIButton buttonWithType:UIButtonTypeContactAdd]; btn.frame = CGRectMake(50, 0, 60, 30); [cell addSubview:btn]; NSLog(@&quot;%@&quot;,cell.subviews); */ return cell;&#125; 系统内置的单元格 123456789101112131415161718192021222324252627282930313233- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; static NSString *identy = @&quot;cell&quot;; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identy]; if (cell == nil) &#123; //系统内置单元格的类型 ,系统提供的单元格上的子视图,无法定制,很少使用 //1. UITableViewCellStyleDefault //2. UITableViewCellStyleValue1 //3. UITableViewCellStyleValue2 //4. UITableViewCellStyleSubtitle cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleValue2 reuseIdentifier:identy]; //设置标题 cell.textLabel.text = @&quot;标题&quot;; //设置图片 cell.imageView.image = [UIImage imageNamed:@&quot;1.png&quot;]; cell.detailTextLabel.text = @&quot;子标题&quot;; //无法更改frame// cell.imageView.frame = CGRectMake(50, 0, 50, 50); &#125; return cell;&#125;//单元格高度- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; return 80;&#125; 自定义一个cell 一种方法就是在代理方法中创建控件，然后添加到cell.contentView 另一种方法就是自己写一个UITableViewCell的子类 纯代码创建 MyCell.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061- (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier&#123; self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]; if (self) &#123; //创建子视图 //图片视图 UIImageView *imageView =[[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;p1997952346.jpg&quot;]]; imageView.frame = CGRectMake(10, 10, 80, 100); [self.contentView addSubview:imageView]; //标题label UILabel *titlelable = [[UILabel alloc] initWithFrame:CGRectMake(CGRectGetMaxX(imageView.frame) + 10, 10, 80, 30)]; titlelable.tag = 1; //在此处填充数据会有问题,一般不会在此处添加数据 titlelable.text = @&quot;卑鄙的我&quot;; titlelable.font = [UIFont boldSystemFontOfSize:18]; titlelable.textColor = [UIColor orangeColor]; [self.contentView addSubview:titlelable]; //评分label UILabel *ratingLable = [[UILabel alloc] initWithFrame:CGRectMake(titlelable.frame.origin.x + 5, CGRectGetMaxY(titlelable.frame), 80, 30)]; ratingLable.text = @&quot;9.1&quot;; ratingLable.font = [UIFont systemFontOfSize:13]; ratingLable.textColor = [UIColor purpleColor]; [self.contentView addSubview:ratingLable]; //年份label UILabel *yearLable = [[UILabel alloc] initWithFrame:CGRectMake(CGRectGetMaxX(imageView.frame) + 10, CGRectGetMaxY(ratingLable.frame), 80, 30)]; yearLable.textColor = [UIColor whiteColor]; yearLable.text = @&quot;年份:2013&quot;; yearLable.font = [UIFont boldSystemFontOfSize:14]; [self.contentView addSubview:yearLable]; &#125; return self;&#125;/* 1.填充数据 2.布局子视图 layoutSubviews :调用的时机 1.如果视图上被添加了子视图,那么此视图的layoutSubviews方法会被调用 2.如果视图的frame发生了变化,那么次视图的layoutSubviews会被调用 */- (void)layoutSubviews&#123; [super layoutSubviews]; //填充数据&#125; xib创建 1234567891011121314151617181920212223- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; static NSString *identy = @&quot;cell&quot;; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:identy]; if (cell == nil) &#123; //加载xib NSArray *array = [[NSBundle mainBundle] loadNibNamed:@&quot;MyCell&quot; owner:nil options:nil]; cell = [array lastObject]; &#125; return cell;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; return 100;&#125; 表视图的编辑模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#pragma mark UITableViewDeleagte//实现此协议方法,左划会出现删除按钮//当删除或插入按钮被点击时会调用此方法- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath &#123; //如果插入按钮被点击 if (editingStyle == UITableViewCellEditingStyleInsert) &#123; NSLog(@&quot;插入一个单元格&quot;); [tableView beginUpdates]; //1. 添加数据 [array insertObject:@&quot;测试&quot; atIndex:indexPath.row];// [tableView reloadData]; //2 .插入一个单元格 [tableView insertRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationRight]; [tableView endUpdates]; //如果删除按钮被点击 &#125;else if (editingStyle == UITableViewCellEditingStyleDelete)&#123; [tableView beginUpdates]; //1. 删除一个单元格 [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationRight]; //2. 删除数组中的数据 [array removeObjectAtIndex:indexPath.row]; [tableView endUpdates]; //刷新表视图// [tableView reloadData]; &#125;&#125;//控制表视图进入到编辑模式后,显示的样式,如果不实现此方法,所有的单元格均显示删除按钮- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (indexPath.row == 0) &#123; //第一个单元格显示插入按钮 return UITableViewCellEditingStyleInsert; &#125; //其它的单元格显示删除 return UITableViewCellEditingStyleDelete;&#125;//实现此方法后,当表视图进入到编辑模式,单元格的右侧会出现移动按钮- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath&#123; //更新数据 [array exchangeObjectAtIndex:sourceIndexPath.row withObjectAtIndex:destinationIndexPath.row];&#125;- (IBAction)editAction:(id)sender &#123; //进入到编辑模式// [_tableView setEditing:YES]; //单元格是否可以多选,开启多选后,删除与添加按钮会消失// _tableView.allowsMultipleSelectionDuringEditing = YES; [_tableView setEditing:YES animated:YES]; &#125;- (IBAction)doneAction:(id)sender &#123; //退出编辑模式 [_tableView setEditing:NO animated:YES];&#125; ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[表视图UITableView的基本使用]]></title>
      <url>%2F2017%2F01%2F11%2F%E8%A1%A8%E8%A7%86%E5%9B%BEUITableView%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[UITableView的基本创建 其中最重要的就是实现它的两个必须实现的代理方法：UITableViewDataSource协议 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778- (void)viewDidLoad &#123;[super viewDidLoad];//创建表视图UITableView *tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 0, 320, 568) style:UITableViewStylePlain];//设置代理(数据源)tableView.dataSource = self;[self.view addSubview:tableView];&#125;#pragma mark UITableViewDatasource//返回单元格的个数的协议方法- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;return 20;&#125;//创建单元格的协议方法- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;// indexPath.section 组的索引// indexPath.row 行的索引 0 , 1 ,2,4 .......9999UITableViewCell *cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:nil];//设置单元格上显示的文本cell.textLabel.text = [NSString stringWithFormat:@&quot;section: %ld row :%ld&quot;,indexPath.section,indexPath.row];return cell;&#125;-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; //单元格高度自适应 NSString *text = _info[indexPath.row]; //根据文本内容计算高度,使用属性文本计算高度 //iOS7之后使用boundingRectWithSize计算文本所占的矩形 /* 参数： CGSizeMake(320, 0)：指定文本的宽度，自动计算出高度 options:绘制文本需要的参数 attributes:文字的属性（字体大小） context:上下文，这里不需要 */ CGRect frame = [text boundingRectWithSize:CGSizeMake(320, 0) options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:16]&#125; context:nil]; NSLog(@&quot;size = %f&quot;,frame.size.height); return frame.size.height + 10;&#125;//cell的点击方法-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; [tableView deselectRowAtIndexPath:indexPath animated:YES];//设置点击的风格// NSLog(@&quot;选中的单元格的索引section = %ld,row = %ld&quot;,indexPath.section,indexPath.row); //获取点击的单元格对象 UITableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath]; NSLog(@&quot;%@&quot;,cell.textLabel.text); [tableView scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionMiddle animated:YES]; &#125; UITableView的风格样式 UITableViewStylePlain和UITableViewStyleGrouped。这两者操作起来其实并没有本质区别，只是后者按分组样式显示前者按照普通样式显示而已。 ​ UITableViewStyleGrouped:分组风格 UITableViewStylePlain:平铺风格 上面介绍的UITableViewStylePlain，下面我们使用UITableViewStyleGrouped来试一下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view.UITableView *tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 20, 320, 548) style:UITableViewStyleGrouped];[self.view addSubview:tableView];//设置数据源tableView.dataSource = self;//设置代理tableView.delegate = self;//读取plist文件NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;font&quot; ofType:@&quot;plist&quot;];array = [NSArray arrayWithContentsOfFile:filePath];&#125;/*[[font1, font2 ,fon3 .....]; //显示在第一组[font1, .....]; // 第二组上面[fon1..........];........]*/#pragma mark UITableViewDataSource//返回组的个数,默认为1组- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123;return array.count; // 13组&#125;//此方法会调用13次,因为分了13组//返回每组中单元格的个数 section:每一组的索引- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; // 0,1,......12NSArray *fontNames = [array objectAtIndex:section];return fontNames.count;&#125;//创建单元格- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;// indexPath : section属性表示组 row属性表示行 整体表示单元格的位置// 第一组的单元格 s:0 r:0 0,1 0,2// 第二组的单元格 s:1 r:0 1,1 1,2........UITableViewCell *cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:nil];//取得组的索引NSInteger section = indexPath.section;//取得小数组NSArray *fontNames = [array objectAtIndex:section];//取得组中行的索引NSInteger row = indexPath.row;//取得小数组中的字符串NSString *fontName = [fontNames objectAtIndex:row];//设置文本cell.textLabel.text = fontName;return cell;&#125;//设置组的头视图的标题- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section &#123;NSString *title = [NSString stringWithFormat:@&quot;第%ld组&quot;,section];return title;&#125; 效果如下： 自定义头部视图 直接像上面设置头视图的文字，这种代理方法局限性很大，无法设置,字的颜色,字的大小。 下面我们用另一个代理方法自定义头部视图 12345678910111213141516171819//返回组的头部视图的协议方法- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section &#123;//高度无法控制,需要用协议方法控制UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, 0)];view.backgroundColor = [UIColor redColor];UILabel *lable = [[UILabel alloc] initWithFrame:CGRectMake(60, 10, 200, 30)];lable.backgroundColor = [UIColor greenColor];lable.text = [NSString stringWithFormat:@&quot;第%ld组&quot;,section];[view addSubview:lable];return view;&#125;//返回组的头视图的高度- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section&#123;return 100;&#125; UITableView的常用方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 //自定义表视图的头视图 UIImageView *headerView = [[UIImageView alloc ] initWithFrame:CGRectMake(0, 0, 0, 100)]; headerView.image = [UIImage imageNamed:@&quot;scene1.jpg&quot;]; //给表视图的头视图属性 赋值 table.tableHeaderView = headerView; //常用属性 //单元格分割线的颜色 table.separatorColor = [UIColor redColor]; // table.separatorStyle = UITableViewCellSeparatorStyleNone; //单元格的高度:统一修改所有单元格的高度，一般不建议使用 //使用相应的代理来设置高度// table.rowHeight = 100; //设置组的头视图高度// table.sectionHeaderHeight = 100;// table.sectionFooterHeight = 100;// //设置背景视图 UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)]; view.backgroundColor = [UIColor redColor]; table.backgroundView = view; //自定义表视图的尾视图 UIImageView *footerView = [[UIImageView alloc ] initWithFrame:CGRectMake(0, 0, 0, 100)]; footerView.image = [UIImage imageNamed:@&quot;scene1.jpg&quot;]; //给表视图的头视图属性 赋值 table.tableFooterView = footerView; [self.view addSubview:table]; //返回一个单元格实例 NSIndexPath *indexPath = [NSIndexPath indexPathForRow:1 inSection:8]; UITableViewCell *cell =[table cellForRowAtIndexPath:indexPath]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; //reloadData：刷新整个表视图的数据 [table reloadData]; //滑动到指定的单元格 [table scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionMiddle animated:YES]; &#125;); ​ 下面我们做个小案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798- (void)viewDidLoad &#123;[super viewDidLoad];UITableView *tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 20, 320, 548) style:UITableViewStyleGrouped];//数据源tableView.dataSource = self;[self.view addSubview:tableView];//读取省份的plist文件NSString *provinPath = [[NSBundle mainBundle] pathForResource:@&quot;provinces.plist&quot; ofType:nil];procinces = [NSArray arrayWithContentsOfFile:provinPath];//读取城市列表文件NSString *cityPath = [[NSBundle mainBundle] pathForResource:@&quot;cities.plist&quot; ofType:nil];cityDic = [NSDictionary dictionaryWithContentsOfFile:cityPath];//设置索引的颜色tableView.sectionIndexBackgroundColor = [UIColor redColor];tableView.sectionIndexColor = [UIColor orangeColor];tableView.sectionIndexTrackingBackgroundColor = [UIColor greenColor];// tableView&#125;/*&#123;安徽: [ ......]湖南: [长沙, 娄底 ........]广东: [];&#125;*///组的个数- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123;return procinces.count;&#125; // Default is 1 if not implemented//每一组中的单元格个数- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;//取得省份的名字NSString *procinceName = [procinces objectAtIndex:section];//取出城市数组NSArray *cites = [cityDic objectForKey:procinceName];return cites.count;return 0;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;UITableViewCell *cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:nil];//组的索引NSInteger section = indexPath.section;//行的索引NSInteger row = indexPath.row;//省份的名字NSString *provinceName = [procinces objectAtIndex:section];//取出城市数组NSArray *cites = [cityDic objectForKey:provinceName];NSString *cityName = [cites objectAtIndex:row];cell.textLabel.text = cityName;return cell;&#125;//组的头视图上的标题,此方法有多少组就会调用多少次- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section &#123;NSString *str = procinces[section];return str;&#125;//返回索引- (NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView&#123;// return @[@&quot;A&quot;,@&quot;B&quot;,@&quot;C&quot;];return procinces;&#125; 上面案例的数据格式如下： provinces.plist cities.plist 效果图如下： UITableView的常用属性和方法 1234567891011121314151617181920212223242526//____________tabelView常用属性______________UIView *headerView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, 200)];headerView.backgroundColor = [UIColor redColor];//设置tableView的头视图_tableView.tableHeaderView = headerView;UIView *footView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, 100)];footView.backgroundColor = [UIColor greenColor];//设置tableView的尾部视图_tableView.tableFooterView = footView;//分割线颜色,默认是灰色_tableView.separatorColor = [UIColor blueColor];//分割线的样式 UITableViewCellSeparatorStyleNone取消分割线// _tableView.separatorStyle = UITableViewCellSeparatorStyleNone;//设置行高 所有的单元格高度都是100,通过协议方法也可以设置_tableView.rowHeight = 100;//设置数据源_tableView.dataSource = self;//设置代理_tableView.delegate = self; 1234567891011121314#pragma mark UITableViewDelegate//返回单元格的行高,此方法会调用多次,为每一个单元格确定行高- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;if (indexPath.row == 0) &#123; //第一个单元格return 100;&#125;else&#123;return 50;&#125;&#125; 123456789101112131415161718192021222324252627//_________________表视图常用方法______________/*//删除第一个元素[fonts removeObjectAtIndex:0];//1. 刷新表视图,让显示的内容与数据同步[_tableView reloadData];*///2. 滚动到指定的单元格// UITableViewScrollPositionTop 顶部// UITableViewScrollPositionMiddle 中间//UITableViewScrollPositionBottom 底部/*NSIndexPath *indexPath = [NSIndexPath indexPathForRow:10 inSection:0];[_tableView scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionBottom animated:YES];*///3. 通过indexPath获取到对应的单元格NSIndexPath *indexPath = [NSIndexPath indexPathForRow:10 inSection:0];UITableViewCell *cell = [_tableView cellForRowAtIndexPath:indexPath];//4. 获取到当前显示的单元格NSArray *cells = [_tableView visibleCells]; 到现在，我们继续做个小案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129- (void)viewDidLoad &#123;[super viewDidLoad];_tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 20, 320, 548) style:UITableViewStylePlain];_tableView.dataSource = self;_tableView.delegate = self;[self.view addSubview:_tableView];//读取plist文件NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;friends.plist&quot; ofType:nil];array = [NSArray arrayWithContentsOfFile:filePath];&#125;/*[&#123;groupe : @&quot;我的好友&quot;friends : [好友1,好友1,好友1,好友1,好友1,];&#125;,&#123;groupe : @&quot;大学同学&quot;friends : [好友1,好友1,好友1,好友1,好友1,];&#125;,]*///租的数量- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123;return array.count;&#125;//返回每一组中单元格的个数- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;NSDictionary *dic = array[section];//取出好友数组NSArray *friends = dic[@&quot;friends&quot;];BOOL f = flag[section]; //NO :展开if (f) &#123; //收起return 0;&#125;else &#123; //展开return friends.count;&#125;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;UITableViewCell *cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:nil];NSDictionary *dic = array[indexPath.section];//取出好友数组NSArray *friends = dic[@&quot;friends&quot;];//取出好友姓名NSString *name = friends[indexPath.row];cell.textLabel.text = name;return cell;&#125;//组的头视图上的标题- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section&#123;UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];[btn setBackgroundImage:[UIImage imageNamed:@&quot;tableCell_common.png&quot;] forState:UIControlStateNormal];[btn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];btn.tag = section;//添加点击事件[btn addTarget:self action:@selector(clickAction:) forControlEvents:UIControlEventTouchUpInside];//取出好友字典NSDictionary *dic = array[section];//取出分组标题NSString *title = dic[@&quot;group&quot;];[btn setTitle:title forState:UIControlStateNormal];return btn;&#125;//设置租的头视图的高度- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section&#123;return 43;&#125;- (void)clickAction:(UIButton *)btn&#123;NSInteger section = btn.tag; // 0//改变数组中元素的状态flag[section] = !flag[section];//刷新表视图// [_tableView reloadData];//刷新多个组//用此种方式创建的set对象只能表示一组NSIndexSet *set = [NSIndexSet indexSetWithIndex:section];//创建的set对象表示多个组// [NSIndexSet indexSetWithIndexesInRange:&lt;#(NSRange)#&gt;];//刷新多个单元格// [_tableView reloadRowsAtIndexPaths:&lt;#(NSArray *)#&gt; withRowAnimation:&lt;#(UITableViewRowAnimation)#&gt;];[_tableView reloadSections:set withRowAnimation:UITableViewRowAnimationFade];&#125; 数据格式如下： 效果如下： 最后补充一下表视图的编辑模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#import &quot;ViewController.h&quot;@interface ViewController ()&#123; BOOL _isEdit; UITableView *_tableView; NSMutableArray *_data; &#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; _data = [NSMutableArray arrayWithArray:@[@&quot;班长1&quot;,@&quot;班长1&quot;,@&quot;班长1&quot;,@&quot;班长1&quot;,@&quot;班长2&quot;,@&quot;班长1&quot;,@&quot;班长10&quot;,@&quot;班长1&quot;,@&quot;班长1&quot;,@&quot;班长1&quot;,@&quot;班长1&quot;,@&quot;班长1&quot;,@&quot;班长11&quot;,@&quot;班长1&quot;,@&quot;班长1&quot;,@&quot;班长1&quot;,]]; _tableView = [[UITableView alloc] initWithFrame:self.view.bounds style:UITableViewStylePlain]; _tableView.delegate = self; _tableView.dataSource = self; [self.view addSubview:_tableView]; &#125;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; return _data.count;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; static NSString * identifer = @&quot;cell&quot;; UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:identifer]; if (cell == nil) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:identifer]; &#125; cell.textLabel.text = _data[indexPath.row]; return cell;&#125;- (IBAction)edit:(UIBarButtonItem *)sender &#123; //让表视图进入编辑模式 _isEdit = !_isEdit; _tableView.allowsMultipleSelectionDuringEditing = YES; [_tableView setEditing:_isEdit animated:YES]; &#125;- (IBAction)multip:(UIBarButtonItem *)sender &#123; // 获取选择的cell 的 indexPath NSArray *indexPaths = [_tableView indexPathsForSelectedRows]; NSMutableIndexSet *fontSet = [[NSMutableIndexSet alloc] init]; for (int i = 0; i &lt; indexPaths.count; i++) &#123; NSIndexPath *indexPath = indexPaths[i]; [fontSet addIndex:indexPath.row]; &#125; // 删除数组中位置所对应集合的数据 [_data removeObjectsAtIndexes:fontSet]; [_tableView deleteRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationLeft]; &#125;-(UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath&#123; //返回每一个单元格的编辑模式 if (indexPath.row == 2) &#123; return UITableViewCellEditingStyleInsert; &#125; return UITableViewCellEditingStyleDelete;&#125;//删除或者添加单元格-(void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (editingStyle == UITableViewCellEditingStyleDelete) &#123; //删除 //1.删除数据 [_data removeObjectAtIndex:indexPath.row]; //2.删除单元格 [tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationRight]; &#125;else if (editingStyle == UITableViewCellEditingStyleInsert) &#123; //添加 //1.添加数据 [_data insertObject:@&quot;我是新来的&quot; atIndex:indexPath.row + 1]; //2.添加单元格 NSIndexPath *indexPathNew = [NSIndexPath indexPathForRow:indexPath.row + 1 inSection:indexPath.section]; [tableView insertRowsAtIndexPaths:[NSArray arrayWithObject:indexPathNew] withRowAnimation:UITableViewRowAnimationLeft]; &#125; &#125;-(void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath&#123; //交换数据 [_data exchangeObjectAtIndex:sourceIndexPath.row withObjectAtIndex:destinationIndexPath.row];&#125; ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[滑动视图UISrollView]]></title>
      <url>%2F2017%2F01%2F10%2F%E6%BB%91%E5%8A%A8%E8%A7%86%E5%9B%BEUISrollView%2F</url>
      <content type="text"><![CDATA[UIScrollView的基本创建和属性的用法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263- (void)viewDidLoad&#123; [super viewDidLoad]; //创建滑动视图 scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, 320, 300)]; scrollView.backgroundColor = [UIColor grayColor]; [self.view addSubview:scrollView]; //1. 设置内容尺寸,只有内容尺寸大于了视图尺寸才能滑动 scrollView.contentSize = CGSizeMake(320 * 3, 600); //创建子视图 UILabel* label1 = [[UILabel alloc] initWithFrame:CGRectMake(60, 60, 200, 50)]; label1.text = @&quot;1&quot;; label1.backgroundColor = [UIColor redColor]; [scrollView addSubview:label1]; UILabel* label2 = [[UILabel alloc] initWithFrame:CGRectMake(320 + 60, 60, 200, 50)]; label2.text = @&quot;2&quot;; label2.backgroundColor = [UIColor redColor]; [scrollView addSubview:label2]; UILabel* label3 = [[UILabel alloc] initWithFrame:CGRectMake(320 * 2 + 60, 60, 200, 50)]; label3.text = @&quot;3&quot;; label3.backgroundColor = [UIColor redColor]; [scrollView addSubview:label3]; //2.分页效果,开启分页效果,一页的宽度为scrollView的宽度// scrollView.pagingEnabled = YES; //3.隐藏水平滚动条 showsVerticalScrollIndicator:垂直 showsHorizontalScrollIndicator : 水平// scrollView.showsHorizontalScrollIndicator = NO; //4. 滑动到视图的末尾时,是否有反弹效果// scrollView.bounces = NO; //5. 是否开启滑动// scrollView.scrollEnabled = NO; //6.上下滑动时,点击状态栏是否可以返回// scrollView.scrollsToTop = NO; //7.内容偏移 [self performSelector:@selector(action) withObject:nil afterDelay:2]; //8.减速时的速度 scrollView.decelerationRate = 0; //9.滑动时是否锁定为一个方向 scrollView.directionalLockEnabled = YES; //10.滚动条的样式 (默认为灰色,黑色,白色) scrollView.indicatorStyle = UIScrollViewIndicatorStyleWhite;&#125;- (void)action&#123; //设置内容的偏移 scrollView.contentOffset = CGPointMake(-200, 0);&#125; UIScrollViewDelegate 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#pragma mark UIScrollViewDelegate//滑动时调用,实时调用//- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;//////// NSLog(@&quot;x轴偏移的距离 %lf&quot;,scrollView.contentOffset.x);//// NSLog(@&quot;y轴偏移的距离 %lf&quot;,scrollView.contentOffset.y);////// CGFloat offsetX = scrollView.contentOffset.x;// //第几页// NSInteger index = offsetX / 320;// NSLog(@&quot;%ld&quot;,index);//////&#125;//手指将要开始拖动- (void)scrollViewWillBeginDragging:(UIScrollView*)scrollView&#123; NSLog(@&quot;手指将要开始拖动&quot;);&#125;//手指已经离开滑动视图- (void)scrollViewDidEndDragging:(UIScrollView*)scrollView willDecelerate:(BOOL)decelerate&#123; NSLog(@&quot;手指结束拖动,离开屏幕&quot;); //decelerate:手指离开屏幕时,是否为减速状态 if (decelerate) &#123; NSLog(@&quot;视图为减速状态&quot;); &#125; else &#123; NSLog(@&quot;视图为静止状态&quot;); &#125;&#125;//视图将要开始减速- (void)scrollViewWillBeginDecelerating:(UIScrollView*)scrollView&#123; NSLog(@&quot;视图将要开始减速&quot;);&#125;//视图结束减速,视图滑动停止- (void)scrollViewDidEndDecelerating:(UIScrollView*)scrollView&#123; //一般在此处判断页数 NSLog(@&quot;视图结束减速,滑动停止&quot;);&#125;//手指将要离开屏幕时调用- (void)scrollViewWillEndDragging:(UIScrollView*)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint*)targetContentOffset NS_AVAILABLE_IOS(5_0)&#123; //velocity 手指离开视图时,滑动视图的速度 //targetContentOffset 滑动最终会滑倒哪个位置 // // CGFloat x = targetContentOffset -&gt; x; // NSLog(@&quot;x轴最终停止的位置为%f&quot;,x); targetContentOffset-&gt;x = 320;&#125; 滑动视图的捏合手势 首先先设置代理，然后设置设置放大的倍数 scroll.maximumZoomScale = 3; 再设置最小的缩放倍数 scroll.minimumZoomScale = .5; scrollView.zoomBouncing = YES;//缩放反弹效果 最后实现代理方法 123456789101112131415161718192021222324252627#pragma mark UIScrollViewDelegate//返回一个需要放大的视图- (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView &#123; UIView *view = [scrollView viewWithTag:10]; return view;&#125; // return a view that will be scaled. if delegate returns nil, nothing happens//滑动视图缩放时,会调用此方法,实时调用- (void)scrollViewDidZoom:(UIScrollView *)scrollView NS_AVAILABLE_IOS(3_2) &#123; //zoomScale当前的缩放倍数 NSLog(@&quot;%f&quot;,scrollView.zoomScale);&#125; //缩放时常用一些协议方法- (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(UIView *)view NS_AVAILABLE_IOS(3_2) &#123; NSLog(@&quot;开始放大&quot;); &#125;- (void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(UIView *)view atScale:(CGFloat)scale &#123; NSLog(@&quot;结束放大&quot;);&#125; 双击手势放大 123456789101112131415161718192021222324252627 UITapGestureRecognizer * tap2 = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap2:)]; //设置点击的次数 tap2.numberOfTapsRequired = 2; tap2.numberOfTouchesRequired = 1; //scrollView 添加双击手势 [scrollView addGestureRecognizer:tap2]; -(void)tap2:(UITapGestureRecognizer *)ges &#123; NSLog(@&quot;双击手势&quot;); //手势所在的视图 UIScrollView *view = (UIScrollView *)ges.view; [UIView animateWithDuration:.35 animations:^&#123; //实现scrollView的缩放 if (view.zoomScale == 1) &#123; //放大 view.zoomScale = 2; &#125;else&#123; view.zoomScale = 1; &#125; &#125;];&#125; ​ 结合UIPageControl的使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051- (void)viewDidLoad &#123; [super viewDidLoad]; scroll = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, 340, 568)]; scroll.backgroundColor = [UIColor grayColor]; [self.view addSubview:scroll]; NSArray *imageNames = @[@&quot;chenyixun.jpg&quot;,@&quot;joy.jpg&quot;,@&quot;yanzi.jpg&quot;,@&quot;wanglihong.jpg&quot;]; for (NSInteger i = 0; i &lt; imageNames.count; i++) &#123; UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(i * 340, 0, 320, 568)]; NSString *imageName = imageNames[i]; imageView.image = [UIImage imageNamed:imageName]; [scroll addSubview:imageView]; &#125; //设置内容大小 scroll.contentSize = CGSizeMake(4 * 340, 568); //设置代理 scroll.delegate = self; //开启分页效果 scroll.pagingEnabled = YES; //分页控件 pageContrl = [[UIPageControl alloc] initWithFrame:CGRectMake(60, 568 - 30, 200, 30)];// pageContrl.backgroundColor = [UIColor redColor]; [self.view addSubview:pageContrl]; //禁用分页控件 pageContrl.enabled = NO; pageContrl.numberOfPages = 4; //选中的颜色 pageContrl.currentPageIndicatorTintColor = [UIColor redColor]; pageContrl.pageIndicatorTintColor = [UIColor grayColor]; //绑定事件方法 [pageContrl addTarget:self action:@selector(pageAction:) forControlEvents:UIControlEventValueChanged];&#125;- (void)pageAction:(UIPageControl *)page&#123; NSInteger index = page.currentPage; CGFloat x = index * 340; scroll.contentOffset = CGPointMake(x, 0);&#125;#pragma mark UIScrollViewDelage- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123; //计算页数 NSInteger index = scrollView.contentOffset.x / 340; pageContrl.currentPage = index;&#125; ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UITabBarController的基本使用]]></title>
      <url>%2F2017%2F01%2F10%2FUITabBarController%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[首先介绍创建一个UITabBarController，并将其设置为根控制器的一般方法： 1234567891011121314151617181920212223242526272829303132333435//创建标签控制器 UITabBarController *tabBarCtrl = [[UITabBarController alloc] init]; tabBarCtrl.delegate = self; //创建子控制器 UIViewController *ctrl1 = [[UIViewController alloc] init]; ctrl1.title = @&quot;首页&quot;; ctrl1.view.backgroundColor = [UIColor redColor]; UIViewController *ctrl2 = [[UIViewController alloc] init]; ctrl2.title = @&quot;通讯录&quot;; ctrl2.view.backgroundColor = [UIColor greenColor]; UIViewController *ctrl3 = [[UIViewController alloc] init]; ctrl3.title = @&quot;设置&quot;; ctrl3.view.backgroundColor = [UIColor orangeColor]; //设置子控制器(以后无法改变) tabBarCtrl.viewControllers = @[ctrl1,ctrl2,ctrl3]; //将标签控制器设为窗口的根控制器 self.window.rootViewController = tabBarCtrl; //delegate//- (BOOL)tabBarController:(UITabBarController *)tabBarController shouldSelectViewController:(UIViewController *)viewController &#123;// return YES;//&#125;- (void)tabBarController:(UITabBarController *)tabBarController didSelectViewController:(UIViewController *)viewController &#123; NSLog(@&quot;%ld&quot;,[tabBarController.viewControllers indexOfObject:viewController]); &#125; tabarItem的创建 123456789101112131415161718//第一种方式 UITabBarItem *item1 = [[UITabBarItem alloc] initWithTabBarSystemItem:UITabBarSystemItemFeatured tag:1]; //取得一个子控制器,设置item UIViewController *ctrl1 = [viewCtrls objectAtIndex:0]; ctrl1.tabBarItem = item1; UITabBarItem *item2 = [[UITabBarItem alloc] initWithTabBarSystemItem:UITabBarSystemItemHistory tag:2]; //取得第二个子控制器,设置item UIViewController *ctrl2 = [viewCtrls objectAtIndex:1]; ctrl2.tabBarItem = item2; //第二种方式 UITabBarItem *item3 = [[UITabBarItem alloc] initWithTitle:@&quot;通讯录&quot; image:[UIImage imageNamed:@&quot;3.png&quot;] tag:3]; //提示文字 item3.badgeValue = @&quot;New&quot;; //取得第三个子控制器 UIViewController *ctrl3 = [viewCtrls objectAtIndex:2]; ctrl3.tabBarItem = item3; UITabar属性与方法 123456789101112131415161718//更改item选中的颜色 tabarCtrl.tabBar.tintColor = [UIColor redColor]; //设置选中的图片 tabarCtrl.tabBar.selectionIndicatorImage = [UIImage imageNamed:@&quot;选中.png&quot;]; [tabbar setSelectedImageTintColor:&lt;#(UIColor *)#&gt;]; //设置背景图片 UIImage *image = [UIImage imageNamed:@&quot;navbg.png&quot;]; image = [image stretchableImageWithLeftCapWidth:2 topCapHeight:0]; [tabbar setBackgroundImage:image];// tabarCtrl.tabBar.backgroundImage = [UIImage imageNamed:@&quot;navbg.png&quot;]; //设置背景颜色// tabarCtrl.tabBar.backgroundColor = [UIColor greenColor]; tabarCtrl.tabBar.barTintColor = [UIColor greenColor]; //item上的图标 item1.badgeValue = @&quot;new&quot;; 自定义Tabbar（这里自定义的继承UITabBarController的一个类，self为UITabBarController子类的对象） 1234567891011121314151617181920212223242526272829303132333435//1.隐藏系统tabbar self.tabBar.hidden = YES; //2.创建图片视图 UIImageView *tabar = [[UIImageView alloc] initWithFrame:CGRectMake(0, kSreenHeight - 49, kScreenWidth, 49)]; tabar.userInteractionEnabled = YES; tabar.image = [UIImage imageNamed:@&quot;navbg.png&quot;]; [self.view addSubview:tabar]; //创建选中视图 selectImageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 53, 45)]; selectImageView.image = [UIImage imageNamed:@&quot;选中.png&quot;]; [tabar addSubview:selectImageView]; //3.创建tabbar按钮 for (NSInteger i = 0; i &lt; 5; i++) &#123; NSString *imageName = [NSString stringWithFormat:@&quot;%ld.png&quot;,i + 1]; UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame = CGRectMake(i * kScreenWidth / 5, 0, kScreenWidth / 5, 49); [btn setImage:[UIImage imageNamed:imageName] forState:UIControlStateNormal]; [btn addTarget:self action:@selector(clickAction:) forControlEvents:UIControlEventTouchUpInside]; [tabar addSubview:btn]; btn.tag = i; if (i == 0) &#123; selectImageView.center = btn.center; &#125; &#125; 将UINavigationController变成UITabBarController的根视图控制器 123456789101112131415161718192021222324252627282930313233//个人中心 创建第三级控制器 ProfileViewController *proCtrl = [[ProfileViewController alloc] init]; //广场 SquareViewController *squeCtrl = [[SquareViewController alloc] init]; //搜索 SearchViewController *searchCtrl = [[SearchViewController alloc] init]; //微评 ComentViewController *comentCtrl = [[ComentViewController alloc] init]; //消息 MessageViewController *messageCtrl = [[MessageViewController alloc] init]; NSArray *viewCtrls = @[proCtrl,squeCtrl,searchCtrl,comentCtrl,messageCtrl]; //创建数组用于存放导航控制器 NSMutableArray *navCtrls = [NSMutableArray array]; //创建导航控制器 二级控制器 for (NSInteger i = 0; i &lt; viewCtrls.count; i++) &#123; //取到对应的子控制器 UIViewController *ctrl = viewCtrls[i]; //将第三级控制器交给导航控制器管理 UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:ctrl]; //将导航控制器加入到数组中 [navCtrls addObject:nav]; &#125; //将导航控制器(二级控制器)交给标签控制器管理 self.viewControllers = navCtrls; 当第一个视图有导航控制器的时候，当push到第二个视图的时候要隐藏tabbar，这个时候就需要实现导航控制器的代理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667- (void)_creatSubViewCtrls&#123; //个人中心 创建第三级控制器 ProfileViewController *proCtrl = [[ProfileViewController alloc] init]; //广场 SquareViewController *squeCtrl = [[SquareViewController alloc] init]; //搜索 SearchViewController *searchCtrl = [[SearchViewController alloc] init]; //微评 ComentViewController *comentCtrl = [[ComentViewController alloc] init]; //消息 MessageViewController *messageCtrl = [[MessageViewController alloc] init]; NSArray *viewCtrls = @[proCtrl,squeCtrl,searchCtrl,comentCtrl,messageCtrl]; //创建数组用于存放导航控制器 NSMutableArray *navCtrls = [NSMutableArray array]; //创建导航控制器 二级控制器 for (NSInteger i = 0; i &lt; viewCtrls.count; i++) &#123; //取到对应的子控制器 UIViewController *ctrl = viewCtrls[i]; //将第三级控制器交给导航控制器管理 UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:ctrl]; //设置代理监听导航控制器的切换 nav.delegate = self; //将导航控制器加入到数组中 [navCtrls addObject:nav]; &#125; //将导航控制器(二级控制器)交给标签控制器管理 self.viewControllers = navCtrls;&#125; //- (void)navigationController:(UINavigationController *)navigationController didShowViewController:(UIViewController *)viewController animated:(BOOL)animated&#123;pragma mark UINavigationControllerDelegate //导航控制器切换子控制器时,会调用此协议方法- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated&#123; NSLog(@&quot;%@将要显示&quot;,viewController); [UIView beginAnimations:nil context:nil]; [UIView setAnimationDuration:.2]; //隐藏标签栏 if (navigationController.viewControllers.count == 1)&#123; // 显示标签栏 // tabar.hidden = NO; CGRect frame = tabar.frame; frame.origin.x = 0; tabar.frame = frame; &#125; else if(navigationController.viewControllers.count &gt; 1)&#123;//隐藏标签 // tabar.hidden = YES; //将tabbar移动到屏幕的左侧 CGRect frame = tabar.frame; frame.origin.x = -kScreenWidth; tabar.frame = frame; &#125; [UIView commitAnimations]; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UINavigationController的常用属性和方法]]></title>
      <url>%2F2017%2F01%2F10%2FUINavigationController%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[UINavigationControllerDelegate 首先在当前的视图控制其中挂失自己的导航控制器的代理 self.navigationController.delegate = self; 然后实现代理方法 12345678910#pragma mark - navigationController delegate- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated&#123; NSLog(@&quot;视图将要显示:%@&quot;, viewController);&#125;- (void)navigationController:(UINavigationController *)navigationController didShowViewController:(UIViewController *)viewController animated:(BOOL)animated&#123; NSLog(@&quot;视图已经显示:%@&quot;, viewController);&#125; 导航控制器的常用属性 导航控制器中 最顶层的视图控制器 self.navigationController.topViewController 导航控制器中 当前显示的试图控制器 self.navigationController.visibleViewController 导航控制器中 所有的子控制器 self.navigationController.viewControllers 导航栏 self.navigationController.navigationBar 设置导航栏的渲染色 self.navigationController.navigationBar.tintColor = [UIColor redColor]; ​ 导航控制器的常用方法 push [self.navigationController pushViewController:second animated:YES]; pop - 弹出当前的视图控制器 显示前一个视图控制器 [self.navigationController popViewControllerAnimated:YES]; 弹出到指定视图控制器 123NSArray *array = self.navigationController.viewControllers;UIViewController *vc = array[0];[self.navigationController popToViewController:vc animated:YES]; UINavigationBar 设置标题 1234// 改变navigationItem中title 不会影响self.title self.navigationItem.title = @&quot;title2&quot;;// 改变self.title 会影响navigationItem.title self.title = @&quot;12345678&quot;; 自定义标题视图 123456789// 自定义标题视图 // 任何一个 UIView 以及 子类 都是可以作为 titleView的 // 用button 作为标题 依然能够响应点击事件 UIButton *titleButton = [UIButton buttonWithType:UIButtonTypeCustom]; [titleButton setTitle:@&quot;首页&quot; forState:UIControlStateNormal]; titleButton.backgroundColor = [UIColor redColor]; titleButton.frame = CGRectMake(344, 3245, 120, 40); // x,y值 不会决定标题视图的位置 [titleButton addTarget:self action:@selector(buttonAction:) forControlEvents:UIControlEventTouchUpInside]; self.navigationItem.titleView = titleButton; 使用文字标题来创建item 12345UIBarButtonItem *backItem = [[UIBarButtonItem alloc] initWithTitle:@&quot;返回&quot; style:UIBarButtonItemStylePlain target:self action:@selector(buttonAction:)]; self.navigationItem.leftBarButtonItem = backItem; 使用图片来创建item 12345UIBarButtonItem *backItem = [[UIBarButtonItem alloc] initWithImage:[UIImage imageNamed:@&quot;back&quot;] style:UIBarButtonItemStylePlain target:self action:@selector(buttonAction:)]; self.navigationItem.leftBarButtonItem = backItem; 使用自定义视图来创建item 123456789// 创建UIButton UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; [button setTitle:@&quot;返回&quot; forState:UIControlStateNormal]; [button setBackgroundImage:[UIImage imageNamed:@&quot;back&quot;] forState:UIControlStateNormal]; button.frame = CGRectMake(0, 0, 68, 33); [button addTarget:self action:@selector(buttonAction:) forControlEvents:UIControlEventTouchUpInside]; // 创建item UIBarButtonItem *backItem = [[UIBarButtonItem alloc] initWithCustomView:button]; self.navigationItem.leftBarButtonItem = backItem; 设置导航栏的风格 设置导航栏的风格 会影响状态栏的颜色 self.navigationController.navigationBar.barStyle = UIBarStyleDefault; 设置 导航栏是否透明 改变透明度 会影响self.view的高度 self.navigationController.navigationBar.translucent = YES; iOS 6 之前 用来修改导航栏背景颜色的方法 在iOS7 之后 能够用来修改系统自带的返回按钮字体颜色 self.navigationController.navigationBar.tintColor = [UIColor purpleColor]; iOS 7之后 修改导航栏背景颜色的方法 self.navigationController.navigationBar.barTintColor = [UIColor purpleColor]; 使用图片来作为导航栏的背景 [self.navigationController.navigationBar setBackgroundImage:[UIImage imageNamed:@&quot;navbar_bg_normal&quot;] forBarMetrics:UIBarMetricsDefault]; 导航上的 提示内容 self.navigationItem.prompt = nil;//默认情况下是nil]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS开发基本动画-Transform]]></title>
      <url>%2F2017%2F01%2F10%2FiOS%E5%BC%80%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%8A%A8%E7%94%BB-Transform%2F</url>
      <content type="text"><![CDATA[iOS开发中最普通的也是入门的动画就是transform了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//缩放视图- (IBAction)scaleAction:(UIButton *)sender &#123; if (sender.tag == 1) &#123; NSLog(@&quot;放大&quot;); /* _myView.transform = CGAffineTransformScale(_myView.transform, 1.2, 1.2); */ CGAffineTransform t = _myView.transform; t = CGAffineTransformScale(t, 1.2, 1.2); _myView.transform = t; &#125; if(sender.tag == 2)&#123; NSLog(@&quot;缩小&quot;); CGAffineTransform t = _myView.transform; t = CGAffineTransformScale(t, 0.5, 0.5); _myView.transform = t; &#125;&#125;//旋转- (IBAction)rotateAction:(UIButton *)sender &#123; CGAffineTransform t = _myView.transform; // PI 180 M_PI 180度 t = CGAffineTransformRotate(t, M_PI / 10); _myView.transform = t;&#125;//恢复- (IBAction)backAction:(id)sender &#123; //恢复视图的tansform值 _myView.transform = CGAffineTransformIdentity;&#125;//平移- (IBAction)tanslationAction:(UIButton *)sender &#123; CGAffineTransform t = _myView.transform; t = CGAffineTransformTranslate(t, 100, 100); _myView.transform = t; // _myView.frame.origin.y = 100; /* //通过修改视图的坐标平移 CGRect rect = _myView.frame; rect.origin.y = 300; _myView.frame = rect; */ &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS开发基础-视图层次结构和UIWindow的基本使用以及常用控件和iOS基本动画的使用]]></title>
      <url>%2F2017%2F01%2F08%2FiOS%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80-%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[视图的层次结构 123456789101112131415161718192021222324252627//直接将view2添加到父视图上// [self.window addSubview:view2]; /* 当把一个视图添加到父试图上显示时,会有一个索引,第一个被添加的试图索引值为0,然后依次递增,索引值越大,显示的优先级越高,也就是后添加的会把前面添加的覆盖 */ //1. 将view2添加到window中,并且将索引设置为0// [self.window insertSubview:view2 atIndex:0]; //2.将view2添加到window中,并且放到view1的下面// [self.window insertSubview:view2 belowSubview:view1]; //3.将view2添加到window中,并且放到view1的上面 [self.window insertSubview:view2 aboveSubview:view1]; /* //4.将view1放到子视图的最上层显示 [self.window bringSubviewToFront:view1]; //5.将view1放到子视图的最下层显示 [self.window sendSubviewToBack:view1]; */ //6.交换两个试图的索引值 [self.window exchangeSubviewAtIndex:0 withSubviewAtIndex:1]; //7.设置视图对象的属性tag，通过tag查找子视图 UIView *subView = [self.view viewWithTag:102]; UIWindow的基本使用 UIWindow的作用： 1.提供区域显示界面 2.接收用户的点击事件，分发到具体的控件 3.一般和控制器一起管理视图 123456789101112131415161718192021222324252627282930313233343536373839404142UIWindow的基本使用： //手机屏幕 UIScreen //单例类 一般提供一个类方法创建对象 shareInstansce main.... default.... // CGFloat height = [UIScreen mainScreen].bounds.size.height;// CGFloat width = [UIScreen mainScreen].bounds.size.width; UIWindow *window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; self.window = window; self.window.backgroundColor = [UIColor whiteColor]; /* 窗口于视图的区别 1.视图需要添加到一个父视图上才能显示 2.window可以直接显示 */ //1.把创建好的窗口设置为主窗口 2.将此窗口显示出来 [self.window makeKeyAndVisible]; //创建另外一个窗口(很少会这样做) myWindow = [[UIWindow alloc] initWithFrame:CGRectMake(0, 0, 320, 20)]; myWindow.backgroundColor = [UIColor redColor]; //设置显示的级别覆盖状态栏 myWindow.windowLevel = UIWindowLevelStatusBar; // [window makeKeyAndVisible]; 错误,只能有一个主窗口 //将窗口显示出来 myWindow.hidden = NO; //获取当前的keyWindow UIApplication *app = [UIApplication sharedApplication]; NSLog(@&quot;主窗口 = %@&quot;,app.keyWindow); NSLog(@&quot;self.window = %@&quot;,self.window); //窗口显示级别 UIWindowLevelNormal &lt; UIWindowLevelStatusBar &lt; UIWindowLevelAlert //状态栏也是一个窗口 高度是20,宽度是屏幕宽 显示级别为UIWindowLevelStatusBar// self.window.windowLevel = UIWindowLevelAlert; ​ iOS动画的基本使用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//方法一： //开始动画 [UIView beginAnimations:nil context:NULL]; //设置动画的时间 [UIView setAnimationDuration:1]; //设置动画执行的次数// [UIView setAnimationRepeatCount:100];// [UIView setAnimationsEnabled:YES]; //动画的运动趋势 [UIView setAnimationCurve:UIViewAnimationCurveEaseInOut]; //设置动画延迟执行的时间// [UIView setAnimationDelay:5]; //更改透明度 _myView.alpha = 0; //获取属性 CGAffineTransform transform = self.myView.transform; //旋转 _myView.transform = CGAffineTransformRotate(transform, M_PI / 10); //平移 _myView.transform = CGAffineTransformTranslate(transform, 0, 200); //恢复 self.myView.transform = CGAffineTransformIdentity; //放大视图:在视图原有的尺寸的基础上进行放大 self.myView.transform = CGAffineTransformScale(transform, 1.5, 2.0); //提交动画 [UIView commitAnimations]; //方法二： 使用Block，动画块进行动画的播放 [UIView animateWithDuration:1 animations:^&#123; //获取属性 CGAffineTransform transform = self.myView.transform; // //旋转视图:在视图原有的位置的基础上进行旋转 //以视图的中心旋转，顺时针旋转 transform = CGAffineTransformRotate(transform, M_PI_2); self.myView.transform = transform; &#125; completion:^(BOOL finished) &#123; self.myView.transform = CGAffineTransformIdentity; &#125;]; UILabel的基本使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//创建UILabel对象(标签) UILabel *lable = [[UILabel alloc] initWithFrame:CGRectMake(50, 50, 100, 0)]; lable.backgroundColor = [UIColor grayColor]; //1. 设置显示的文本// [lable setText:&lt;#(NSString *)#&gt;]; lable.text = @&quot;huiwenjiaoyuhuiwenjiaoyu&quot;; //2. 设置自动换行,默认是1行,设置为0为自动换行 lable.numberOfLines = 0; //3.设置字体 UIFont *font = [UIFont fontWithName:@&quot;Telugu Sangam MN&quot; size:25];// lable.font = font; //默认字体 lable.font = [UIFont systemFontOfSize:25]; //粗体 lable.font = [UIFont boldSystemFontOfSize:25]; //斜体 lable.font = [UIFont italicSystemFontOfSize:25]; //4.设置字体的颜色// lable.textColor = [UIColor redColor]; //5.设置文本的位置 默认为居左 lable.textAlignment = NSTextAlignmentCenter; //6.自适应 [lable sizeToFit]; //获取系统所有的字体 NSArray *fontNames = [UIFont familyNames]; NSLog(@&quot;%@&quot;,fontNames); [self.view addSubview:lable]; //断点形式 label.lineBreakMode = NSLineBreakByWordWrapping; //7.设置字体的阴影 lable.shadowColor = [UIColor orangeColor]; //阴影大小 lable.shadowOffset = CGSizeMake(2, 2); UIButton的基本使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109 //1.UIButon的创建 UIButton *button = [UIButton buttonWithType:UIButtonTypeSystem]; //设置frame button.frame = CGRectMake(50, 100, 60, 50); button.backgroundColor = [UIColor greenColor]; //设置标题// button.titleLabel.text = @&quot;标题&quot;;通过此种方式无法设置标题 /* 给按钮设置标题,标题颜色需要绑定一个状态 UIControlStateNormal 平常状态 , UIControlStateHighlighted 高亮状态 (按钮被点击时,系统自动切换) i UIControlStateDisabled 禁用状态 (通过代码设置) UIControlStateSelected 选择状态 (通过代码设置) */ //设置平常状态下的标题 [button setTitle:@&quot;按钮&quot; forState:UIControlStateNormal]; //设置高亮状态下的标题 [button setTitle:@&quot;正在点我&quot; forState:UIControlStateHighlighted]; //设置标题颜色 [button setTitleColor:[UIColor redColor] forState:UIControlStateNormal]; [button setTitleColor:[UIColor yellowColor] forState:UIControlStateHighlighted]; //设置字体时不需要绑定状态 button.titleLabel.font = [UIFont systemFontOfSize:20]; // Target靶 MVC 给按钮绑定一个方法,当按钮被点击时,会调用绑定的方法 [button addTarget:self action:@selector(clickAction:) forControlEvents:UIControlEventTouchUpInside]; //是否禁用按钮// button.enabled = NO; // 禁止按钮响应触摸事件// button.userInteractionEnabled = NO; //当按钮被点击时,会发光 button.showsTouchWhenHighlighted = YES; [self.view addSubview:button]; //______________________图片按钮___________________________ /* 设置背景图片时,如果按钮比较大,会将图片拉伸 setBackgroundImage 设置图片时,如果按钮比较大,不会拉伸图片,图片以原图显示,居中 setImage 以上两种方式都需要绑定状态 */ UIButton *but1 = [UIButton buttonWithType:UIButtonTypeCustom]; /* //设置背景图片 NSString UIImage NSData UIImage *image = [UIImage imageNamed:@&quot;back_on_black.png&quot;]; //设置平常状态下的背景图片 [but1 setBackgroundImage:image forState:UIControlStateNormal]; UIImage *image1 = [UIImage imageNamed:@&quot;back_on.png&quot;]; //设置平常状态下的高亮图片 [but1 setBackgroundImage:image1 forState:UIControlStateHighlighted]; but1.frame = CGRectMake(100, 200, 90, 44); //设置标题 [but1 setTitle:@&quot;保存&quot; forState:UIControlStateNormal]; */ self.view.backgroundColor = [UIColor darkGrayColor]; //如果同时设置了图片又设置了标题,那么图片和标题会并列显示 //同事设置背景图片与标题时,标题会显示在图片的上方 //设置图片 but1.frame = CGRectMake(100, 150, 300, 44); but1.backgroundColor = [UIColor blueColor]; [but1 setImage:[UIImage imageNamed:@&quot;back_on_black.png&quot;] forState:UIControlStateNormal]; [but1 setImage:[UIImage imageNamed:@&quot;back_on.png&quot;] forState:UIControlStateHighlighted]; [but1 setTitle:@&quot;保存&quot; forState:UIControlStateNormal]; // UIEdgeInsets edge = UIEdgeInsetsMake(0, 0, 0, 100);// //设置按钮标题的偏移量// [but1 setTitleEdgeInsets:edge]; // [but1 setImageEdgeInsets:&lt;#(UIEdgeInsets)#&gt;]; [self.view addSubview:but1]; //按钮的选择状态 UIButton *checkBtn = [UIButton buttonWithType:UIButtonTypeCustom]; //设置平常状态下的图片 [checkBtn setImage:[UIImage imageNamed:@&quot;playing_btn_love_disable.png&quot;] forState:UIControlStateNormal]; //设置选择状态下的图片 [checkBtn setImage:[UIImage imageNamed:@&quot;playing_btn_in_myfavor.png&quot;] forState:UIControlStateSelected]; //绑定事件方法 [checkBtn addTarget:self action:@selector(loveAction:) forControlEvents:UIControlEventTouchUpInside]; //设置按钮为选择状态// checkBtn.selected = YES; 默认为NO checkBtn.frame = CGRectMake(50, 300, 50, 50); [self.view addSubview:checkBtn]; ​ UITextField的基本使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#import &quot;ViewController.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //1.创建输入框 UITextField *textField = [[UITextField alloc] initWithFrame:CGRectMake(50, 50, 200, 30)]; //2.设置边框样式 textField.borderStyle = UITextBorderStyleRoundedRect; [self.view addSubview:textField]; // //3.设置文本的颜色 textField.textColor = [UIColor redColor]; //4.设置清除按钮模式 textField.clearButtonMode = UITextFieldViewModeWhileEditing; //5.当输入框为空时,显示的提示字符 textField.placeholder = @&quot;请输入密码&quot;; //6.设置字体 textField.font = [UIFont italicSystemFontOfSize:17]; //7.安全输入// textField.secureTextEntry = YES; //8.设置return按钮 textField.returnKeyType = UIReturnKeySend; //9.键盘外观 textField.keyboardAppearance = UIKeyboardAppearanceDefault; UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 50, 50)]; imageView.image = [UIImage imageNamed:@&quot;left&quot;]; //10.键盘左侧视图 textF.leftView = imageView; textF.leftViewMode = UITextFieldViewModeAlways; //11.清除按钮 textF.clearButtonMode = UITextFieldViewModeAlways; //12.设置输入框的键盘类型 textF.keyboardType = UIKeyboardTypeDefault; //设置为第一相应者,会直接弹出键盘 [textField becomeFirstResponder]; //设置代理 textField.delegate = self; // textFiled -&gt; self -&gt; view -&gt; textFiled 循环引用 // a -&gt; b -&gt; c - &gt; d -&gt; a /* //点击return [self.delegate 协议方法] */ //是否开启首字母大写 textField.autocapitalizationType = UITextAutocapitalizationTypeNone; &#125;#pragma mark -UITextFieldDeleagte//当return按钮被点击时,会调用次协议方法- (BOOL)textFieldShouldReturn:(UITextField *)textField&#123; //让键盘返回,缩回 //方式1// [textField endEditing:YES]; //方式2 //失去第一响应者 [textField resignFirstResponder]; return YES;&#125;//如果然会NO,则键盘不会弹出- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField &#123; NSLog(@&quot;键盘将要弹出&quot;); return YES;&#125; // return NO to disallow editing.- (void)textFieldDidBeginEditing:(UITextField *)textField &#123; NSLog(@&quot;键盘已经弹出&quot;); &#125; - (BOOL)textFieldShouldEndEditing:(UITextField *)textField &#123; NSLog(@&quot;键盘将要返回&quot;); return YES; &#125; // return YES to allow editing to stop and to resign first responder status. NO to disallow the editing session to end- (void)textFieldDidEndEditing:(UITextField *)textField &#123; NSLog(@&quot;键盘已经返回&quot;); &#125; //当输入框被编辑时,会实时调用- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string &#123; NSLog(@&quot;%@&quot;,string); if ([string isEqualToString:@&quot;a&quot;]) &#123; return NO; //如果返回NO,输入的字符不会显示在输入框中 &#125; return YES; &#125; // return NO to not change text @end UIImageView的基本使用(包含图片数组的循环播放动画) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136 #import &quot;ViewController.h&quot; @interface ViewController () @end @implementation ViewController - (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //1. UIImageView的创建 /* UIImageView *imageView = [[UIImageView alloc] initWithFrame:&lt;#(CGRect)#&gt;]; imageView.image */ //layer层：设置视图的 边框，圆角的弧度// imageView.layer.borderWidth = 2;// imageView.layer.borderColor = [UIColor redColor].CGColor;// imageView.layer.cornerRadius = 5; UIImage *image = [UIImage imageNamed:@&quot;back_on_black.png&quot;]; // 图片的大小 // image.size UIImageView *imageView = [[UIImageView alloc] initWithImage:image]; imageView.frame = CGRectMake(50, 0, 200, 200); imageView.backgroundColor = [UIColor orangeColor]; //设置内容模式 /* 默认为UIViewContentModeScaleToFill拉伸填充,会是图片变形 UIViewContentModeScaleAspectFit 等比例缩放 UIViewContentModeScaleAspectFill, 等比例的充满整个视图 */ imageView.contentMode = UIViewContentModeScaleAspectFit; [self.view addSubview:imageView]; //2. 设置高亮图片 imageView.highlightedImage = [UIImage imageNamed:@&quot;Icon.png&quot;]; //需要手动设置为高亮状态,才能显示高亮状态下的图片 // imageView.highlighted = YES; //3.不接受用户交互事件 默认为NO,如果在图片视图上添加按钮,则按钮也不接受点击事件 imageView.userInteractionEnabled = YES; UIButton *btn = [UIButton buttonWithType:UIButtonTypeSystem]; [btn setTitle:@&quot;保存&quot; forState:UIControlStateNormal]; [btn setFrame:CGRectMake(0, 0, 100, 100)]; [btn addTarget:self action:@selector(clickAction:) forControlEvents:UIControlEventTouchUpInside]; [imageView addSubview:btn]; //4.可以加载网络上的图片 UIImageView *imageView1 = [[UIImageView alloc] initWithFrame:CGRectMake(0, 200, 100, 100)]; NSURL *url = [NSURL URLWithString:@&quot;https://www.baidu.com/img/bd_logo1.png&quot;]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *imageNet = [UIImage imageWithData:data]; imageView1.image = imageNet; [self.view addSubview:imageView1]; //播放动画 UIImageView *imageView3 = [[UIImageView alloc] initWithFrame:CGRectMake(20, 300, 200, 200)]; imageView3.tag = 100; //图片数组 imags = [NSMutableArray array]; for (NSInteger i = 1; i &lt;= 21; i++) &#123; NSString *imageName = [NSString stringWithFormat:@&quot;%ld.jpg&quot;,i]; UIImage *image = [UIImage imageNamed:imageName]; [imags addObject:image]; &#125; /* //将图片数组交给图片视图 imageView3.animationImages = imags; //设置动画的时间 imageView3.animationDuration = 2.1; //动画重复的次数：默认循环播放 imageView.animationRepeatCount = 3; //开始动画 [imageView3 startAnimating]; */ [self.view addSubview:imageView3]; //通过定时器实现图片的播放 [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(timerAction:) userInfo:nil repeats:YES]; &#125; - (void)timerAction:(NSTimer *)timer&#123; UIImageView *imageView = (UIImageView *)[self.view viewWithTag:100]; //UIView //切换图片 imageView.image = imags[index]; index++; if (index &gt;= imags.count) &#123; index = 0; &#125; &#125; - (void)clickAction:(UIButton *)btn&#123; &#125; - (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated. &#125; @end ​ UISlider的基本使用 123456789101112131415161718192021222324252627282930313233343536373839- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //滑块的创建 UISlider *slider = [[UISlider alloc] initWithFrame:CGRectMake(20, 100, 300, 30)]; // slider.backgroundColor = [UIColor redColor]; [self.view addSubview:slider]; // 默认最小值为0 最大值为1 slider.value = .5; //设置最大值 slider.maximumValue = 100; //设置最小值// slider.minimumValue = 0; //绑定方法,监听滑动事件// [slider addTarget:self action:@selector(sliderAction:) forControlEvents:UIControlEventValueChanged]; [slider addTarget:self action:@selector(sliderAction:) forControlEvents:UIControlEventValueChanged]; //设置进度条的颜色 [slider setMaximumTrackTintColor:[UIColor redColor]]; [slider setMinimumTrackTintColor:[UIColor greenColor]]; // [slider setMaximumTrackImage:&lt;#(UIImage *)#&gt; forState:&lt;#(UIControlState)#&gt;]; //设置拇指视图// [slider setThumbImage:&lt;#(UIImage *)#&gt; forState:&lt;#(UIControlState)#&gt;];&#125;- (void)sliderAction:(UISlider *)slider&#123; NSLog(@&quot;%f&quot;,slider.value); &#125; 模态视图的基本使用 123456789101112131415//切换视图 SecondViewController *ctrl = [[SecondViewController alloc] init]; //通过模态视图弹出,将第二个控制器的视图弹出 //设置动画效果 ctrl.modalTransitionStyle = UIModalTransitionStyleFlipHorizontal; /* 将 ctrl的视图添加到窗口上面 */ [self presentViewController:ctrl animated:YES completion:NULL]; //返回 [self dismissViewControllerAnimated:YES completion:NULL]; 网络加载活动视图UIActivityIndicatorView的基本使用 1234567891011121314151617181920212223242526272829//活动视图 /* 样式1. UIActivityIndicatorViewStyleWhiteLarge 大白2. UIActivityIndicatorViewStyleGray 灰色3. UIActivityIndicatorViewStyleWhite */ //self.view.backgroundColor = [UIColor orangeColor]; activityView = [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:UIActivityIndicatorViewStyleWhiteLarge]; activityView.frame = CGRectMake(100, 200, 0, 0); //activityView.backgroundColor = [UIColor redColor]; //停止转动时,是否消失,默认是YES //activityView.hidesWhenStopped = NO; //开始动画 [activityView startAnimating]; //hideaAction方法中调用[activityView stopAnimating]来停止动画 [self performSelector:@selector(hideaAction) withObject:nil afterDelay:4]; [self.view addSubview:activityView]; //创建应用程序对象 UIApplication *app = [UIApplication sharedApplication]; [app setNetworkActivityIndicatorVisible:YES]; UISwitch的基本使用 12345678910111213//开关 UISwitch UISwitch *switchBtn = [[UISwitch alloc] initWithFrame:CGRectMake(50, 50, 100, 100)]; //开关是否打开 switchBtn.on = YES; //绑定事件 [switchBtn addTarget:self action:@selector(switchAction:) forControlEvents:UIControlEventValueChanged]; [self.view addSubview:switchBtn]; switchBtn.onTintColor = [UIColor redColor]; switchBtn.thumbTintColor = [UIColor blueColor]; ​ 分页控件UIPageControl 1234567UIPageControl *pageControl = [[UIPageControl alloc] initWithFrame:CGRectMake(50, 80, 300, 30)]; pageControl.backgroundColor = [UIColor orangeColor]; pageControl.currentPage = 0; pageControl.numberOfPages = 5; [pageControl addTarget:self action:@selector(pageControlAction) forControlEvents:UIControlEventValueChanged]; [self.view addSubview:pageControl]; ​ 分段控件UISegmentedControl 1234567891011121314//分段控件 NSArray *array = @[@&quot;娱乐&quot;,@&quot;综艺&quot;,@&quot;体育&quot;]; UISegmentedControl *segment = [[UISegmentedControl alloc] initWithItems:array]; segment.frame = CGRectMake(100, 150, 200, 40); [self.view addSubview:segment]; //被选中的索引 segment.selectedSegmentIndex = 2; //设置渲染的颜色 segment.tintColor = [UIColor orangeColor]; [segment addTarget:self action:@selector(segementAction:) forControlEvents:UIControlEventValueChanged]; ​ AVAudioPlayer 首先需要导入AVFoundation.framework 12345678910111213141516171819202122232425262728293031323334353637#import &quot;ViewController.h&quot;#import &lt;AVFoundation/AVFoundation.h&gt;@interface ViewController ()&#123; AVAudioPlayer *_player; &#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //创建播放器对象 //播放的音乐 //获取资源文件的路径 NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;小苹果&quot; ofType:@&quot;mp3&quot;]; //转换成url NSURL *url = [NSURL fileURLWithPath:path]; _player = [[AVAudioPlayer alloc] initWithContentsOfURL:url error:nil]; //音频文件中的时间 NSLog(@&quot;%f&quot;,_player.duration); //播放文件 [_player play]; //暂停播放// [player pause];&#125; ​ ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Foundation框架的基本使用]]></title>
      <url>%2F2017%2F01%2F07%2FFoundation%E6%A1%86%E6%9E%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[NSObject常用方法 首先创建一个基类：Person Person.m中增加一个私有方法 123- (void)_privateFunc &#123; NSLog(@&quot;Person的私有方法&quot;);&#125; 在创建一个子类：Student继承Person 下面通过代码来介绍NSObject常用方法 12345678910111213141516171819202122232425262728293031323334353637383940#import &lt;Foundation/Foundation.h&gt;#import &quot;Person.h&quot;#import &quot;Student.h&quot;int main(int argc, const char * argv[]) &#123; NSObject *obj1 = [[NSObject alloc] init]; NSObject *obj2 = [[NSObject alloc] init]; //1. 判断两个实例对象是否是同一个实例对象 if (![obj1 isEqualTo:obj2]) &#123; NSLog(@&quot;两个实例对象地址不同&quot;); &#125; if (obj1 == obj2) &#123; &#125; //2.isMemberOfClass:判断实例对象是否是Person类创建的。 //isKindOfClass:判断实例对象是否是当前类创建的或者继承自当前类。 Person *p = [[Person alloc] init]; if ([p isMemberOfClass:[Person class]]) &#123; NSLog(@&quot;p是Person类创建的实例对象&quot;); &#125; if ([p isKindOfClass:[NSObject class]]) &#123; NSLog(@&quot;p是NSObject类创建的实例对象或者是继承自NSObject&quot;); &#125; //间接继承也返回YES Student *s = [[Student alloc] init]; if ([s isKindOfClass:[NSObject class]]) &#123; &#125; //3.performSelector：通过包装好的SEL数据来调用方法 //respondsToSelector:判断当前类中是否已经定义了这个方法 //[p _privateFunc]; if ([p respondsToSelector:@selector(_privateFunc)]) &#123; [p performSelector:@selector(_privateFunc)]; &#125; return 0;&#125; ​ 常用的结构体 常用的结构体有： NSRange NSPoint/CGPoint NSSize/CGSize NSRect/CGRect 下面通过代码来简单介绍一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#import &lt;Foundation/Foundation.h&gt; void rangeUse(void) &#123; //@&quot;I love programming!&quot; //&#123;1,2,3,4,5&#125;; NSRange range = &#123;2, 4&#125;; NSRange range1 = &#123;.location = 3, .length = 2&#125;; //OC常用此函数来创建NSRange结构体变量 NSRange range2 = NSMakeRange(2, 4); NSString *str = @&quot;I love Programming&quot;; //查找@&quot;is&quot;的范围 NSRange r = [str rangeOfString:@&quot;is&quot;]; //如果查找不到，则location为NSNotFound,length为0 if (r.location == NSNotFound) &#123; NSLog(@&quot;此字符串中没有is子串&quot;); &#125; else &#123; //r.location,r.length NSLog(@&quot;%@&quot;,NSStringFromRange(r)); &#125; &#125; //NSPoint CGPoint NSSize CGSize NSRect CGRect void pointUse(void) &#123; //CGPoint表示一个点 CGPoint p1 = CGPointMake(20, 30); NSLog(@&quot;%@&quot;, NSStringFromPoint(p1)); //CGSize表示一个尺寸 CGSize s1 = CGSizeMake(100, 100); NSLog(@&quot;%@&quot;, NSStringFromSize(s1)); //CGRect表示一个UI元素 CGRect r1 = CGRectMake(0, 0, 100, 100); CGRect r2 = &#123;p1,s1&#125;; CGRect r3 = &#123;CGPointZero,CGSizeMake(100, 100)&#125;; NSLog(@&quot;%@&quot;,NSStringFromRect(r1)); &#125; int main(int argc, const char * argv[]) &#123;//rangeUse(); //pointUse(); BOOL b = CGPointEqualToPoint(CGPointZero, CGPointMake(0, 100)); BOOL b2 = CGRectContainsPoint(CGRectMake(50, 10, 1, 2), CGPointZero); NSLog(@&quot;%i&quot;, b2); return 0; &#125; NSString 下面通过代码来简单介绍一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#import &lt;Foundation/Foundation.h&gt;//1.字符串创建void stringCreate(void) &#123; NSString *s1 = @&quot;hello&quot;; //NSString *s2 = [[NSString alloc] initWithString:@&quot;220&quot;]; //类方法创建 NSString *s3 = [NSString stringWithFormat:@&quot;age is %i&quot;,10]; //用C语言的字符串来创建 NSString *s4 = [NSString stringWithUTF8String:&quot;hello&quot;]; //把字符串对象转换成C字符串 const char *cString = [s4 UTF8String]; //从文件中读取字符串 NSError *error = nil; NSString *s5 = [NSString stringWithContentsOfFile:@&quot;/Users/kangkathy/Desktop/1.txt&quot; encoding:NSUTF8StringEncoding error:&amp;error]; //NSLog(@&quot;%@&quot;, s5); //从网络资源中读取字符串 //URL:网络资源路径 NSURL *url = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;]; NSString *s6 = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error]; NSLog(@&quot;%@&quot;, s6);&#125;//2.字符串的导出void stringExport(void) &#123; NSString *string = @&quot;hello world&quot;; [string writeToFile:@&quot;/Users/kangkathy/Desktop/1.txt&quot; atomically:YES encoding:NSUTF8StringEncoding error:nil];&#125;//3.字符串的比较void stringCompare(void) &#123; NSString *s1 = @&quot;abcd&quot;; NSString *s2 = @&quot;ABCD&quot;; //对大小写敏感的比较 compare if (![s1 isEqualToString:s2]) &#123; NSLog(@&quot;两个字符串内容不相同&quot;); &#125; //忽略大小写的比较 NSComparisonResult result = [s1 caseInsensitiveCompare:s2]; if (result == NSOrderedSame) &#123; NSLog(@&quot;两个字符串忽略大小写内容相同&quot;); &#125; else if (result == NSOrderedAscending) &#123; NSLog(@&quot;s1 &lt; s2，升序&quot;); &#125; else if (result == NSOrderedDescending) &#123; NSLog(@&quot;s1 &gt; s2，降序&quot;); &#125; &#125;void stringOther(void) &#123; //获取字符串字符的个数,一个中文按一个字符计数 NSString *str = @&quot;abcd一二&quot;; NSLog(@&quot;count=%lu&quot;, str.length); //获取对应下标字符 unichar c = [str characterAtIndex:0]; NSLog(@&quot;%c&quot;, c); //字符串转换 //把字符串中的小写字母转换成大写字母 NSString *str2 = @&quot;hEhE&quot;; NSLog(@&quot;%@&quot;, [str2 uppercaseString]); NSLog(@&quot;%@&quot;, [str2 lowercaseString]); //字符串类型转换成基本类型 int i = [@&quot;123&quot; intValue]; double d = [@&quot;1.4&quot; doubleValue]; BOOL b = [@&quot;YES&quot; boolValue]; NSLog(@&quot;%i,%lf,%i&quot;, i, d, b);&#125;//改变字符串的方法void stringChange(void) &#123; //字符串截取 NSString *s1 = @&quot;kangxiangzhe@huiwen.com&quot;; //不可变字符一经创建不会改变里面的内容，如果要截取或者拼接则会产生新的字符串 //从字符串的起始位置截取到指定位置（不包含指定位置的字符) NSString *subStr1 = [s1 substringToIndex:12]; //从指定位置截取到字符串的末尾（包含指定位置的字符) NSString *subStr2 = [s1 substringFromIndex:12]; //从第2个开始后面的4个位置的数 NSString *subStr3 = [s1 substringWithRange:NSMakeRange(2,4)];// NSLog(@&quot;subStr1:%@&quot;, subStr1);// NSLog(@&quot;subStr2:%@&quot;, subStr2);// NSLog(@&quot;subStr3:%@&quot;, subStr3); //字符串的拼接 NSString *str4 = @&quot;iOS&quot;; NSString *str5 = [str4 stringByAppendingString:@&quot;23&quot;]; NSString *str6 = [str4 stringByAppendingFormat:@&quot;%@--%i&quot;,str5,7]; NSLog(@&quot;str5:%@&quot;, str6); //字符串的查找 NSString *eMail = @&quot;sb@163.com,erhuo@163.com&quot;; NSRange r = [eMail rangeOfString:@&quot;163.com&quot;]; if (r.location == NSNotFound) &#123; NSLog(@&quot;找不到此字符串&quot;); &#125; //字符串的替换 NSString *newEMail = [eMail stringByReplacingOccurrencesOfString:@&quot;163.com&quot; withString:@&quot;qq.com&quot;]; NSLog(@&quot;newEMail:%@&quot;, newEMail); //分割字符串 NSString *str1=@&quot;qwbud,,qwdoi..qwdbiu&quot;; NSArray *array=[str1 componentsSeparatedByString:@&quot;d&quot;]; NSLog(@&quot;%@&quot;,array); //访问字符串指定位置字符 NSString *str2=@&quot;nhgsiohsoigniohewt&quot;; char c = [str2 characterAtIndex:5]; NSLog(@&quot;%c&quot;,c); &#125;int main(int argc, const char * argv[]) &#123; //stringCreate(); //stringExport(); //stringCompare(); //stringOther(); stringChange(); return 0;&#125; ​ NSMutableString 12345678910111213141516171819202122232425262728293031323334353637383940#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; //可变字符串的创建 //创建一个空的字符串 NSMutableString *ms = [NSMutableString string]; //根据不可字符串创建一个可变字符串 NSMutableString *ms1 = [NSMutableString stringWithString:@&quot;hello&quot;]; //按照某种格式创建字符串 NSMutableString *ms2 = [NSMutableString stringWithFormat:@&quot;字符串&quot;]; //NSString和NSMutableString的区别// NSString对象不可变，添加删除时会产生一个新的字符串，不能在自身上操作。// NSMutableString可以自身的基础上添加和删除。 //1.添加字符串 [ms2 insertString:@&quot;可变&quot; atIndex:0]; NSLog(@&quot;%@&quot;, ms2); //追加字符串 [ms2 appendString:@&quot;对象&quot;]; NSLog(@&quot;%@&quot;, ms2); //2.删除字符串 NSRange r = [ms2 rangeOfString:@&quot;可变&quot;]; [ms2 deleteCharactersInRange:r]; NSLog(@&quot;%@&quot;, ms2); //3.字符串的替换 NSRange r1 = [ms2 rangeOfString:@&quot;字符&quot;]; [ms2 replaceCharactersInRange:r1 withString:@&quot;羊肉&quot;]; NSLog(@&quot;%@&quot;, ms2); return 0;&#125; 下面是一个小demo，查找出一个字符串里面的数字 123456789101112131415161718192021222324NSString * stringWithoutNum(NSString *str)&#123;// NSMutableString *str1 = [[NSMutableString alloc] init];// NSMutableString *str2 = [[NSMutableString alloc] init];// for (NSUInteger i =0; i&lt; str.length; i++) &#123;// unichar c = [str characterAtIndex:i];// NSRange range = NSMakeRange(i, 1);// if (c &lt; &apos;0&apos; || c &gt; &apos;9&apos;) &#123;// str1 = [NSMutableString stringWithString:[str substringWithRange:range]];// [str2 appendString:str1];// &#125;// &#125;// // return str2; NSMutableString *strm = [NSMutableString stringWithString:str]; for (NSInteger i = 0; i &lt; 10; i++) &#123; [strm replaceOccurrencesOfString:[NSString stringWithFormat:@&quot;%li&quot;,i] withString:@&quot;&quot; options:NSLiteralSearch range:NSMakeRange(0, strm.length)]; &#125; return strm; &#125; ​ NSArray 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//1.数组的创建//2.数组的遍历#import &lt;Foundation/Foundation.h&gt;#import &quot;Person.h&quot;void arrayCreate(void) &#123; //创建一个空数组 NSArray *array = [NSArray array]; //创建一个有一个元素的数组 NSArray *array1 = [NSArray arrayWithObject:@&quot;hello&quot;]; //创建一个有两个元素的数组 Person *p = [[Person alloc] init]; //nil表示数组结束的标记，并不是数组的元素 NSArray *array2 = [NSArray arrayWithObjects:@&quot;Kathy&quot;,@&quot;hello&quot;,p, nil]; NSLog(@&quot;%@&quot;, array2); //编译器新特性 NSArray *array3 = @[@&quot;kathy&quot;,@&quot;hello&quot;, p]; //访问到数组中某下标对应的元素 NSLog(@&quot;数组的第一个元素是：%@&quot;,[array3 objectAtIndex:0]); //新语法a[0] NSLog(@&quot;数组的第一个元素是：%@&quot;,array3[0]); //字符串分割的结果保存在数组中 NSString *str = @&quot;086-135880-99765&quot;; NSArray *array4 = [str componentsSeparatedByString:@&quot;-&quot;]; NSLog(@&quot;%@&quot;, array4); //是否包含 BOOL isContain = [array containsObject:@&quot;sunkeqiang&quot;]; NSLog(@&quot;%d&quot;,isContain); //某个值得索引 NSUInteger index = [array indexOfObject:@&quot;xuzhonglin&quot;]; NSLog(@&quot;%li&quot;,index); NSString *str = [array componentsJoinedByString:@&quot;-&quot;]; NSLog(@&quot;%@&quot;,str); //最后一个 NSString *lastStr = [array lastObject]; NSLog(@&quot;%@&quot;,lastStr); &#125;//数组的遍历void arrayEnumerate(void) &#123; Person *p = [[Person alloc] init]; p.age = 10; NSArray *array = @[p, @&quot;kathy&quot;, @&quot;hi&quot;]; //1.最直观的方法 for (NSUInteger i = 0; i &lt; array.count; i++) &#123; NSLog(@&quot;%@&quot;, array[i]); &#125; //2.快速遍历 for (id obj in array) &#123; NSUInteger i = [array indexOfObject:obj]; NSLog(@&quot;%@&quot;, obj); &#125; //3.block遍历 &#125;int main(int argc, const char * argv[]) &#123; //int a[5] = &#123;1,2,3,4,5&#125;; //OC数组只能存放OC对象，不能存放基本类型的数据，不能存放结构体变量，也不能存放nil。 //arrayCreate(); arrayEnumerate(); NSArray *array2 = @[@&quot;zhangsan&quot;,@&quot;lisi&quot;,@&quot;wangwu&quot;,@&quot;zhaoliu&quot;,@&quot;hanba&quot;]; [array2 writeToFile:@&quot;/Users/kanzhetaiyangchishaobing/Desktop/1.txt&quot; atomically:NO]; NSArray *array3 = [NSArray arrayWithContentsOfFile:@&quot;/Users/kanzhetaiyangchishaobing/Desktop/1.txt&quot;]; NSLog(@&quot;%@&quot;,array3); return 0;&#125; 其中的block遍历 首先是最基本的运用形式 1234567891011121314151617//基于 块（block） 结构的遍历数组方法 enumerate:列举，数 //参数介绍： obj:值 idx:索引 stop：停止遍历 NSArray *arr1 = @[@&quot;好&quot;, @&quot;好&quot;, @&quot;学&quot;, @&quot;习&quot;, @&quot;天&quot;, @&quot;天&quot;, @&quot;向&quot;,@&quot;上&quot;]; [arr1 enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; //NSLog(@&quot;输出基于 块（block） 结构的遍历数组方法数组中的值.......%@&quot;, obj); if ([obj isEqualToString:@&quot;习&quot;]) &#123; *stop = YES; &#125; &#125;]; 123456789101112131415161718192021 //基于 块（block） 结构的遍历字典方法，字典是无序的，每次值的顺序是不固定的 enumerate:列举，数 //参数介绍： key:键 obj：值 stop：停止遍历 NSDictionary *dict1 = @&#123;@&quot;1&quot;:@&quot;好好&quot;, @&quot;2&quot;:@&quot;学习&quot;, @&quot;3&quot;:@&quot;天天&quot;,@&quot;4&quot;:@&quot;向上&quot;&#125;; [dict1 enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; //NSLog(@&quot;输出基于 块（block） 结构的遍历字典方法字典中的值........%@&quot;, obj); if ([obj isEqualToString:@&quot;向上&quot;]) &#123; *stop = YES; &#125; &#125;];若已知collection里对象的数据类型，可以修改块签名，知道对象的精确类型后，编译器就可以检测开发者是否调用了该对象所不具有的方法，并在发现问题时报错。如代码，直接把key和value的类型修改成NSString类型。 1234567891011121314151617//基于 块（block） 结构的遍历字典，如果知道字典中的键、值类型，可以修改块儿中的键、值类型的方法，字典是无序的，每次值的顺序是不固定的 enumerate:列举，数 //参数介绍： key:键 obj：值 stop：停止遍历 NSDictionary *dict2 = @&#123;@&quot;1&quot;:@&quot;好好&quot;, @&quot;2&quot;:@&quot;学习&quot;, @&quot;3&quot;:@&quot;天天&quot;,@&quot;4&quot;:@&quot;向上&quot;&#125;; [dict2 enumerateKeysAndObjectsUsingBlock:^(NSString *key, NSString *obj, BOOL * _Nonnull stop) &#123; //NSLog(@&quot;基于 块（block） 结构的遍历字典，修改键、值类型的方法字典中的值........%@&quot;, obj); if ([obj isEqualToString:@&quot;向上&quot;]) &#123; *stop = YES; &#125; &#125;]; 1234567891011121314151617//基于 块（block） 结构的 反向 遍历数组方法 enumerate:列举，数 多添加一个参数：NSEnumerationReverse：Reverse：相反， //参数介绍： obj:值 idx:索引 stop：停止遍历 NSArray *arr2 = @[@&quot;好&quot;, @&quot;好&quot;, @&quot;学&quot;, @&quot;习&quot;, @&quot;天&quot;, @&quot;天&quot;, @&quot;向&quot;,@&quot;上&quot;]; [arr2 enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(NSString *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; //NSLog(@&quot;基于 块（block） 结构的 反向 遍历数组方法数组中的值.......%@&quot;, obj); if ([obj isEqualToString:@&quot;习&quot;]) &#123; *stop = YES; &#125; &#125;]; 12345678910111213141516171819202122232425//基于 块（block） 结构的 并发 遍历数组方法 enumerate:列举，数 Concurrent：同时发生的 //参数是：NSEnumerationConcurrent，也就是可以同时遍历collection中的几个元素，具体数量根据系统资源而定 //参数介绍： obj:值 idx:索引 stop：停止遍历 NSArray *arr3 = @[@&quot;好&quot;, @&quot;好&quot;, @&quot;学&quot;, @&quot;习&quot;, @&quot;天&quot;, @&quot;天&quot;, @&quot;向&quot;,@&quot;上&quot;]; NSMutableArray *newArr = [NSMutableArray arrayWithArray:arr3]; [newArr enumerateObjectsWithOptions:NSEnumerationConcurrent usingBlock:^(NSString *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; obj = [NSString stringWithFormat:@&quot;_%@&quot;, obj]; [newArr replaceObjectAtIndex:idx withObject:obj]; NSLog(@&quot;基于 块（block） 结构的 并发 遍历数组方法数组中的值.......%@&quot;, obj);// if ([obj isEqualToString:@&quot;_向&quot;]) &#123;// *stop = YES;// &#125; &#125;]; ​ block遍历优缺点总结： 优点： 1、可以完美实现for循环的所有功能； 2、可以方便获取集合中的每一项元素； 3、提供了循环遍历的参数，NSEnumerationReverse用来实现倒序循环。NSEnumerationConcurrent用来实现并发遍历，两个参数可以同时使用； 4、这种循环方式效率高，能够提升程序性能，开发者可以专注于业务逻辑，而不必担心内存和线程的问题； 5、当开启NSEnumerationConcurrent选项时，可以实现for循环和快速遍历无法轻易实现的并发循环功能，系统底层会通过GCD处理并发事宜，这样可以充分利用系统和硬件资源，达到最优的遍历效果； 6、可以修改块签名，当我们已经明确集合中的元素类型时，可以把默认的签名id类型修改成已知类型，比如常见的NSString，这样既可以节省系统资源开销，也可以防止误向对象发送不存在的方法是引起的崩溃。 缺点： 1、很多开发者不知道这种遍历方式； 2、这里使用了block，需要注意在block里容易引起的保留环问题，比如使用self调用方法时，把self转化成若引用即可打破保留环。如：weak typeof(self)weakSelf = self 或者 __weak MyController *weakSelf = self; 在block里使用weakSelf即可。 注意： 使用基于块的遍历时是可以修改遍历的元素的，不会导致崩溃，但是如果要删除遍历的元素会导致后面的元素无法遍历而崩溃，解决办法有2种，1、一种是复制一份原集合的副本，对副本进行操作，找出所要操作的元素后再处理原集合；2、使用反向遍历，反向遍历删除元素后不会导致崩溃。 ​ NSDictionary 1234567891011121314#import &lt;Foundation/Foundation.h&gt;void dictionaryCreate(void) &#123; //创建字典里面仅有一个键值对 NSDictionary *dic = [NSDictionary dictionaryWithObject:@&quot;kathy&quot; forKey:@&quot;name&quot;]; NSLog(@&quot;%@&quot;, dic);&#125;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; dictionaryCreate(); &#125; return 0;&#125; ​ NSNumber和NSValue 1234567891011121314151617181920212223#import &lt;Foundation/Foundation.h&gt;void number(void) &#123; //把基本类型的数据包装OC对象 NSNumber *num = [NSNumber numberWithInt:20]; NSDictionary *person = @&#123;@&quot;name&quot; : @&quot;zhangsan&quot;, @&quot;age&quot; : num&#125;; NSLog(@&quot;%@&quot;, person); NSNumber *num2 = person[@&quot;age&quot;]; //把NSNumber对象转成基本类型数据 NSLog(@&quot;%i&quot;, [num2 intValue]); //更为简单的方法把基本类型数据包装成OC对象,直接在基本类型数据前加@就可以把它包装成一个OC对象 NSArray *array = @[@1, @2]; // @15.2 // @YES // @&apos;a&apos; //对于基本类型的变量，不能前面直接加@,编译器会为是一个关键字，需要加括号。 int age = 10; NSLog(@&quot;%@&quot;, @(age));&#125; int main(int argc, const char * argv[]) {​ //NSValue--&gt;NSNumber //NSValue中提供了把常用结构体转化成OC对象的方法 CGPoint p1 = CGPointMake(0, 1); CGRect r1 = CGRectMake(0, 0, 100, 100); NSValue *value1 = [NSValue valueWithPoint:p1]; NSValue *value2 = [NSValue valueWithRect:r1]; //NSValue--&gt;结构体变量 CGPoint p3 = [value1 pointValue]; NSArray *array = @[value1, value2]; NSLog(@&quot;%@&quot;, array); ​ return 0; } 123456789101112131415161718192021222324252627 ​- 异常处理 ```objective-c #import &lt;Foundation/Foundation.h&gt; int main(int argc, const char * argv[]) &#123; @try &#123; //有可能有问题的代码段会写在try块中 NSArray *array = [NSArray array]; //id obj = [array objectAtIndex:3]; &#125; @catch (NSException *exception)&#123; //如果有异常情况发生，会执行Catch块中的内容，把错误信息包装成一个NSException对象。 NSLog(@&quot;------:%@&quot;, exception); &#125; @finally &#123; //不管是否有异常，都会执行此代码段 NSLog(@&quot;finally&quot;); &#125; return 0; &#125; ​ NSDate 1234567891011121314151617181920212223242526272829303132#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; //创建一个当前时间点的日期对象,格林威治时间0时区的时间 NSDate *date = [NSDate date]; NSLog(@&quot;%@&quot;, date); NSDate *date1 = [NSDate dateWithTimeIntervalSinceNow:-24*60*60]; NSLog(@&quot;%@&quot;, date1); //获取时间戳 NSTimeInterval time = [date timeIntervalSince1970]; NSLog(@&quot;%lf&quot;, time); //日期格式化 //2015-05-09 13:10:10 NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; formatter.dateFormat = @&quot;yyyy/MM/dd HH:mm:ss&quot;; NSTimeZone *timeZone = [[NSTimeZone alloc] initWithName:@&quot;America/New_York&quot;]; formatter.timeZone = timeZone; NSString *dateString = [formatter stringFromDate:date]; NSLog(@&quot;%@&quot;, dateString); NSArray *zoneNames = [NSTimeZone knownTimeZoneNames]; NSLog(@&quot;%@&quot;, zoneNames); &#125; return 0;&#125; 下面做个小练习 定义一个球类，有颜色属性（只有黑白两种颜色）。生成30个小球（颜色随机生成），放入数组中，从此数组中拿出前15个小球，放入另一个数组中，并打印出此数组中各小球的颜色。 创建一个Ball类 Ball.h 12345678910111213#import &lt;Foundation/Foundation.h&gt;typedef enum &#123; Black, White &#125; Color;@interface Ball : NSObject&#123; Color _color;&#125; @property Color color; (id)ball; @end 1234567891011121314151617181920212223242526272829Ball.m```objective-c#import &quot;Ball.h&quot;@implementation Ball+ (id)ball &#123; Ball *ball = [[Ball alloc] init]; ball.color = arc4random() % 2 ? White : Black; return ball;&#125;- (NSString *)description &#123; // NSString *ballColor = nil;// if (self.color == White) &#123;// ballColor = @&quot;黑色的&quot;;// &#125;// else &#123;// ballColor = @&quot;白色的&quot;;// &#125;// return [NSString stringWithFormat:@&quot;小球的颜色是%@&quot;, ballColor]; return [NSString stringWithFormat:@&quot;%@&quot;, self.color ? @&quot;这个小球是白色的&quot;: @&quot;这个小球是黑色的&quot;]; &#125;@end 主函数： 12345678910111213141516171819202122#import &lt;Foundation/Foundation.h&gt;#import &quot;Ball.h&quot;int main(int argc, const char * argv[])&#123; NSMutableArray *ballArray = [NSMutableArray arrayWithCapacity:30]; for (NSUInteger i = 0; i &lt; 30; i++) &#123; [ballArray addObject:[Ball ball]]; &#125; NSRange range = NSMakeRange(0, 15); NSArray *ballSubArray = [ballArray subarrayWithRange:range]; for (Ball* obj in ballSubArray) &#123; NSLog(@&quot;%@&quot;, obj); &#125; return 0;&#125; ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[定时器的用法总结]]></title>
      <url>%2F2017%2F01%2F07%2F%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[初始化方法：有五种初始化方法，分别是 (1) + (NSTimer )timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation )invocation repeats:(BOOL)yesOrNo; 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; //初始化一个Invocation对象 NSInvocation * invo = [NSInvocation invocationWithMethodSignature:[[self class] instanceMethodSignatureForSelector:@selector(init)]]; [invo setTarget:self]; [invo setSelector:@selector(myLog)]; NSTimer * timer = [NSTimer timerWithTimeInterval:1 invocation:invo repeats:YES]; //加入主循环池中 [[NSRunLoop mainRunLoop]addTimer:timer forMode:NSDefaultRunLoopMode]; //开始循环 [timer fire];&#125; (2) + (NSTimer )scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation )invocation repeats:(BOOL)yesOrNo; 1NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 invocation:invo repeats:YES]; (3) + (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo; 1NSTimer * timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(myLog) userInfo:nil repeats:NO] (4) + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo; 1NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(myLog:) userInfo:@&quot;123&quot; repeats:YES] (5) - (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(id)t selector:(SEL)s userInfo:(id)ui repeats:(BOOL)rep 12NSTimer * timer = [[NSTimer alloc]initWithFireDate:[NSDate distantPast] interval:1 target:self selector:@selector(myLog:) userInfo:nil repeats:YES]; [[NSRunLoop mainRunLoop]addTimer:timer forMode:NSDefaultRunLoopMode]; 注意：五种初始化方法的异同： 参数repeats是指定是否循环执行，YES将循环，NO将只执行一次。 timerWithTimeInterval这两个类方法创建出来的对象如果不用 addTimer: forMode方法手动加入主循环池中，将不会循环执行。并且如果不手动调用fair，则定时器不会启动。 scheduledTimerWithTimeInterval这两个方法不需要手动调用fair，会自动执行，并且自动加入主循环池。 init方法需要手动加入循环池，它会在设定的启动时间启动。 ​ 成员变量 @property (copy) NSDate *fireDate; 这是设置定时器的启动时间，常用来管理定时器的启动与停止 1234//启动定时器 timer.fireDate = [NSDate distantPast]; //停止定时器 timer.fireDate = [NSDate distantFuture]; @property (readonly) NSTimeInterval timeInterval; 这个是一个只读属性，获取定时器调用间隔时间。 @property NSTimeInterval tolerance; 这是7.0之后新增的一个属性，因为NSTimer并不完全精准，通过这个值设置误差范围。 @property (readonly, getter=isValid) BOOL valid; 获取定时器是否有效 @property (readonly, retain) id userInfo; 获取参数信息 关于内存释放 如果我们启动了一个定时器，在某个界面释放前，将这个定时器停止，甚至置为nil，都不能是这个界面释放，原因是系统的循环池中还保有这个对象。所以我们需要这样做： 123456789101112131415161718-(void)dealloc&#123; NSLog(@&quot;dealloc:%@&quot;,[self class]);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; timer= [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(myLog:) userInfo:nil repeats:YES]; UIButton *btn = [[UIButton alloc]initWithFrame:CGRectMake(0, 0, 100, 100)]; btn.backgroundColor=[UIColor redColor]; [btn addTarget:self action:@selector(btn) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn];&#125;-(void)btn&#123; if (timer.isValid) &#123; [timer invalidate]; &#125; timer=nil; [self dismissViewControllerAnimated:YES completion:nil];&#125; 在官方文档中我们可以看到 [timer invalidate]是唯一的方法将定时器从循环池中移除。 ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分类的使用的注意点]]></title>
      <url>%2F2017%2F01%2F07%2F%E5%88%86%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
      <content type="text"><![CDATA[分类 分类的作用： 在不修改原始类模型的基础上，给某个类扩充方法。分类提供简单的方式将类的定义模块化到相应的分类中，不需要创建子类就可以扩充方法。 分类的语法： 分类的声明 @interface 原始类名 (分类名) //扩充方法的声明 @end 分类的实现 @implenmentation 原始类名（分类名） //扩充方法的实现 @end 分类思想的好处 使一个庞大的类可以分功能模块进行开发，可以分多人开发，更有利于团队合作。 分类命名的规则 分类名一般为模块的功能。 分类使用的注意要点 (1) 分类中不能扩充成员变量 (2) 在分类的方法中可以访问到原始类中定义的成员变量 (3) 分类中允许重新实现原始类中的方法，但是会覆盖掉原始类的中方法，导致其无法再使用，开发不建议在分类中重新实现原始类中的方法。 (4) 当原始类，不同的分类中有相同的方法时，遵循下列原则： 方法调用的优先顺序： 分类（最后参与编译的分类优先）–&gt;原始类。 ​ 延展 1.本质： 延展就是分类，但是只有一个@interface，方法的实现在原始类中进行 2.作用 （1）最初时设计的目的是在.m声明所有的私有方法，使当前类的公有方法和私有方法区分开来，使程序更规范。 （2）现在也可以在.h中加入延展，使类的方法按照功能模块进行区分，方便阅读和查找。Foundation框架中经常使用此种用法。 ​ 下面简单举个例子 创建一个Person类 Person.h 12345678910#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject&#123; NSInteger _age; NSArray *_array;&#125;@property NSInteger age; Person.m 1234567891011121314151617181920212223242526272829303132333435363738#import &quot;Person.h&quot;#import &quot;Person_p4.h&quot;//延展的作用：作私有方法的声明。在原始类中实现私有方法。//延展的本质就是分类@interface Person ()- (void)_showInfo;- (void)_demo;@end@interface Person ()//私有方法2//私有方法3@end@implementation Person- (void)work &#123; NSLog(@&quot;我在认真工作&quot;);&#125;//私有方法的命名规则：方法名前加下划线- (void)_showInfo &#123; NSLog(@&quot;我的信息是....&quot;);&#125;//私有方法1- (void)_demo &#123; NSLog(@&quot;demo&quot;);&#125;//私有方法2- (void)shabi &#123; NSLog(@&quot;asdasd&quot;);&#125;@end 创建一个Person的延展 Person_p4 123456#import &quot;Person.h&quot;//新建一个延展，只有.h文件，其中做方法的声明@interface Person ()- (void)shabi;@end 创建一个Person的分类 Person+Eat.h 1234567891011#import &quot;Person.h&quot;@interface Person (Eat)//分类中不能扩充成员变量//&#123;// NSInteger _count;//&#125;- (void)eat;@end Person+Eat.m 123456789101112#import &quot;Person+Eat.h&quot;@implementation Person (Eat)- (void)eat &#123; NSLog(@&quot;年龄是%li的人在使劲吃饭&quot;,_age);&#125;- (void)work &#123; // [self work]; NSLog(@&quot;Eat work&quot;);&#125;@end 创建另一个Person的分类 Person+Sleep.h 12345#import &quot;Person.h&quot;@interface Person (Sleep)- (void)sleep;@end Person+Sleep.m 123456789101112#import &quot;Person+Sleep.h&quot;@implementation Person (Sleep)- (void)sleep &#123; NSLog(@&quot;我在休息&quot;);&#125;- (void)work &#123; //[self work]; NSLog(@&quot;sleep work&quot;);&#125;@end 最后在主程序中： 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;#import &quot;Person+Eat.h&quot;#import &quot;Person+Sleep.h&quot;#import &quot;Person.h&quot;#import &quot;Person_p4.h&quot;int main(int argc, const char * argv[]) &#123; Person *p = [[Person alloc] init]; p.age = 10; [p shabi]; [p sleep]; [p eat]; [p work]; return 0;&#125; 结果： 12342017-01-07 22:03:19.480 02-分类中需要注意的问题[4824:111908] asdasd2017-01-07 22:03:19.482 02-分类中需要注意的问题[4824:111908] 我在休息2017-01-07 22:03:19.482 02-分类中需要注意的问题[4824:111908] 年龄是10的人在使劲吃饭2017-01-07 22:03:19.482 02-分类中需要注意的问题[4824:111908] sleep work]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5新手教学-表单（表单-表单元素）]]></title>
      <url>%2F2016%2F12%2F26%2FHTML5%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%A6-%E8%A1%A8%E5%8D%95%EF%BC%88%E8%A1%A8%E5%8D%95-%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%EF%BC%89%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;表单-表单元素（兼容性不是很好很少用）&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;label for=""&gt; 姓名: &lt;input type="text" name="name"/&gt;&lt;/label&gt;&lt;label for=""&gt; 地区: &lt;input type="text" name="area"/&gt;&lt;/label&gt;&lt;!--datalist需要和list属性一起使用。datalist里面的option注意一定要写在value里面，写在两个标签之间的会显示在右边--&gt;&lt;label for=""&gt; 课程： &lt;input type="text" list="course"/&gt;&lt;/label&gt;&lt;datalist id="course"&gt; &lt;option value="python"&gt;p&lt;/option&gt; &lt;option value="php"&gt;&lt;/option&gt; &lt;option value="photoshop"&gt;&lt;/option&gt; &lt;option value="java"&gt;&lt;/option&gt; &lt;option value="javascript"&gt;&lt;/option&gt; &lt;option value="软件工程"&gt;&lt;/option&gt;&lt;/datalist&gt;&lt;br/&gt;&lt;!--请求服务器的时候，公钥和私钥的问题用户将信息生成公钥和私钥，将私钥和信息一起进行二次加密，然后发给服务器，服务器用公钥解密。其中公钥和私钥是成对存在的。只能用对应的公钥才能解开对应的私钥--&gt;&lt;label for=""&gt; 加密类型：&lt;keygen name="security"/&gt; &lt;!--生成公钥--&gt;&lt;/label&gt;&lt;br/&gt;&lt;label for=""&gt; 结果：&lt;output&gt;一些结果&lt;/output&gt; &lt;!--和span差不多--&gt;&lt;/label&gt;&lt;br/&gt;&lt;label for=""&gt; 度量器：&lt;meter min="0" max="100" low="60" high="80" value="50"&gt;&lt;/meter&gt; 度量器：&lt;meter min="0" max="100" low="60" high="80" value="70"&gt;&lt;/meter&gt; 度量器：&lt;meter min="0" max="100" low="60" high="80" value="90"&gt;&lt;/meter&gt; &lt;!--low和high将颜色分为三类，根据value的值--&gt;&lt;/label&gt;&lt;br/&gt;&lt;label for=""&gt; &lt;input type="submit" value="保存"/&gt;&lt;/label&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS开发笔记-OC语言语法注意点]]></title>
      <url>%2F2016%2F12%2F25%2FiOS%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-OC%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
      <content type="text"><![CDATA[Objective-C是面向对象的语言，专门为iOS开发所设计，下面我就自己所学过程中遇到的注意点来告诉大家，OC（下面Objective-C的简写）语言的一些重点和注意点。 self self的定义： （1）self是方法中一个隐藏的形参，它是一个指针，谁调用了当前方法，self就指向谁。 （2）self出现在对象方法中，其指向了调用当前方法的实例对象。 （3）self出现在类方法中，其指向了当前类。 self的作用 （1）当方法中的局部变量和实例变量重名时，使用Self可以进行区分。 （2） 在方法中使用[self 方法名]来调用其它的方法，实现代码的复用。 self使用注意的要点 （1）不能在方法中使用Self来调用当前方法，会引发死循环。 （2）类方法不能使用self来调用对象方法，对象方法中不能使用Self来调用类方法。 （3）在类方法和对象方法中都不能使用self来调用普通函数。 （4）self只能出现在方法（类方法和对象方法）中。 ​ property和synthesize Xcode4.4之前 （1）@property自动生成set和get方法的声明 ​ @propterty NSInteger age; （2）@synthesize自动生成Set和get方法的实现 ​ @synthesize age = _age; ​ 左边的age表示Set和get方法名这里的age。 ​ 右边的_age表示要在set方法中对_age这个成员进行设置，在get方法中获取_age这个成员变量。 Xcode4.4之后 @property可以自动生成Set方法和get方法的声明和实现 ​ （1）自动生成成员变量_age ​ （2）自动生成get和set方法的声明 ​ （3）自动生成get和set方法的实现 规则： ​ （1）如果手动实现了set方法，则编译器只会自动生成get方法。 ​ （2）反之也相同。 ​ （3）如果手动实现了set方法和get方法，此时编译器不会自动生成成员变量。 利用@property的最佳方法 （1）声明带下划线的成员变量 （2）利用@property生成set和get方法的声明和实现。 继承 我们为什么要使用继承呢？ 建立类与类之间关联。 子类继承父类的所有实例变量和方法，避免了重复代码的出现，实现代码复用。 NSObject类：基类 OC中所有的类都必须直接或者间接的继承自NSObject，因为NSObject这个类中定义了很多常用的方法。如new, init，alloc 每个实例对象中的isa指针也是继承自NSObject. 继承使用注意要点 子类中不能定义和父类相同名称的实例变量 子类可以重写父类的方法，子类的方法必须和父类方法的原型完全一致，通过子类实例对象去调用该方法时，优先调用子类重写的方法，如果子类中没有重写则调用父类的方法。 继承关系的缺点 父类和子类的关系紧密，耦合性强，如果删除父类，则子类不能单独存在。 self在继承关系中的使用 在子类方法中使用Self调用其它方法时，如果子类重写了方法，则调用子类的方法，如果没重写，则调用父类的方法。 super关键字 当子类想保留父类的一些行为时，要强制使用super关键字来调用父类方法。 当super出现在对象方法中，会强制调用父类的对象方法。 当super出现在类方法中，会强制调用父类的类方法。 多态 什么是多态 一种类型，多种形态 在OC中表现为父类指针可以指向父类对象，也可以指向子类对象 直到运行期，才能根据父类指针实际指向的对象来确定调用哪个一类的方法，父类方法还是子类重写的方法。 多态产生的条件 必须有继承关系 子类要重写父类的方法 父类指针指向子类对象 多态的好处 使用多态后，可以用父类指针操纵所有的子类对象，程序的可扩展性就会增强。 多态使用的限制 父类指针不能调用子类新增的方法。 下面使用最简单的打印机的例子 父类：Printer 123- (void)print &#123; NSLog(@&quot;打印机在打印&quot;);&#125; 彩色打印子类：ColorPrinter 1234//重写父类的print方法- (void)print &#123; NSLog(@&quot;彩色打印机打印彩色效果&quot;);&#125; 黑白打印子类：BlackPrinter 1234//重写父类的print方法- (void)print &#123; NSLog(@&quot;黑白打印机打印黑白效果&quot;);&#125; 接下来见证奇迹的时刻到了： 12Printer *printer = [BlackPrinter new];[printer print]; 虽然创建的对象是父类，但是初始化的时候是其中一个子类的，所以运行之后打印出来的就是子类的方法（前提是重写父类的方法，然后调用的方法也是重写的这个方法名） 打印结果如下： 1黑白打印机打印黑白效果 ​ import #import和#include的区别 #include多次导入同一文件，会导致重复包含。 #import多次导入，在第二次导入时，会自动判断之前此文件是否已被导入过，如果已经导入则不做导入操作。 #import可以确保头文件只被导入一次。 @class和#import的区别 @class告诉编译器该类是一个类名，但是这个类具体有什么样的实例变量和方法无法确定。 #import XXX.h是一个预处理命令，把包含的文件的全部内容插入当前文件中来。 尽量在头文件中使用@class,在源文件一般使用#import。 @class的优点 （1）可以避免循环引用引起的嵌套包含 （2）如果一个工程中有多个文件#import了同一个头文件，当头文件需要修改时，所有包含了此头文件的文件都需要重新进行编译，编译效率较低，而@class不需要重新编译。 构造方法 子类重写构造方法的规则： 一定要调用父类的init方法，初始化从父类继承过来的成员变量。 判断父类成员是否初始化成功，如果成功才有必要去初始化子类新增的成员变量 返回经过了初始后的当前实例对象self 自定义的构造方法的规范： 一定是对象方法。 返回值类型必须为id类型。 方法名以init开头，如果传参数,init后接With。 子类对象的初始化过程： 首选调用NSObject类的init方法–》Person类（Student父类）的init方法–》Student类的init方法 1 Student *s = [[Student alloc] init]; alloc init组合：alloc:分配存储空间；init:初始化。初始化方法以init开头，如果初始化失败返回nil。 类的本质 类也是对象，类型为Class,也叫类对象，Person对象叫实例对象。 类就是类对象，因此可以直接用类对象来调用类方法。 获取类方法的方法 1、对象方法：[p class]; 2、类方法：[Person class]; 类的加载和初始化过程 1、+ load:类对象加载后调用的方法 当程序开始运行时，会加载当前项目中所有的类，加载完成后自动调用+load方法，只调用一次。 2、 + initialize：类对象初始化的方法。 当程序中第一次使用某个类时，会调用+ initialize方法，只调用一次。 类对象加载和初始化的规则： （1）先加载父类，再加载子类。 （2）如果使用子类实例对象，则先初始化父类对象，再初始化子类对象。 123456789//通过对象获取类对象 Class c1 = [p1 class];//类对象在内存中只有一个，一个类对应一个类对象//通过类方法获取类对象 Class c4 = [Person class];//类就是类对象，类名就是类对象 Person *p = [[Person alloc] init]; Class c = [p class]; description方法 需求：想直接输出实例对象，把对象的所有成员变量的值全部一一输出。 -description方法–》决定了以%@输出一个实例对象的结果 （1）方法的返回值是NSString *，把这个字符串输出到屏幕上。 （2）NSObject类的-description方法默认返回的是&lt;类名：实例对象的内存地址&gt; （3）如果想根据需求进行处理，则在当前类中重写-description方法，把所有的实例变量按照格式拼接成一个字符串输出，方便用户进行查看。 +description方法–》决定了以%@输出一个类对象的结果 （1）方法的返回值是NSString *，把这个字符串输出到屏幕上。 （2）NSObject类的+description方法默认返回的是类名。 （3）如果想输出其它内容，则重写类方法。 直接在类里面书写下面的代码，然后再输出该累的对象，然后会自动执行对象方法；同时类方法也是同样的使用方法 1234567- (NSString *)description &#123; return [NSString stringWithFormat:@&quot;age=%li,name=%@&quot;,_age,_name];&#125;+ (NSString *)description &#123; return @&quot;helloworld&quot;;&#125; 12345Person *p = [[Person alloc] initWithAge:10 andName:@ &quot;kathy&quot;]; NSLog(@&quot;%@&quot;, p);Class c = [p class];NSLog(@&quot;%@&quot;, c); 结果： 122016-12-25 19:54:50.340 06-description方法[10195:373710] age=10,name=kathy2016-12-25 19:54:50.341 06-description方法[10195:373710] helloworld SEL类型 封装成SEL类型的目的，可以通过两种方式来调用方法 （1）方法名直接调用 （2）传SEL类型的数据去找到方法的入口地址，间接调用方法。 包装成selector的语法 （1）无参 ​ [p performSelector:@selector(demo)]; （2）带参数的 ​ [p performSelector:s3 withObject:@”kathy” withObject:@”13588099765”]; OC中的私有方法：在.m在定义的方法，在.h没有声明。 可以包装成selector来调用私有方法。 字符串对象转换成selector的函数 SEL s = NSSelectorFromString(name); selector的作用： 本质类似于C语言的回调函数，主要用于两个对象之间的通信。 123456789101112//方法名包装成一个selector数据,进行方法调用 SEL s1 = @selector(demo); SEL s2 = @selector(demo:); SEL s3 = @selector(setName:andTel:);//调用私有方法 [p performSelector:@selector(showInfo)]; //只知道方法名，而方法名是一个字符串，可以把字符串对象转换为一个SEL类型的数据 NSString *name = @&quot;showInfo&quot;; SEL s = NSSelectorFromString(name); [p performSelector:s]; ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5新手教学-表单（输入类型）]]></title>
      <url>%2F2016%2F12%2F25%2FHTML5%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%A6-%E8%A1%A8%E5%8D%95%EF%BC%88%E8%BE%93%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%89%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt; &lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; label &#123; display: block; &#125; input &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;fieldset&gt; &lt;legend&gt;输入类型&lt;/legend&gt; &lt;label for="demo"&gt; email:&lt;input type="email" id="demo"&gt; &lt;/label&gt; &lt;label&gt; tel:&lt;input type="tel"&gt; &lt;/label&gt; &lt;label&gt; url:&lt;input type="url"&gt; &lt;/label&gt; &lt;label&gt; number:&lt;input type="number" step="3" max="10" min="2"&gt; &lt;/label&gt; &lt;label&gt; search:&lt;input type="search"&gt; &lt;/label&gt; &lt;!-- 上面的几个大胆的用，下面的带有选择的使用 --&gt; &lt;label&gt; range:&lt;input type="range" value="80"&gt; &lt;/label&gt; &lt;label&gt; color:&lt;input type="color" &gt; &lt;/label&gt; &lt;label&gt; time:&lt;input type="time" &gt; &lt;/label&gt; &lt;label&gt; date:&lt;input type="date" &gt; &lt;/label&gt; &lt;label&gt; datetime:&lt;input type="datetime" &gt; &lt;/label&gt; &lt;label&gt; month:&lt;input type="month" &gt; &lt;/label&gt; &lt;label&gt; week:&lt;input type="week " &gt; &lt;/label&gt; &lt;label&gt; &lt;input type="submit" value="提交"&gt; &lt;/label&gt; &lt;/fieldset&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5新手教学-多媒体]]></title>
      <url>%2F2016%2F12%2F22%2FHTML5%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%A6-%E5%A4%9A%E5%AA%92%E4%BD%93%2F</url>
      <content type="text"><![CDATA[HTML5新增的音频标签（audio）和视频标签（video），基本使用方法见下面的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;多媒体&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;!-- 音频 --&gt; &lt;audio src="See You Again.mp3" controls autoplay loop="3"&gt;&lt;/audio&gt; &lt;!-- controls:页面显示音频播放器的一些控件 autoplay:页面显示后立即播放 loop:循环播放几次 --&gt; &lt;!-- 有些浏览器不支持音频格式的采用下面方法来兼容 --&gt; &lt;audio controls&gt; &lt;source src="See You Again.mp3"&gt; &lt;source src="See You Again.wav"&gt; &lt;source src="See You Again.ogg"&gt; 如果浏览器不支持这个H5标签的话，显示这段文字 &lt;/audio&gt; &lt;!-- 视频 --&gt; &lt;video src="movie.mp4" width="300" height="400" controls autoplay loop="3"&gt;&lt;/video&gt; &lt;!-- controls:页面显示视频播放器的一些控件 autoplay:页面显示后立即播放 loop:循环播放几次 width:设置视频窗口宽度 height:设置视频窗口宽高度 但是宽高会自动调整。因为视频不会拉伸，所以浏览器会按照视频的比例有所调整，不像img标签，图片标签会拉伸 --&gt; &lt;!-- 有些浏览器不支持视频格式的采用下面方法来兼容 --&gt; &lt;video controls&gt; &lt;source src="movie.mp4"&gt; &lt;source src="movie.wav"&gt; &lt;source src="movie.ogg"&gt; 如果浏览器不支持这个H5标签的话，显示这段文字 &lt;/video&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[H5新手教学-语义化标签]]></title>
      <url>%2F2016%2F12%2F21%2FH5%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%A6-%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%2F</url>
      <content type="text"><![CDATA[HTML5其实并不是新的语言，相比于HTML来说只是多了几个新的标签，属性而已。下面的代码将首先介绍几个常用的HTML5的语义化标签。所谓语义化标签就是带有语义的标签，本质还是div和span。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;语义化标签&lt;/title&gt; &lt;!-- H5增加了大量的更有意义的语义标签，更有利于搜索引擎或辅助设备来理解HTML页面内容,使用方法和普通的标签一样，并不会有什么样式 --&gt; &lt;style type="text/css"&gt; header &#123; height: 100px; width: 980px; margin: 0 auto;/*页面居中处理*/ border: 1px solid #ccc; &#125; nav &#123; background-color: red; &#125; section &#123; height: 600px; width: 980px; margin: 0 auto; background-color: pink; &#125; article &#123; height: 100%; width: 800px; float: left; background-color: blue; &#125; aside &#123; width: 180px; float: right; height: 100%; background-color: orange; &#125; footer &#123; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- header:页眉 --&gt; &lt;header&gt; &lt;!-- nav:导航栏 --&gt; &lt;nav&gt; &lt;a href="#"&gt;首页&lt;/a&gt; &lt;a href="#"&gt;新闻&lt;/a&gt; &lt;a href="#"&gt;资讯&lt;/a&gt; &lt;/nav&gt; &lt;/header&gt; &lt;!-- section:区块 --&gt; &lt;section class="container"&gt; &lt;!-- article:文章 --&gt; &lt;article&gt; 主题文章 &lt;!-- progress:进度条 浏览器的样式不怎么兼容，样式css也不怎么能修改--&gt; &lt;progress min="0" max="100" value="70"&gt;&lt;/progress&gt; &lt;/article&gt; &lt;!-- aside:侧边栏 --&gt; &lt;aside&gt; &lt;a href="#"&gt;其他链接&lt;/a&gt; &lt;/aside&gt; &lt;/section&gt; &lt;!-- footer:页脚 --&gt; &lt;footer&gt;Feyddy版权所有&lt;/footer&gt; &lt;!-- 本质上新语义标签与&lt;div&gt;\&lt;span&gt;没有区别，只是其具有语义性。 --&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[修改UITextField的光标颜色]]></title>
      <url>%2F2016%2F12%2F19%2F%E4%BF%AE%E6%94%B9UITextField%E7%9A%84%E5%85%89%E6%A0%87%E9%A2%9C%E8%89%B2%2F</url>
      <content type="text"><![CDATA[有时候，我们的背景色调比较暗，因此需要亮点的光标来显示textField的输入区域。于是我们可以通过以下的方法去改变： 通过xib来修改 通过一句代码 textField.tintColor = [UIColor whiteColor]; 封装一个UITextField为FDLoginRegisterTextField 1234567//通过xib加载- (void)awakeFromNib&#123; //修改光标颜色 self.tintColor = [UIColor whiteColor]; self.textColor = [UIColor whiteColor];&#125; 然后在xib中设置类别 ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS开发小技巧]]></title>
      <url>%2F2016%2F12%2F18%2FiOS%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[设置按钮圆角： 1、利用纯代码 12self.loginButton.layer.cornerRadius = 5;self.loginButton.layer.masksToBounds = YES;//设置按钮里面的内容也会切换成圆角(如按钮的图片） 2、利用KVC 12[self.loginButton setValue:@5 forKeyPath:@&quot;layer.cornerRadius&quot;];[self.loginButton setValue:@YES forKeyPath:@&quot;layer.masksToBounds&quot;]; 3、xib里面 UIView动画的原理以及根据约束条件来设置动画的方法（layoutIfNeeded） 12345678910111213if (self.showLoginOrRegister.constant) &#123; self.showLoginOrRegister.constant = 0; [button setTitle:@&quot;注册帐号&quot; forState:UIControlStateNormal];&#125;else &#123; self.showLoginOrRegister.constant = -KscreenWidth; [button setTitle:@&quot;已有帐号？&quot; forState:UIControlStateNormal];&#125;[UIView animateWithDuration:0.25 animations:^&#123; //强制刷新界面，然最新的约束立马刷新到UI [self.view layoutIfNeeded]; //一般这个方法里面可以直接修改UI的frame值，这样的话才有动画效果。&#125;]; 当前一个界面弹出了键盘，切换界面的时候，让键盘退出 //退出键盘 1[self.view endEditing:YES]; 根据按钮的不同状态来设置不同的文字，使用xib]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义图上字下的Button]]></title>
      <url>%2F2016%2F12%2F17%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E4%B8%8A%E5%AD%97%E4%B8%8B%E7%9A%84Button%2F</url>
      <content type="text"><![CDATA[在开发过程中，有时候系统自带的按钮风格不满足我们的需求。这个时候的最佳方法就是自定义按钮。 接下来，我自定义一个图片在上，文字在下的按钮。 123456789101112131415161718192021222324252627282930313233343536#import &quot;FDButton.h&quot;@implementation FDButton//为了适应xib文件-(id)initWithCoder:(NSCoder *)aDecoder&#123; if (self=[super initWithCoder:aDecoder]) &#123; [self commonInit]; &#125; return self;&#125;-(id)initWithFrame:(CGRect)frame&#123; if (self=[super initWithFrame:frame]) &#123; [self commonInit]; &#125; return self;&#125;//常用属性设置-(void)commonInit&#123; self.titleLabel.textAlignment = NSTextAlignmentCenter; self.imageView.contentMode = UIViewContentModeScaleAspectFit; self.titleLabel.font = [UIFont systemFontOfSize:14];&#125;//文字的尺寸位置设置-(CGRect)titleRectForContentRect:(CGRect)contentRect&#123; CGFloat titleX = 0; CGFloat titleY = contentRect.size.height *0.75; CGFloat titleW = contentRect.size.width; CGFloat titleH = contentRect.size.height - titleY; return CGRectMake(titleX, titleY, titleW, titleH);&#125;//图片的尺寸位置设置-(CGRect)imageRectForContentRect:(CGRect)contentRect&#123; CGFloat imageW = CGRectGetWidth(contentRect); CGFloat imageH = contentRect.size.height * 0.7; return CGRectMake(0, 0, imageW, imageH);&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[修改状态栏样式]]></title>
      <url>%2F2016%2F12%2F14%2F%E4%BF%AE%E6%94%B9%E7%8A%B6%E6%80%81%E6%A0%8F%E6%A0%B7%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[使用UIApplication来管理1[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent]; 在Info.plist中做了图中的配置,可能会出现以下警告信息 使用UIViewController来管理 123456@implementation XMGLoginRegisterViewController- (UIStatusBarStyle)preferredStatusBarStyle&#123; return UIStatusBarStyleLightContent;&#125;@end 详情请参考：https://my.oschina.net/shede333/blog/304560]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[文字内容换行]]></title>
      <url>%2F2016%2F12%2F13%2F%E6%96%87%E5%AD%97%E5%86%85%E5%AE%B9%E6%8D%A2%E8%A1%8C%2F</url>
      <content type="text"><![CDATA[如何让storyboard\xib中的文字内容换行 快捷键: option + 回车键 在storyboard\xib输入\n是无法实现换行的 在代码中输入\n是可以实现换行的 1self.label.text = @&quot;534534534\n5345345\n5345&quot;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[frame、bounds、contentOffset以及contentInset的认识]]></title>
      <url>%2F2016%2F12%2F12%2Fframe%E3%80%81bounds%E3%80%81contentOffset%E4%BB%A5%E5%8F%8AcontentInset%E7%9A%84%E8%AE%A4%E8%AF%86%2F</url>
      <content type="text"><![CDATA[frame和bounds的重新认识 frame 以父控件 内容的左上角为坐标原点, 计算出的控件自己 矩形框的位置和尺寸 bounds 以控件自己 内容的左上角为坐标原点, 计算出的控件自己 矩形框的位置和尺寸 概括 frame.size == bounds.size scrollView.bounds.origin == scrollView.contentOffset bounds和frame的区别 矩形框和内容的理解 矩形框 控件自己的显示位置和尺寸 内容 控件内部的东西,比如它的子控件 contentInset的调整 默认情况下, 如果一个控制器A处在导航控制器管理中, 并且控制器A的第一个子控件是UIScrollView, 那么就会自动调整这个UIScrollView的contentInset UIEdgeInsetsMake(64, 0, 0, 0) // 有导航栏 UIEdgeInsetsMake(20, 0, 0, 0) // 没有导航栏 默认情况下, 如果一个控制器A处在导航控制器管理中, 并且导航控制器又处在UITabBarController管理中, 并且控制器A的第一个子控件是UIScrollView, 那么就会自动调整这个UIScrollView的contentInset UIEdgeInsetsMake(64, 0, 49, 0) 如何禁止上述的默认问题? 1控制器A.automaticallyAdjustsScrollViewInsets = NO; 注：如果只有UITabBarController在管理而没有导航栏在管理的话，只能手动设置内容偏移量了 - UIEdgeInsetsMake(0, 0, 49, 0) 在使用UITableViewController过程中,可能会出现的错误123@interface TestTableViewController : UITableViewController@end&apos;-[UITableViewController loadView] instantiated view controller with identifier &quot;UIViewController-BYZ-38-t0r&quot; from storyboard &quot;Main&quot;, but didn&apos;t get a UITableView.&apos; 造成这个错误的原因 错误地将一个UIViewController当做UITableViewController来用 错误做法 正确做法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[抽取uiview的分类来实现设置frame的简单操作]]></title>
      <url>%2F2016%2F12%2F11%2F%E6%8A%BD%E5%8F%96uiview%E7%9A%84%E5%88%86%E7%B1%BB%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%AE%BE%E7%BD%AEframe%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[在开发过程中，我们有很多地方需要设置控件的width，height等frame属性，如：self.frame.size.width。 但是这样的操作难免比较繁琐，作为一个程序员，一定要想尽办法省去不必要的代码。这样不仅能节省时间，还能愉悦心情。因此，如果我们能直接写self.width就可以直接设置那不是更好吗？那就需要我们抽取一个UIView类，在里面大设特设。 先创建一个分类文件 按住cmd + N，创建一个UIView的分类。 为分类设置属性和创建setter和getter方法。 UIView+FDExtension.h 123456 \#import &lt;UIKit/UIKit.h&gt;@interface UIView (FDExtension)//加上前缀fd的原因是为了不与内部或其他三方的width属性值重名，防止混乱的造成@property (nonatomic, assign) CGFloat fd_width;@property (nonatomic, assign) CGFloat fd_height;@end - UIView+FDExtension.m 1234567891011121314151617181920212223 \#import &quot;UIView+FDExtension.h&quot;\@implementation UIView (FDExtension)\- (CGFloat)fd_height&#123; return self.frame.size.height;&#125;\- (void)setFd_height:(CGFloat)fd_height&#123; CGRect frame = self.frame; frame.size.height = fd_height; self.frame = frame;&#125;\- (CGFloat)fd_width&#123; return self.frame.size.width;&#125;\- (void)setFd_width:(CGFloat)fd_width&#123; CGRect frame = self.frame; frame.size.width = fd_width; self.frame = frame;&#125;@end 这样我们以后设置frame的宽高就不用self.frame.size.width，只需要self.fd_width就可以了。 不仅是宽高，其他的比如：x，y，center，top，left，right，bottom等属性的简便设置也是类似的。 UIView+FDExtension.h 123456789101112\#import &lt;UIKit/UIKit.h&gt;@interface UIView (FDExtension)//加上前缀fd的原因是为了不与内部或其他三方的width属性值重名，防止混乱的造成@property (nonatomic, assign) CGFloat fd_width;@property (nonatomic, assign) CGFloat fd_height;@property (nonatomic, assign) CGFloat fd_x;@property (nonatomic, assign) CGFloat fd_y;@property (nonatomic, assign) CGFloat fd_centerX;@property (nonatomic, assign) CGFloat fd_centerY;@property (nonatomic, assign) CGFloat fd_right;@property (nonatomic, assign) CGFloat fd_bottom;@end UIView+FDExtension.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081\#import &quot;UIView+FDExtension.h&quot;@implementation UIView (FDExtension)- (CGFloat)fd_height&#123; return self.frame.size.height;&#125;- (void)setFd_height:(CGFloat)fd_height&#123; CGRect frame = self.frame; frame.size.height = fd_height; self.frame = frame;&#125;- (CGFloat)fd_width&#123; return self.frame.size.width;&#125;- (void)setFd_width:(CGFloat)fd_width&#123; CGRect frame = self.frame; frame.size.width = fd_width; self.frame = frame;&#125;- (CGFloat)fd_x&#123; return self.frame.origin.x;&#125;- (void)setFd_x:(CGFloat)fd_x&#123; CGRect frame = self.frame; frame.origin.x = fd_x; self.frame = frame;&#125;- (CGFloat)fd_y&#123; return self.frame.origin.y;&#125;- (void)setFd_y:(CGFloat)fd_y&#123; CGRect frame = self.frame; frame.origin.y = fd_y; self.frame = frame;&#125;- (CGFloat)fd_centerX&#123; return self.center.x;&#125;- (void)setFd_centerX:(CGFloat)fd_centerX&#123; CGPoint center = self.center; center.x = fd_centerX; self.center = center;&#125;- (CGFloat)fd_centerY&#123; return self.center.y;&#125;- (void)setFd_centerY:(CGFloat)fd_centerY&#123; CGPoint center = self.center; center.y = fd_centerY; self.center = center;&#125;- (CGFloat)fd_right&#123; // return self.xmg_x + self.xmg_width; return CGRectGetMaxX(self.frame);&#125;- (CGFloat)fd_bottom&#123; // return self.xmg_y + self.xmg_height; return CGRectGetMaxY(self.frame);&#125;- (void)setFd_right:(CGFloat)fd_right&#123; self.fd_x = fd_right - self.fd_width;&#125;- (void)setFd_bottom:(CGFloat)fd_bottom&#123; self.fd_y = fd_bottom - self.fd_height;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义导航控制器，以及解决自定义导航控制器后右滑pop手势失效问题]]></title>
      <url>%2F2016%2F12%2F10%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%8C%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%90%8E%E5%8F%B3%E6%BB%91pop%E6%89%8B%E5%8A%BF%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[通过自定义导航控制器，来给所有push的控制器自动加上自定义的返回键。 只需要重写- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated这个push方法。重写的目的就是拦截所有push进来的子控制器。然后对他们进行返回键的设置。 123456789101112131415161718192021- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated&#123; if (self.childViewControllers.count &gt; 0) &#123; // 如果viewController不是最早push进来的子控制器 // 左上角 UIButton *backButton = [UIButton buttonWithType:UIButtonTypeCustom]; [backButton setImage:[UIImage imageNamed:@&quot;navigationButtonReturn&quot;] forState:UIControlStateNormal]; [backButton setImage:[UIImage imageNamed:@&quot;navigationButtonReturnClick&quot;] forState:UIControlStateHighlighted]; [backButton setTitle:@&quot;返回&quot; forState:UIControlStateNormal]; [backButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal]; [backButton setTitleColor:[UIColor redColor] forState:UIControlStateHighlighted]; [backButton sizeToFit]; // 这句代码放在sizeToFit后面 backButton.contentEdgeInsets = UIEdgeInsetsMake(0, -20, 0, 0); [backButton addTarget:self action:@selector(back) forControlEvents:UIControlEventTouchUpInside]; viewController.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithCustomView:backButton]; // 隐藏底部的工具条 viewController.hidesBottomBarWhenPushed = YES; &#125; // 所有设置搞定后, 再push控制器 [super pushViewController:viewController animated:animated];&#125; 这样我们会发现，push完后，右滑pop手势不起作用了。 解决方法： 在viewDidLoad方法里面重新设置手势代理self.interactivePopGestureRecognizer.delegate = self;。记得挂上代理&lt;UIGestureRecognizerDelegate&gt;。 实现代理方法 12345678910111213\/** \* 手势识别器对象会调用这个代理方法来决定手势是否有效 \* @return YES : 手势有效, NO : 手势无效 */\- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer&#123; // if (self.childViewControllers.count == 1) &#123; // 导航控制器中只有1个子控制器 // return NO; // &#125; // return YES; // 手势何时有效 : 当导航控制器的子控制器个数 &gt; 1就有效 return self.childViewControllers.count &gt; 1;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[导航栏内容的相关设置]]></title>
      <url>%2F2016%2F12%2F09%2F%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%86%85%E5%AE%B9%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[设置导航栏标题 self.navigationItem.title = @&quot;首页&quot;;// 标题(不建议使用self.title属性) 给导航栏的标题添加一个图片 self.navigationItem.titleView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;MainTitle&quot;]]; 导航栏左侧按钮图片设置两种状态：normal和highlight。创建一个button 123456UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; [button setImage:[UIImage imageNamed:@&quot;MainTagSubIcon&quot;] forState:UIControlStateNormal]; [button setImage:[UIImage imageNamed:@&quot;MainTagSubIconClick&quot;] forState:UIControlStateHighlighted]; [button addTarget:self action:@selector(tagClick) forControlEvents:UIControlEventTouchUpInside]; [button sizeToFit]; self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithCustomView:button]; 注：其中的按钮的设置有很多种方法： 12345678[button imageForState:UIControlStateNormal].size;button.currentImage.size;[button backgroundImageForState:UIControlStateNormal];button.currentBackgroundImage;[button titleForState:UIControlStateNormal];button.currentTitle;[button titleColorForState:UIControlStateNormal];button.currentTitleColor; 导航栏右侧设置两个按钮 123456789101112131415// 右边1 UIButton *settingButton = [UIButton buttonWithType:UIButtonTypeCustom]; [settingButton setImage:[UIImage imageNamed:@&quot;mine-setting-icon&quot;] forState:UIControlStateNormal]; [settingButton setImage:[UIImage imageNamed:@&quot;mine-setting-icon-click&quot;] forState:UIControlStateHighlighted]; [settingButton addTarget:self action:@selector(settingClick) forControlEvents:UIControlEventTouchUpInside]; [settingButton sizeToFit]; UIBarButtonItem *settingItem = [[UIBarButtonItem alloc] initWithCustomView:settingButton]; // 右边2 UIButton *moonButton = [UIButton buttonWithType:UIButtonTypeCustom]; [moonButton setImage:[UIImage imageNamed:@&quot;mine-moon-icon&quot;] forState:UIControlStateNormal]; [moonButton setImage:[UIImage imageNamed:@&quot;mine-moon-icon-click&quot;] forState:UIControlStateHighlighted]; [moonButton addTarget:self action:@selector(moonClick) forControlEvents:UIControlEventTouchUpInside]; [moonButton sizeToFit]; UIBarButtonItem *moonItem = [[UIBarButtonItem alloc] initWithCustomView:moonButton]; self.navigationItem.rightBarButtonItems = @[settingItem, moonItem]; 看到这里，很多有经验的人肯定认为我的水平不高，为什么呢？因为在创建button时很多重复代码。下面我就为UIBarButtonItem创建一个分类，来自定义UIBarButtonItem。 123456789+ (instancetype)itemWithImage:(NSString *)image highImage:(NSString *)highImage target:(id)target action:(SEL)action&#123; UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; [button setImage:[UIImage imageNamed:image] forState:UIControlStateNormal]; [button setImage:[UIImage imageNamed:highImage] forState:UIControlStateHighlighted]; [button addTarget:target action:action forControlEvents:UIControlEventTouchUpInside]; [button sizeToFit]; return [[self alloc] initWithCustomView:button];&#125; 分类里面只需要实现上面的代码就行了。 1self.navigationItem.leftBarButtonItem = [UIBarButtonItem itemWithImage:@&quot;MainTagSubIcon&quot; highImage:@&quot;MainTagSubIconClick&quot; target:self action:@selector(tagClick)]; 调用只需要一个方法。这样是不是就方便了很多呢！！！ 设置导航栏的返回键 注：在push的时候记得设置vc.hidesBottomBarWhenPushed = YES;，这样就能隐藏vc的tabbar了。 返回按钮如果不设置，系统是会自动提供的。但是系统的一般无法满足我们的需求。而且返回按钮的文字是和前一个控制器的title一样的。如果文字太长，系统就会显示为Back。 123456789101112//返回按钮 UIButton *backButton = [UIButton buttonWithType:UIButtonTypeCustom]; [backButton setImage:[UIImage imageNamed:@&quot;navigationButtonReturn&quot;] forState:UIControlStateNormal]; [backButton setImage:[UIImage imageNamed:@&quot;navigationButtonReturnClick&quot;] forState:UIControlStateHighlighted]; [backButton setTitle:@&quot;返回&quot; forState:UIControlStateNormal]; [backButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal]; [backButton setTitleColor:[UIColor redColor] forState:UIControlStateHighlighted]; [backButton sizeToFit]; [backButton addTarget:self action:@selector(backAction) forControlEvents:UIControlEventTouchUpInside]; //这句代码一定要放在sizeToFit后面 backButton.contentEdgeInsets = UIEdgeInsetsMake(0, -20, 0, 0);//设置整个按钮向左偏移20个单位 self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithCustomView:backButton]; 这里涉及到设置按钮的内边距。他可以设置button的文字、图片以及两者共同的偏移量。 123@property(nonatomic) UIEdgeInsets contentEdgeInsets UI_APPEARANCE_SELECTOR;@property(nonatomic) UIEdgeInsets titleEdgeInsets;@property(nonatomic) UIEdgeInsets imageEdgeInsets; 做到这里，肯定有人会问，如果我每一次push之后都要在新的控制器里面重复写上上面设置返回键的代码，那不是很繁琐吗？答案是肯定的。下面有两种方式来解决这个问题。 方法一：自定义BaseViewController 只需要在BaseViewController里面设置一次就行了，后面所有的控制器都继承自它即可。但是这种方式不建议使用。 这样子比较麻烦，每一次创建控制器都必须继承BaseViewController 有些控制器无法继承BaseViewController。例如：UITableViewController，UICollectionViewController。如果这两个继承了，他们很多的方法都必须自己手动添加书写，比较麻烦。 方法二：自定义导航栏控制器（推荐）。具体实现参考我的下一篇博客。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何给tabbar的中间添加一个不同于其他UITabBarItem的发布按钮]]></title>
      <url>%2F2016%2F12%2F08%2F%E5%A6%82%E4%BD%95%E7%BB%99tabbar%E7%9A%84%E4%B8%AD%E9%97%B4%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%90%8C%E4%BA%8E%E5%85%B6%E4%BB%96tabbarbuttond%E7%9A%84%E5%8F%91%E5%B8%83%E6%8C%89%E9%92%AE%2F</url>
      <content type="text"><![CDATA[很多的社交软件都有发布状态这一功能，例如：新浪微博。它的APP中的tabbar上中间有一个不同于其他四个风格的按钮，而且他的点击事件也是不一样的。那么我们该如何创建它呢？下面我来介绍创建它的两种方式。 第一种方式： 自定义一个UITabBarController。 在添加子控制器的时候，中间多添加一个自控制器来占用位置。 它的图片，文字等都不用设置。 通过懒加载的方式创建一个button，然后在viewWillApper:方法中添加到self.tabBar上就行了。 注：一定要添加在viewWillApper:方法中。因为当viewWillAppear:方法被调用的时候, tabBar内部已经添加了5个UITabBarButton。这样就可以实现一个效果 : [发布按钮]盖在其他UITabBarButton上面。 为什么一定要慵懒加载呢？ 因为viewWillApper:方法可能会执行多次，如果使用懒加载就只会创建以此按钮而已，后面无论添加多少次，都只是会出现一个按钮。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475\#import &quot;FDTabBarViewController.h&quot;@interface FDTabBarViewController ()/** 中间的发布按钮 */@property (nonatomic , strong) UIButton *publishButton;@end@implementation FDTabBarViewController\#pragma mark - 懒加载/** 发布按钮 */ - (UIButton *)publishButton&#123; if (!_publishButton) &#123; _publishButton = [UIButton buttonWithType:UIButtonTypeCustom]; _publishButton.frame = CGRectMake(0, 0, self.tabBar.frame.size.width / 5, self.tabBar.frame.size.height); _publishButton.center = CGPointMake(self.tabBar.frame.size.width * 0.5, self.tabBar.frame.size.height * 0.5); [_publishButton setImage:[UIImage imageNamed:@&quot;tabBar_publish_icon&quot;] forState:UIControlStateNormal]; [_publishButton setImage:[UIImage imageNamed:@&quot;tabBar_publish_click_icon&quot;] forState:UIControlStateHighlighted]; [_publishButton addTarget:self action:@selector(publishButtonAction) forControlEvents:UIControlEventTouchUpInside]; &#125; return _publishButton;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; /**** 设置所有UITabBarItem的文字属性 ****/ UITabBarItem *item = [UITabBarItem appearance]; // 普通状态下的文字属性 NSMutableDictionary *normalAttrs = [NSMutableDictionary dictionary]; normalAttrs[NSFontAttributeName] = [UIFont systemFontOfSize:14]; normalAttrs[NSForegroundColorAttributeName] = [UIColor grayColor]; [item setTitleTextAttributes:normalAttrs forState:UIControlStateNormal]; // 选中状态下的文字属性 NSMutableDictionary *selectedAttrs = [NSMutableDictionary dictionary]; selectedAttrs[NSForegroundColorAttributeName] = [UIColor darkGrayColor]; [item setTitleTextAttributes:selectedAttrs forState:UIControlStateSelected]; /**** 添加子控制器 ****/ [self setupOneChildViewController:[[UITableViewController alloc] init] title:@&quot;精华&quot; image:@&quot;tabBar_essence_icon&quot; selectedImage:@&quot;tabBar_essence_click_icon&quot;]; [self setupOneChildViewController:[[UITableViewController alloc] init] title:@&quot;新帖&quot; image:@&quot;tabBar_new_icon&quot; selectedImage:@&quot;tabBar_new_click_icon&quot;]; //中间用来占位置的子控制器 [self setupOneChildViewController:[[UIViewController alloc] init] title:nil image:nil selectedImage:nil]; [self setupOneChildViewController:[[UIViewController alloc] init] title:@&quot;关注&quot; image:@&quot;tabBar_friendTrends_icon&quot; selectedImage:@&quot;tabBar_friendTrends_click_icon&quot;]; [self setupOneChildViewController:[[UITableViewController alloc] init] title:@&quot;我&quot; image:@&quot;tabBar_me_icon&quot; selectedImage:@&quot;tabBar_me_click_icon&quot;];&#125;/** * 为什么要在viewWillAppear:方法中添加发布按钮? * 当viewWillAppear:方法被调用的时候, tabBar内部已经添加了5个UITabBarButton * 就可以实现一个效果 : [发布按钮]盖在其他UITabBarButton上面 */- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; /**** 增加一个发布按钮 ****/ [self.tabBar addSubview:self.publishButton];//重复添加只会添加一次而已&#125;/** * 初始化一个子控制器 * @param vc 子控制器 * @param title 标题 * @param image 图标 * @param selectedImage 选中的图标 */- (void)setupOneChildViewController:(UIViewController *)vc title:(NSString *)title image:(NSString *)image selectedImage:(NSString *)selectedImage&#123; vc.view.backgroundColor = FDRandomColor; vc.tabBarItem.title = title; //这样判断的好处就是防止控制台打印出警告。因为如果image为nil或者@“”的时候都会打印出警告。 if (image.length) &#123;// 图片名有具体值 vc.tabBarItem.image = [UIImage imageNamed:image]; vc.tabBarItem.selectedImage = [UIImage imageNamed:selectedImage]; &#125; [self addChildViewController:vc];&#125;\#pragma mark - 点击事件监听- (void)publishButtonAction &#123; DLOG(@&quot;事件点击了&quot;);&#125;@end 第二种方式：通过直接更换TabBar来实现 自定义一个UITabBarController。 自定义一个UITabBar，重写layoutSubviews方法。注：[super layoutSubviews]方法要先写上。 layoutSubviews方法中遍历tabBar的所有子视图，来获取所有的UITabBarButton，然后一个一个设置他们的frame,让中间空出一个按钮的大小。 通过懒加载的方式创建一个button，然后在layoutSubviews方法中设置发布按钮的frame。注：因为UITabBarButton是苹果内部的类型，所以无法直接使用，所以在遍历子视图判断的时候无法直接用类来判断，而是通过转换成字符串的形式来的判断。 subview.class != NSClassFromString(@&quot;UITabBarButton&quot;) 具体实现如下： 自定义的FDTabBar类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960\#import &quot;FDTabBar.h&quot;@interface FDTabBar()/** 中间的发布按钮 */@property (nonatomic, weak) UIButton *publishButton;@end@implementation FDTabBar\#pragma mark - 懒加载/** 发布按钮 */- (UIButton *)publishButton&#123; if (!_publishButton) &#123; UIButton *publishButton = [UIButton buttonWithType:UIButtonTypeCustom]; publishButton.backgroundColor = FDRandomColor; [publishButton setImage:[UIImage imageNamed:@&quot;tabBar_publish_icon&quot;] forState:UIControlStateNormal]; [publishButton setImage:[UIImage imageNamed:@&quot;tabBar_publish_click_icon&quot;] forState:UIControlStateHighlighted]; [publishButton addTarget:self action:@selector(publishClick) forControlEvents:UIControlEventTouchUpInside]; [self addSubview:publishButton]; _publishButton = publishButton; &#125; return _publishButton;&#125;\#pragma mark - 初始化/** * 布局子控件 */- (void)layoutSubviews&#123; [super layoutSubviews]; // NSClassFromString(@&quot;UITabBarButton&quot;) == [UITabBarButton class] // NSClassFromString(@&quot;UIButton&quot;) == [UIButton class] /**** 设置所有UITabBarButton的frame ****/ // 按钮的尺寸 CGFloat buttonW = self.frame.size.width / 5; CGFloat buttonH = self.frame.size.height; CGFloat buttonY = 0; // 按钮索引 int buttonIndex = 0; for (UIView *subview in self.subviews) &#123; // 过滤掉非UITabBarButton // if (![@&quot;UITabBarButton&quot; isEqualToString:NSStringFromClass(subview.class)]) continue; if (subview.class != NSClassFromString(@&quot;UITabBarButton&quot;)) continue; // 设置frame CGFloat buttonX = buttonIndex * buttonW; if (buttonIndex &gt;= 2) &#123; // 右边的2个UITabBarButton buttonX += buttonW; &#125; subview.frame = CGRectMake(buttonX, buttonY, buttonW, buttonH); // 增加索引 buttonIndex++; &#125; /**** 设置中间的发布按钮的frame ****/ self.publishButton.frame = CGRectMake(0, 0, buttonW, buttonH); self.publishButton.center = CGPointMake(self.frame.size.width * 0.5, self.frame.size.height * 0.5);&#125;\#pragma mark - 监听- (void)publishClick&#123; DLOG(@&quot;点击发布按钮&quot;);&#125;@end 注：在设置中间的发布按钮的frame的时候，一定要先设置size然后再设置center。 自定义的FDTabBarViewController类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647\#import &quot;FDTabBarViewController.h&quot;\#import &quot;FDTabBar.h&quot;@interface FDTabBarViewController ()@end@implementation FDTabBarViewController- (void)viewDidLoad &#123; [super viewDidLoad]; /**** 设置所有UITabBarItem的文字属性 ****/ UITabBarItem *item = [UITabBarItem appearance]; // 普通状态下的文字属性 NSMutableDictionary *normalAttrs = [NSMutableDictionary dictionary]; normalAttrs[NSFontAttributeName] = [UIFont systemFontOfSize:14]; normalAttrs[NSForegroundColorAttributeName] = [UIColor grayColor]; [item setTitleTextAttributes:normalAttrs forState:UIControlStateNormal]; // 选中状态下的文字属性 NSMutableDictionary *selectedAttrs = [NSMutableDictionary dictionary]; selectedAttrs[NSForegroundColorAttributeName] = [UIColor darkGrayColor]; [item setTitleTextAttributes:selectedAttrs forState:UIControlStateSelected]; /**** 添加子控制器 ****/ [self setupOneChildViewController:[[UITableViewController alloc] init] title:@&quot;精华&quot; image:@&quot;tabBar_essence_icon&quot; selectedImage:@&quot;tabBar_essence_click_icon&quot;]; [self setupOneChildViewController:[[UITableViewController alloc] init] title:@&quot;新帖&quot; image:@&quot;tabBar_new_icon&quot; selectedImage:@&quot;tabBar_new_click_icon&quot;]; [self setupOneChildViewController:[[UIViewController alloc] init] title:@&quot;关注&quot; image:@&quot;tabBar_friendTrends_icon&quot; selectedImage:@&quot;tabBar_friendTrends_click_icon&quot;]; [self setupOneChildViewController:[[UITableViewController alloc] init] title:@&quot;我&quot; image:@&quot;tabBar_me_icon&quot; selectedImage:@&quot;tabBar_me_click_icon&quot;]; /**** 更换TabBar ****/ // self.tabBar = [[XMGTabBar alloc] init]; [self setValue:[[FDTabBar alloc] init] forKeyPath:@&quot;tabBar&quot;];&#125;/** * 初始化一个子控制器 * * @param vc 子控制器 * @param title 标题 * @param image 图标 * @param selectedImage 选中的图标 */- (void)setupOneChildViewController:(UIViewController *)vc title:(NSString *)title image:(NSString *)image selectedImage:(NSString *)selectedImage&#123; vc.view.backgroundColor = FDRandomColor; vc.tabBarItem.title = title; //这样判断的好处就是防止控制台打印出警告。因为如果image为nil或者@“”的时候都会打印出警告。 if (image.length) &#123;// 图片名有具体值 vc.tabBarItem.image = [UIImage imageNamed:image]; vc.tabBarItem.selectedImage = [UIImage imageNamed:selectedImage]; &#125; [self addChildViewController:vc];&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在设置一些控件的图片时，有些图片显示出来会自动渲染成蓝色]]></title>
      <url>%2F2016%2F12%2F07%2F%E5%9C%A8%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%BA%9B%E6%8E%A7%E4%BB%B6%E7%9A%84%E5%9B%BE%E7%89%87%E6%97%B6%EF%BC%8C%E6%9C%89%E4%BA%9B%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E5%87%BA%E6%9D%A5%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%B8%B2%E6%9F%93%E6%88%90%E8%93%9D%E8%89%B2%2F</url>
      <content type="text"><![CDATA[比如 设置tabBarItem的选中图片 1vc.tabBarItem.selectedImage = image; 我使用的图片都是灰色的，但是选中之后出现下面的效果 解决方案 再次产生一张不会进行渲染的图片 12345// 加载图片UIImage *tempImage = [UIImage imageNamed:@&quot;tabBar_essence_click_icon&quot;];// 产生一张不会进行自动渲染的图片UIImage *selectedImage = [tempImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];vc.tabBarItem.selectedImage = selectedImage; 直接在Assets.xcassets中设置（推荐）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[pch文件的设置以及宏定义的注意事项：（包含的oc与c的兼容问题）]]></title>
      <url>%2F2016%2F12%2F07%2Fpch%E6%96%87%E4%BB%B6%E7%9A%84%E8%AE%BE%E7%BD%AE%EF%BC%9A%EF%BC%88%E5%8C%85%E5%90%AB%E7%9A%84oc%E4%B8%8Ec%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
      <content type="text"><![CDATA[首先我们先建立一个pch文件，然后与项目进行配置。如下： 这种方法只能在本地读取到，因为这个路径是绝对的。但是如果在公司开发项目，一般好几个人一起开发。这个时候这个路径就会出现问题，最好使用相对路径。路径的设置为$(SRCROOT)+项目名+pch文件名。如下： 到这里我们的pch文件就和项目关联上了。 接下来如果在项目中需要兼容C语言文件的时候，就需要设置一下#ifdef __OBJC__。 否则会出现以下的错误提示： 具体实现方案： 123456789101112/*** 如果希望某些内容能拷贝到任何源代码文件(OC\C\C++等), 那么就不要写在#ifdef __OBJC__和#endif之间 ***//***** 在#ifdef __OBJC__和#endif之间的内容, 只会拷贝到OC源代码文件中, 不会拷贝到其他语言的源代码文件中 *****/\#ifdef __OBJC__/** * 日志 * 在Debug模式下，输出内容 */\#ifdef DEBUG\#define DLOG(...) NSLog(__VA_ARGS__)\#endif\#endif/***** 在#ifdef __OBJC__和#endif之间的内容, 只会拷贝到OC源代码文件中, 不会拷贝到其他语言的源代码文件中 *****/ 配置宏有两种方式 在pch文件中或者在每个类文件中创建代码来设置宏定义。 在Build Setting中配置宏。 如果项目中有些宏找不到, 可能是配置在Build Setting中 注意点:宏的名字不能全部是小写字母 如果宏的名字全部是小写, 会出现以下错误]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS中appearence的特殊用法]]></title>
      <url>%2F2016%2F12%2F06%2FiOS%E4%B8%ADappearence%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[在开发过程中，有时候需要对一些对象进行统一的属性设置，例如，对UITabBarItem的显示的文字属性进行统一设置。这样的话，我们就可以使用appearence来做，而不是一个一个UITabBarItem设置。 通过UITabBarItem的appearance对象统一设置：1234567891011/**** 设置所有UITabBarItem的文字属性 ****/UITabBarItem *item = [UITabBarItem appearance];// 普通状态下的文字属性NSMutableDictionary *normalAttrs = [NSMutableDictionary dictionary];normalAttrs[NSFontAttributeName] = [UIFont systemFontOfSize:14];normalAttrs[NSForegroundColorAttributeName] = [UIColor grayColor];[item setTitleTextAttributes:normalAttrs forState:UIControlStateNormal];// 选中状态下的文字属性NSMutableDictionary *selectedAttrs = [NSMutableDictionary dictionary];selectedAttrs[NSForegroundColorAttributeName] = [UIColor darkGrayColor];[item setTitleTextAttributes:normalAttrs forState:UIControlStateSelected]; 当然不仅仅是UITabBarItem对象可以使用，凡是在对象属性后面有UI_APPEARANCE_SELECTOR的字样的，都是可以通过appearence来统一设置。 注：必须在创建每个对象之前进行统一的设置。 如果在对象创建完成后还想通过appearence来设置属性，就必须先将视图移除，然后在添加上去。如下： 1234567891011121314151617181920212223242526272829303132333435363738\#import &quot;ViewController.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; UISwitch *s1 = [[UISwitch alloc] init]; s1.center = CGPointMake(100, 100); s1.on = YES; [self.view addSubview:s1]; UISwitch *s2 = [[UISwitch alloc] init]; s2.center = CGPointMake(200, 100); s2.on = YES; [self.view addSubview:s2]; UISwitch *s3 = [[UISwitch alloc] init]; s3.center = CGPointMake(300, 100); s3.on = YES; [self.view addSubview:s3];&#125;- (IBAction)changeColor:(UISegmentedControl *)sender &#123; switch (sender.selectedSegmentIndex) &#123; case 0: [UISwitch appearance].onTintColor = [UIColor redColor]; break; case 1: [UISwitch appearance].onTintColor = [UIColor blueColor]; break; case 2: [UISwitch appearance].onTintColor = [UIColor orangeColor]; break; default: break; &#125; //重新添加控件，如果不重新添加控件就不会刷新设置。 [self.view removeFromSuperview];//因为控制器的view都是强引用的，所以移除之后没有被销毁掉 [[UIApplication sharedApplication].keyWindow addSubview:self.view];&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新建控制器时自动加上一个前缀]]></title>
      <url>%2F2016%2F12%2F06%2F%E6%96%B0%E5%BB%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8A%A0%E4%B8%8A%E4%B8%80%E4%B8%AA%E5%89%8D%E7%BC%80%2F</url>
      <content type="text"><![CDATA[当我们在公司中开发项目的时候，一般每个公司都会在自己的项目代码类中加上一个前缀，来表明这是本公司创建的。那么怎么才能在我们创建类的时候就自动加上前缀呢？ 其实很简单，只需要按照下面图片展示的三步就可以轻松实现了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[APP的资源提取方法]]></title>
      <url>%2F2016%2F12%2F06%2FAPP%E7%9A%84%E8%B5%84%E6%BA%90%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[APP的资源提取方法打开iTunes,找到应用。(前提是你已经买过了) 将app拖到桌面上，然后将.api格式转换成.zip格式。 解压后打开文件，找到Payload文件夹里面的项目，右击显示包内容。 注：有时候你会发现图片较少，这时候你可以找到一个文件叫Assets.car。这个里面很多资源压缩在里面。但是不能像之前一样使用.zip的格式解压。 这时，我们需要一个工具cartool。 下载完成后打开直接运行生成cartool Finder打开cartool所在目录。 打开终端，cd到cartool所在目录。 创建一个接受解压后的图片的文件夹。（outputDirectory） 在终端中执行以下命令： ./cartool /xxx/Assets.car /xxx/outputDirectory 注：第一个xxx是Assets.car的路径，第二个xxx是图片接受文件夹的路径，二者缺一不可。 执行完成后，便可以显示出Assets.car里面的资源了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新手写swift应该注意什么]]></title>
      <url>%2F2016%2F12%2F06%2F%E6%96%B0%E6%89%8B%E5%86%99swift%E5%BA%94%E8%AF%A5%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%2F</url>
      <content type="text"><![CDATA[新手写Swift应该注意什么（Style）每个语言都有自己的推荐风格。显然OC与Swift有着不同的风格。但我们书写Swift代码的时候一定要用Swift的代码风格，而不是沿用OC的风格。 省略句末的分号Swift的语言风格就是越简洁越好。如果一行里面只有一句代码的话，代码的末尾就不需要写上分号了。 注：不写代码的情况只限于一行里面只有一句代码，其他情况建议直接换行。 12345//tableView设置 tableView.estimatedRowHeight = 200 tableView.rowHeight = UITableViewAutomaticDimension tableView.delegate = self tableView.dataSource = self 省略self.不在闭包里面的时候，如果要调用自身的属性或者方法时省略self.。这是苹果强烈建议的，因为这样可以使得代码变得简介。 12345678910//2.执行动画 UIView.animateWithDuration(1.0, animations: &#123; () -&gt; Void in self.tipLabel.transform = CGAffineTransformMakeTranslation(0, 44) &#125;) &#123; (_) -&gt; Void in UIView.animateWithDuration(1.0, delay: 2.0, options: UIViewAnimationOptions(rawValue: 0), animations: &#123; () -&gt; Void in self.tipLabel.transform = CGAffineTransformIdentity &#125;, completion: &#123; (_) -&gt; Void in self.tipLabel.hidden = true &#125;) &#125; 类型声明的一些注意点在声明变量的时候，:要紧跟变量名后面，但是类型与冒号之间需要一个空格。另外，字典类型的声明也是需要遵守这样的规则的。(可以使用SwiftLint来帮你检查) 12var a: String var dict: [String: AnyObject] 函数名的后面与{ }之间需要一个空格下面是标准的函数与法： 123override func viewDidLoad() &#123; super.viewDidLoad()&#125; 注： 二元操作符（+、-、*、/、%）的前后都有空格的，包含返回类型符号（-&gt;）。 对象初始化的时候不要调用init方法Swift语言通过()就已经调用对象的初始化方法了，因此不需要在调用init()。 12let btn = UIButton()//正确let btn = UIButton.init()//错误 函数参数命名规则因为OC的第一个参数名是省略的所以会把第一个参数名直接带到方法名上。但是Swift3.0之后，在方法调用时，第一个参数名也是会展现出来的。所以函数命名的时候要注意命名的简洁性，比如不需要再加什么：with、and等连接词了。 其他的相关风格可以参考：swift-style-guide]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown新手教程]]></title>
      <url>%2F2016%2F12%2F05%2FMarkdown%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[Markdown新手指南Markdown是一中电子邮件风格的标记语言，通常为程序员群体所用。为什么？在此，我们总结Markdown的优点如下： 纯文本，所以兼容性极强，可以用所有文本编辑器打开。 让你专注于文字而不是排版。 格式转换方便，Markdown的文本你可以轻松转换为html、电子书等。 Markdown的标记语法有极好的可读性。 标题标题分为多级标题，你只需要在标题文本前加上#，便可显示标题文本本格式。当然你还可以增加二级标题、三级标题等一共六级，只需要增加#的个数即可，标题的字号变相应的降低。 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 注：#和一级标题之间建议保留一个字符的空格，这是最标准的Markdown写法。 效果图如下：  一级到六级标题 列表说到列表，一般都会分为两种情况：有序列表和无序列表。但是对于Markdown来说都是同等的简单。 无序列表只需要在文字的前面加上1. 2. 3.就行了。例如： 1231. 文本2. 文本3. 文本 有序列表同样只要在文字前面加上-或者*即可，例如： -文本 -文本 -文本 注：-、*、1.和文本之间要保留一个字符的空格。列表案例截图如下： 邮箱、连接和图片当我们需要显示一串文字为邮箱或者链接地址的时候，可以使用&lt;example@example.com&gt;在Markdown中插入连接不需要其他的按钮，只需要[显示的文本](连接的地址 &quot;鼠标放到链接上弹出的文字提示&quot;)这样的语法即可。例如： [百度](http://www.baidu.com) 同样插入图片也不需要其他的按钮，只需要![图片的简介](图片的链接地址 &quot;鼠标放到链接上弹出的文字提示&quot;)这样写即可。例如： ![赵丽颖的图片](http://ww2.sinaimg.cn/large/e3aca1a1jw1fafxl66dmyj20sg0lcgnf.jpg) 插入链接和插入图片的效果图如下： 注：当我们页面的连接比较多的时候，可以统一写在页面的最下面。然后通过： 链接显示的文本 引用在我们写作的时候经常会应用到其他人的文字，这个时候加上引用就是必须的了，这个语法只需要在文字前加上&gt;即可，例如： &gt; 黑云压城城欲摧，甲光向日金鳞开。 注：&gt;和文本之间要保留一个字符的空格。最终的现实就是： 粗体和斜体Markdown的粗体和斜体都是比较简单的，用两个*包含一段文字就是粗体，用一个*包含的一段文字就是斜体，例如： *黑云压城城欲摧*,**甲光向日金鳞开** 最终显示的就是前面一句话为斜体，后面一句话为粗体。 案例截图： 注：当然你也可以使用标记_来替换*,效果是一样的。快捷键：斜体-Cmd + B ， 粗体-Cmd + I 代码引用需要引用代码的时候，如果你引用的代码不分行的话，可以使用``将其包起来。 但是如果有好几行的话就不行了。这时候你就可以用```放在代码行的首行和末行这样的方式。当然还有最简单的一种方法，那就是按Tab键。 效果图如下： 注：在使用```这种方法时，里面面的代码不要出现空行，否则是不会显示的。 扩展：标记代码的时候可以在```后面加上是哪种语言，这样代码显示的时候会根据不同的语言自动识别代码关键词，看上去十分美观，简洁易懂。具体可以参考：代码识别语言汇总 强制换行换行使用HTML里面的 &lt;br /&gt;。 水平分割线的使用我们可以使用三种方式创建水平分割线***、---、- - - -,他们都是显示在文字下面。 Headers头部Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： This is an H1This is an H2任何数量的 = 和 - 都可以有效果。 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： 这是 H1这是 H2这是 H6你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）： 这是 H1这是 H2这是 H3 角标一般在一片论文中会有很多其他论文观点的支持，因此在有些结论之后会加上引用论文的角标号。如下： 爱因斯坦相对论原理.^1 注：爱因斯坦相对论原理.[^1]这个是放在文章中的。[^1]:《相对论》.这个则会显示在文章的最底部。类似于参考文献 删除线为一段文字填上删除的横线，我们使用~~将文字前后包含即可。如下： ~~Strikethrough~~ 显示的效果： 表格下面是创建的一个简单的表格: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell 或者： First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell 效果如下： 通过添加冒号来设置内容的对齐方式： First Header Second Header Third Header Left Center Right Left Center Right 效果如下： 注释用html的注释，好像只有这样？ 转义字符Markdown中的转义字符为\，转义的有： \ 反斜杠 ` 反引号 * 星号 _ 下划线 {} 大括号 [] 中括号 () 小括号 # 井号 + 加号 - 减号 . 英文句号 ! 感叹号 段落缩进（空格）1234半方大的空白`&amp;ensp;`或`&amp;#8194;`看，飞碟全方大的空白`&amp;emsp;`或`&amp;#8195;`看，飞碟不断行的空白格`&amp;nbsp;`或`&amp;#160;`看，飞碟`&amp;emsp;&amp;emsp;`段落从此开始。 效果如下： 半方大的空白 或 看，飞碟 全方大的空白 或 看，飞碟 不断行的空白格 或 看，飞碟 段落从此开始。 字体、字号、颜色123456&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=12 face=&quot;黑体&quot;&gt;黑体&lt;/font&gt;&lt;font color=#00ffff size=3&gt;null&lt;/font&gt;&lt;font color=gray size=5&gt;gray&lt;/font&gt; 效果如下： 我是黑体字 我是微软雅黑 我是华文彩云 黑体 null gray 快捷键视图 切换是否显示预览窗口: Shift + Cmd + I 切换是否显示文本单词数量: Shift + Cmd + W 切换透明度: Shift + Cmd + T 切换浮动效果: Shift + Cmd + F 左边大小/右边大小 = 1/1: Cmd + 0 左边大小/右边大小 = 3/1: Cmd + + 左边大小/右边大小 = 1/3: Cmd + - 切换文本书写的方向: Cmd + L 全屏: Control + Cmd + F 行为 Copy HTML: Option + Cmd + C Strong: Select text, Cmd + B Emphasize: Select text, Cmd + I Inline Code: Select text, Cmd + K Strikethrough: Select text, Cmd + U Link: Select text, Control + Shift + L Image: Select text, Control + Shift + I Select Word: Control + Option + W Select Line: Shift + Cmd + L Select All: Cmd + A Deselect All: Cmd + D Convert to Uppercase: Select text, Control + U Convert to Lowercase: Select text, Control + Shift + U Convert to Titlecase: Select text, Control + Option + U Convert to List: Select lines, Control + L Convert to Blockquote: Select lines, Control + Q Convert to H1: Cmd + 1 Convert to H2: Cmd + 2 Convert to H3: Cmd + 3 Convert to H4: Cmd + 4 Convert to H5: Cmd + 5 Convert to H6: Cmd + 6 Convert Spaces to Tabs: Control + [ Convert Tabs to Spaces: Control + ] Insert Current Date: Control + Shift + 1 Insert Current Time: Control + Shift + 2 Insert entity &lt;: Control + Shift + , Insert entity &gt;: Control + Shift + . Insert entity &amp;: Control + Shift + 7 Insert entity Space: Control + Shift + Space Insert Scriptogr.am Header: Control + Shift + G Shift Line Left: Select lines, Cmd + [ Shift Line Right: Select lines, Cmd + ] New Line: Cmd + Return Comment: Cmd + / Hard Linebreak: Control + Return 编辑 Auto complete current word: Esc Find: Cmd + F Close find bar: Esc 提交 Post on Scriptogr.am: Control + Shift + S Post on Tumblr: Control + Shift + T 导出 Export HTML: Option + Cmd + E Export PDF: Option + Cmd + P]]></content>
    </entry>

    
  
  
</search>
